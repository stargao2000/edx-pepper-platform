// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.XModule = {
    /*
    Load a single module (either an edit module or a display module)
    from the supplied element, which should have a data-type attribute
    specifying the class to load
    */

    loadModule: function(element) {
      var error, module, moduleType;
      moduleType = $(element).data('type');
      if (moduleType === 'None') {
        return;
      }
      try {
        module = new window[moduleType](element);
        if ($(element).hasClass('xmodule_edit')) {
          $(document).trigger('XModule.loaded.edit', [element, module]);
        }
        if ($(element).hasClass('xmodule_display')) {
          $(document).trigger('XModule.loaded.display', [element, module]);
        }
        return module;
      } catch (_error) {
        error = _error;
        if (window.console && console.log) {
          return console.error("Unable to load " + moduleType + ": " + error.message);
        } else {
          throw error;
        }
      }
    },
    /*
    Load all modules on the page of the specified type.
    If container is provided, only load modules inside that element
    Type is one of 'display' or 'edit'
    */

    loadModules: function(container) {
      var modules, selector;
      selector = ".xmodule_edit, .xmodule_display";
      if (container != null) {
        modules = $(container).find(selector);
      } else {
        modules = $(selector);
      }
      return modules.each(function(idx, element) {
        return XModule.loadModule(element);
      });
    }
  };

  this.XModule.Descriptor = (function() {
    /*
    Register a callback method to be called when the state of this
    descriptor is updated. The callback will be passed the results
    of calling the save method on this descriptor.
    */

    Descriptor.prototype.onUpdate = function(callback) {
      if (this.callbacks == null) {
        this.callbacks = [];
      }
      return this.callbacks.push(callback);
    };

    /*
    Notify registered callbacks that the state of this descriptor has changed
    */


    Descriptor.prototype.update = function() {
      var callback, data, _i, _len, _ref, _results;
      data = this.save();
      _ref = this.callbacks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback(data));
      }
      return _results;
    };

    /*
    Bind the module to an element. This may be called multiple times,
    if the element content has changed and so the module needs to be rebound
    
    @method: constructor
    @param {html element} the .xmodule_edit section containing all of the descriptor content
    */


    function Descriptor(element) {
      this.element = element;
      this.update = __bind(this.update, this);
      return;
    }

    /*
    Return the current state of the descriptor (to be written to the module store)
    
    @method: save
    @returns {object} An object containing children and data attributes (both optional).
                      The contents of the attributes will be saved to the server
    */


    Descriptor.prototype.save = function() {
      return {};
    };

    return Descriptor;

  })();

}).call(this);

var SequenceNav = function($element) {
	var _this = this;
	var $element = $element;
	var $wrapper = $element.find('.sequence-list-wrapper');
	var $list = $element.find('#sequence-list');
	var $arrows = $element.find('.sequence-nav-buttons');
	var maxScroll = $list.width() - $wrapper.width() + 20;
	var $leftShadow = $('<div class="left-shadow"></div>');
	var $rightShadow = $('<div class="right-shadow"></div>');
	var $body = $('body');
	var listOrigin;
	var mouseOrigin;

	var startDrag = function(e) {
		updateWidths();
		mouseOrigin = e.pageX;
		listOrigin = $list.position().left;
		$body.css('-webkit-user-select', 'none');
		$body.bind('mousemove', moveDrag);
		$body.bind('mouseup', stopDrag);
	};

	var moveDrag = function(e) {
		var offset = e.pageX - mouseOrigin;
		var targetLeft = clamp(listOrigin + offset, -maxScroll, 0);

		updateHorizontalPosition(targetLeft);

		setShadows(targetLeft);
	};

	var stopDrag = function(e) {
		$body.css('-webkit-user-select', 'auto');
		$body.unbind('mousemove', moveDrag);
		$body.unbind('mouseup', stopDrag);
	};

	var setShadows = function(left) {
		var left = left || $list.position().left;
		var padding = 30;

		var leftPercent = clamp(-left / padding, 0, 1);
		$leftShadow.css('opacity', leftPercent);

		var rightPercent = clamp((maxScroll + left) / padding, 0, 1);
		$rightShadow.css('opacity', rightPercent);
	};

	var clamp = function(val, min, max) {
	    if(val > max) return max;
	    if(val < min) return min;
	    return val;
	};

	var updateWidths = function(e) {
		maxScroll = $list.width() - $wrapper.width() + 20;
		var targetLeft = clamp($list.position().left, -maxScroll, 0);
		updateHorizontalPosition(targetLeft);
		setShadows(targetLeft);
	};

	var updateHorizontalPosition = function(left) {
		$list.css({
			'left': left + 'px'
		});
	};

	var checkPosition = function(e) {
		var $active = $element.find('.active');
		if(!$active[0]) {
			return;
		}
		if($active.position().left + $active.width() > $wrapper.width() - $list.position().left) {
			$list.animate({
				'left': (-$active.position().left + $wrapper.width() - $active.width() - 10) + 'px'
			}, {
				step: setShadows
			});
		} else if($active.position().left < -$list.position().left) {
			$list.animate({
				'left': (-$active.position().left + 10) + 'px'
			}, {
				step: setShadows
			});
		}
	};

	$wrapper.append($leftShadow).append($rightShadow);
	setShadows(0);
	$wrapper.bind('mousedown', startDrag);
	$arrows.bind('click', checkPosition);
	$(window).bind('resize', updateWidths);
	setTimeout(function() {
		checkPosition();
	}, 200);
};

/////////////////////////////////////////////////////////////////////////////
//
//  Simple image input 
//
////////////////////////////////////////////////////////////////////////////////

// click on image, return coordinates
// put a dot at location of click, on imag

// window.image_input_click = function(id,event){

function image_input_click(id,event){
    iidiv = document.getElementById("imageinput_"+id);
    pos_x = event.offsetX?(event.offsetX):event.pageX-iidiv.offsetLeft;
    pos_y = event.offsetY?(event.offsetY):event.pageY-iidiv.offsetTop;
    result = "[" + pos_x + "," + pos_y + "]";
    cx = (pos_x-15) +"px";
    cy = (pos_y-15)  +"px" ;
    // alert(result);
    document.getElementById("cross_"+id).style.left = cx;
    document.getElementById("cross_"+id).style.top = cy;
    document.getElementById("cross_"+id).style.visibility = "visible" ;
    document.getElementById("input_"+id).value =result;
}

/**
 * @file Initialize module works with the JSON config, and sets up various
 * settings, parameters, variables. After all setup actions are performed, it
 * invokes the video player to play the specified video. This module must be
 * invoked first. It provides several functions which do not fit in with other
 * modules.
 *
 * @external VideoPlayer
 *
 * @module Initialize
 */

(function (requirejs, require, define) {

define(
'video/01_initialize.js',
['video/03_video_player.js'],
function (VideoPlayer) {

    // window.console.log() is expected to be available. We do not support
    // browsers which lack this functionality.

    // The function gettext() is defined by a vendor library. If, however, it
    // is undefined, it is a simple wrapper. It is used to return a different
    // version of the string passed (translated string, etc.). In the basic
    // case, the original string is returned.
    if (typeof(window.gettext) == 'undefined') {
        window.gettext = function (s) {
            return s;
        };
    }

    /**
     * @function
     *
     * Initialize module exports this function.
     *
     * @param {object} state The object containg the state of the video player.
     *     All other modules, their parameters, public variables, etc. are
     *     available via this object.
     * @param {DOM element} element Container of the entire Video DOM element.
     */
    return function (state, element) {
        _makeFunctionsPublic(state);
        state.initialize(element);
    };

    // ***************************************************************
    // Private functions start here. Private functions start with underscore.
    // ***************************************************************

    /**
     * @function _makeFunctionsPublic
     *
     * Functions which will be accessible via 'state' object. When called,
     * these functions will get the 'state'
     * object as a context.
     *
     * @param {object} state The object containg the state (properties,
     *     methods, modules) of the Video player.
     */
    function _makeFunctionsPublic(state) {
        state.setSpeed      = _.bind(setSpeed, state);
        state.youtubeId     = _.bind(youtubeId, state);
        state.getDuration   = _.bind(getDuration, state);
        state.trigger       = _.bind(trigger, state);
        state.stopBuffering = _.bind(stopBuffering, state);

        // Old private functions. Now also public so that can be
        // tested by Jasmine.

        state.initialize          = _.bind(initialize, state);
        state.parseSpeed          = _.bind(parseSpeed, state);
        state.fetchMetadata       = _.bind(fetchMetadata, state);
        state.parseYoutubeStreams = _.bind(parseYoutubeStreams, state);
        state.parseVideoSources   = _.bind(parseVideoSources, state);
        state.getVideoMetadata    = _.bind(getVideoMetadata, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _renderElements(state) {
        // Launch embedding of actual video content, or set it up so that it
        // will be done as soon as the appropriate video player (YouTube or
        // stand-alone HTML5) is loaded, and can handle embedding.
        //
        // Note that the loading of stand alone HTML5 player API is handled by
        // Require JS. At the time when we reach this code, the stand alone
        // HTML5 player is already loaded, so no further testing in that case
        // is required.
        var onPlayerReadyFunc;
        if (
            (
                (state.videoType === 'youtube') &&
                (window.YT) &&
                (window.YT.Player)
            ) ||
            (state.videoType === 'html5')
        ) {
            VideoPlayer(state);
        } else {
            if (state.videoType === 'youtube') {
                onPlayerReadyFunc = 'onYouTubePlayerAPIReady';
            } else {
                onPlayerReadyFunc = 'onHTML5PlayerAPIReady';
            }
            window[onPlayerReadyFunc] = _.bind(VideoPlayer, window, state);
        }
    }

    // function _configureCaptions(state)
    //     Configure displaying of captions.
    //
    //     Option
    //         this.config.show_captions = true | false
    //
    //     Defines whether or not captions are shown on first viewing.
    //
    //     Option
    //          this.hide_captions = true | false
    //
    //     represents the user's choice of having the subtitles shown or
    //     hidden. This choice is stored in cookies.
    function _configureCaptions(state) {
        if (state.config.show_captions) {
            state.hide_captions = ($.cookie('hide_captions') === 'true');
        } else {
            state.hide_captions = true;

            $.cookie('hide_captions', state.hide_captions, {
                expires: 3650,
                path: '/'
            });

            state.el.addClass('closed');
        }
    }

    // function _setPlayerMode(state)
    //     By default we will be forcing HTML5 player mode. Only in the case
    //     when, after initializtion, we will get one available playback rate,
    //     we will change to Flash player mode. There is a need to store this
    //     setting in cookies because otherwise we will have to change from
    //     HTML5 to Flash on every page load in a browser that doesn't fully
    //     support HTML5. When we have this setting in cookies, we can select
    //     the proper mode from the start (not having to change mode later on).
    function _setPlayerMode(state) {
        (function (currentPlayerMode) {
            if (
                (currentPlayerMode === 'html5') ||
                (currentPlayerMode === 'flash')
            ) {
                state.currentPlayerMode = currentPlayerMode;
            } else {
                $.cookie('current_player_mode', 'html5', {
                    expires: 3650,
                    path: '/'
                });
                state.currentPlayerMode = 'html5';
            }

            console.log(
                '[Video info]: YouTube player mode is "' +
                state.currentPlayerMode + '".'
            );
        }($.cookie('current_player_mode')));
    }

    // function _parseYouTubeIDs(state)
    //     The function parse YouTube stream ID's.
    //     @return
    //         false: We don't have YouTube video IDs to work with; most likely
    //             we have HTML5 video sources.
    //         true: Parsing of YouTube video IDs went OK, and we can proceed
    //             onwards to play YouTube videos.
    function _parseYouTubeIDs(state) {
        if (state.parseYoutubeStreams(state.config.youtubeStreams)) {
            state.videoType = 'youtube';

            return true;
        }

        console.log(
            '[Video info]: Youtube Video IDs are incorrect or absent.'
        );

        return false;
    }

    // function _prepareHTML5Video(state)
    // The function prepare HTML5 video, parse HTML5
    // video sources etc.
    function _prepareHTML5Video(state, html5Mode) {
        state.parseVideoSources(
            {
                mp4: state.config.mp4Source,
                webm: state.config.webmSource,
                ogg: state.config.oggSource
            }
        );

        if (html5Mode) {
            state.speeds = ['0.75', '1.0', '1.25', '1.50'];
            state.videos = {
                '0.75': state.config.sub,
                '1.0':  state.config.sub,
                '1.25': state.config.sub,
                '1.5':  state.config.sub
            };
        }

        // We must have at least one non-YouTube video source available.
        // Otherwise, return a negative.
        if (
            state.html5Sources.webm === null &&
            state.html5Sources.mp4 === null &&
            state.html5Sources.ogg === null
        ) {
            state.el.find('.video-player div').addClass('hidden');
            state.el.find('.video-player h3').removeClass('hidden');

            console.log(
                '[Video info]: Non-youtube video sources aren\'t available.'
            );

            return false;
        }

        state.videoType = 'html5';

        if (!state.config.sub || !state.config.sub.length) {
            state.config.sub = '';
            state.config.show_captions = false;
        }

        state.setSpeed($.cookie('video_speed'));

        return true;
    }

    function _setConfigurations(state) {
        _configureCaptions(state);
        _setPlayerMode(state);

        // Possible value are: 'visible', 'hiding', and 'invisible'.
        state.controlState = 'visible';
        state.controlHideTimeout = null;
        state.captionState = 'visible';
        state.captionHideTimeout = null;
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    // function initialize(element)
    // The function set initial configuration and preparation.

    function initialize(element) {
        var _this = this, tempYtTestTimeout;
        // This is used in places where we instead would have to check if an
        // element has a CSS class 'fullscreen'.
        this.isFullScreen = false;

        // The parent element of the video, and the ID.
        this.el = $(element).find('.video');
        this.id = this.el.attr('id').replace(/video_/, '');

        console.log(
            '[Video info]: Initializing video with id "' + this.id + '".'
        );

        // We store all settings passed to us by the server in one place. These
        // are "read only", so don't modify them. All variable content lives in
        // 'state' object.
        this.config = {
            element: element,

            start:              this.el.data('start'),
            end:                this.el.data('end'),

            caption_data_dir:   this.el.data('caption-data-dir'),
            caption_asset_path: this.el.data('caption-asset-path'),
            show_captions:      (
                                    this.el.data('show-captions')
                                        .toString().toLowerCase() === 'true'
                                ),
            youtubeStreams:     this.el.data('streams'),

            sub:                this.el.data('sub'),
            mp4Source:          this.el.data('mp4-source'),
            webmSource:         this.el.data('webm-source'),
            oggSource:          this.el.data('ogg-source'),

            ytTestUrl:   this.el.data('yt-test-url'),

            fadeOutTimeout:     1400,

            availableQualities: ['hd720', 'hd1080', 'highres']
        };

        // Check if the YT test timeout has been set. If not, or it is in
        // improper format, then set to default value.
        tempYtTestTimeout = parseInt(this.el.data('yt-test-timeout'), 10);
        if (!isFinite(tempYtTestTimeout)) {
            tempYtTestTimeout = 1500;
        }
        this.config.ytTestTimeout = tempYtTestTimeout;

        if (!(_parseYouTubeIDs(this))) {

            // If we do not have YouTube ID's, try parsing HTML5 video sources.
            if (!_prepareHTML5Video(this, true)) {

                // Non-YouTube sources were not found either.
                return;
            }

            console.log('[Video info]: Start player in HTML5 mode.');

            _setConfigurations(this);
            _renderElements(this);
        } else {
            if (!this.youtubeXhr) {
                this.youtubeXhr = this.getVideoMetadata();
            }

            this.youtubeXhr
                .always(function (json, status) {
                    var err = $.isPlainObject(json.error) ||
                                (
                                    status !== 'success' &&
                                    status !== 'notmodified'
                                );
                    if (err) {
                        console.log(
                            '[Video info]: YouTube returned an error for ' +
                            'video with id "' + _this.id + '".'
                        );

                        // When the youtube link doesn't work for any reason
                        // (for example, the great firewall in china) any
                        // alternate sources should automatically play.
                        if (!_prepareHTML5Video(_this)) {
                            console.log(
                                '[Video info]: Continue loading ' +
                                'YouTube video.'
                            );

                            // Non-YouTube sources were not found either.

                            _this.el.find('.video-player div')
                                .removeClass('hidden');
                            _this.el.find('.video-player h3')
                                .addClass('hidden');

                            // If in reality the timeout was to short, try to
                            // continue loading the YouTube video anyways.
                            _this.fetchMetadata();
                            _this.parseSpeed();
                        } else {
                            console.log(
                                '[Video info]: Change player mode to HTML5.'
                            );

                            // In-browser HTML5 player does not support quality
                            // control.
                            _this.el.find('a.quality_control').hide();
                        }
                    } else {
                        console.log(
                            '[Video info]: Start player in YouTube mode.'
                        );

                        _this.fetchMetadata();
                        _this.parseSpeed();
                    }

                    _setConfigurations(_this);
                    _renderElements(_this);
                });
        }
    }

    // function parseYoutubeStreams(state, youtubeStreams)
    //
    //     Take a string in the form:
    //         "iCawTYPtehk:0.75,KgpclqP-LBA:1.0,9-2670d5nvU:1.5"
    //     parse it, and make it available via the 'state' object. If we are
    //     not given a string, or it's length is zero, then we return false.
    //
    //     @return
    //         false: We don't have YouTube video IDs to work with; most likely
    //             we have HTML5 video sources.
    //         true: Parsing of YouTube video IDs went OK, and we can proceed
    //             onwards to play YouTube videos.
    function parseYoutubeStreams(youtubeStreams) {
        var _this;

        if (
            typeof youtubeStreams === 'undefined' ||
            youtubeStreams.length === 0
        ) {
            return false;
        }

        _this = this;
        this.videos = {};

        $.each(youtubeStreams.split(/,/), function (index, video) {
            var speed;

            video = video.split(/:/);
            speed = parseFloat(video[0]).toFixed(2).replace(/\.00$/, '.0');

            _this.videos[speed] = video[1];
        });

        return true;
    }

    // function parseVideoSources(, mp4Source, webmSource, oggSource)
    //
    //     Take the HTML5 sources (URLs of videos), and make them available
    //     explictly for each type of video format (mp4, webm, ogg).
    function parseVideoSources(sources) {
        var _this = this,
            v = document.createElement('video'),
            sourceCodecs = {
                mp4: 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
                webm: 'video/webm; codecs="vp8, vorbis"',
                ogg: 'video/ogg; codecs="theora"'
            };

        this.html5Sources = {
            mp4: null,
            webm: null,
            ogg: null
        };

        $.each(sources, function (name, source) {
            if (source && source.length) {
                if (
                    Boolean(
                        v.canPlayType &&
                        v.canPlayType(sourceCodecs[name]).replace(/no/, '')
                    )
                ) {
                    _this.html5Sources[name] = source;
                }
            }
        });
    }

    // function fetchMetadata()
    //
    //     When dealing with YouTube videos, we must fetch meta data that has
    //     certain key facts not available while the video is loading. For
    //     example the length of the video can be determined from the meta
    //     data.
    function fetchMetadata() {
        var _this = this;

        this.metadata = {};

        $.each(this.videos, function (speed, url) {
            _this.getVideoMetadata(url, function (data) {
                if (data.data) {
                    _this.metadata[data.data.id] = data.data;
                }
            });
        });
    }

    // function parseSpeed()
    //
    //     Create a separate array of available speeds.
    function parseSpeed() {
        this.speeds = ($.map(this.videos, function (url, speed) {
            return speed;
        })).sort();

        this.setSpeed($.cookie('video_speed'));
    }

    function setSpeed(newSpeed, updateCookie) {
        if (_.indexOf(this.speeds, newSpeed) !== -1) {
            this.speed = newSpeed;
        } else {
            this.speed = '1.0';
        }

        if (updateCookie) {
            $.cookie('video_speed', this.speed, {
                expires: 3650,
                path: '/'
            });
        }
    }

    function getVideoMetadata(url, callback) {
        var successHandler, xhr;

        if (typeof url !== 'string') {
            url = this.videos['1.0'] || '';
        }
        successHandler = ($.isFunction(callback)) ? callback : null;
        xhr = $.ajax({
            url: this.config.ytTestUrl + url + '?v=2&alt=jsonc',
            dataType: 'jsonp',
            timeout: this.config.ytTestTimeout,
            success: successHandler
        });

        return xhr;
    }

    function stopBuffering() {
        var video;

        if (this.videoType === 'html5') {
            // HTML5 player haven't default way to abort bufferization.
            // In this case we simply resetting source and call load().
            video = this.videoPlayer.player.video;
            video.src = '';
            video.load();
        }
    }

    function youtubeId(speed) {
        return this.videos[speed || this.speed];
    }

    function getDuration() {
        return this.metadata[this.youtubeId()].duration;
    }

    /*
     * The trigger() function will assume that the @objChain is a complete
     * chain with a method (function) at the end. It will call this function.
     * So for example, when trigger() is called like so:
     *
     *     state.trigger('videoPlayer.pause', {'param1': 10});
     *
     * Then trigger() will execute:
     *
     *     state.videoPlayer.pause({'param1': 10});
     */
    function trigger(objChain, extraParameters) {
        var i, tmpObj, chain;

        // Remember that 'this' is the 'state' object.
        tmpObj = this;
        chain = objChain.split('.');

        // At the end of the loop the variable 'tmpObj' will either be the
        // correct object/function to trigger/invoke. If the 'chain' chain of
        // object is incorrect (one of the link is non-existent), then the loop
        // will immediately exit.
        while (chain.length) {
            i = chain.shift();

            if (tmpObj.hasOwnProperty(i)) {
                tmpObj = tmpObj[i];
            } else {
                // An incorrect object chain was specified.

                return false;
            }
        }

        tmpObj(extraParameters);

        return true;
    }
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define(
    'GstMain',

    // Even though it is not explicitly in this module, we have to specify
    // 'GeneralMethods' as a dependency. It expands some of the core JS objects
    // with additional useful methods that are used in other modules.
    ['State', 'GeneralMethods', 'Sliders', 'Inputs', 'Graph', 'ElOutput', 'GLabelElOutput', 'logme'],
    function (State, GeneralMethods, Sliders, Inputs, Graph, ElOutput, GLabelElOutput, logme) {

    return GstMain;

    function GstMain(gstId) {
        var config, gstClass, state;

        if ($('#' + gstId).attr('data-processed') !== 'processed') {
            $('#' + gstId).attr('data-processed', 'processed');
        } else {
            // logme('MESSAGE: Already processed GST with ID ' + gstId + '. Skipping.');

            return;
        }

        // Get the JSON configuration, parse it, and store as an object.
        try {
            config = JSON.parse($('#' + gstId + '_json').html()).root;
        } catch (err) {
            logme('ERROR: could not parse config JSON.');
            logme('$("#" + gstId + "_json").html() = ', $('#' + gstId + '_json').html());
            logme('JSON.parse(...) = ', JSON.parse($('#' + gstId + '_json').html()));
            logme('config = ', config);

            return;
        }

        // Get the class name of the GST. All elements are assigned a class
        // name that is based on the class name of the GST. For example, inputs
        // are assigned a class name '{GST class name}_input'.
        if (typeof config['@class'] !== 'string') {
            logme('ERROR: Could not get the class name of GST.');
            logme('config["@class"] = ', config['@class']);

            return;
        }
        gstClass = config['@class'];

        // Parse the configuration settings for parameters, and store them in a
        // state object.
        state = State(gstId, config);

        state.showDebugInfo = false;

        // It is possible that something goes wrong while extracting parameters
        // from the JSON config object. In this case, we will not continue.
        if (state === undefined) {
            logme('ERROR: The state object was not initialized properly.');

            return;
        }

        // Create the sliders and the text inputs, attaching them to
        // appropriate parameters.
        Sliders(gstId, state);
        Inputs(gstId, gstClass, state);

        // Configure functions that output to an element instead of the graph.
        ElOutput(config, state);

        // Configure functions that output to an element instead of the graph
        // label.
        GLabelElOutput(config, state);

        // Configure and display the graph. Attach event for the graph to be
        // updated on any change of a slider or a text input.
        Graph(gstId, config, state);
    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('logme', [], function () {
    var debugMode;

    // debugMode can be one of the following:
    //
    //     true - All messages passed to logme will be written to the internal
    //            browser console.
    //     false - Suppress all output to the internal browser console.
    //
    // Obviously, if anywhere there is a direct console.log() call, we can't do
    // anything about it. That's why use logme() - it will allow to turn off
    // the output of debug information with a single change to a variable.
    debugMode = true;

    return logme;

    /*
     * function: logme
     *
     * A helper function that provides logging facilities. We don't want
     * to call console.log() directly, because sometimes it is not supported
     * by the browser. Also when everything is routed through this function.
     * the logging output can be easily turned off.
     *
     * logme() supports multiple parameters. Each parameter will be passed to
     * console.log() function separately.
     *
     */
    function logme() {
        var i;

        if (
            (typeof debugMode === 'undefined') ||
            (debugMode !== true) ||
            (typeof window.console === 'undefined')
        ) {
            return;
        }

        for (i = 0; i < arguments.length; i++) {
            window.console.log(arguments[i]);
        }
    } // End-of: function logme
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Generated by CoffeeScript 1.6.3
(function() {
  this.Time = (function() {
    function Time() {}

    Time.format = function(time) {
      var hours, minutes, pad, seconds;
      pad = function(number) {
        if (number < 10) {
          return "0" + number;
        } else {
          return number;
        }
      };
      seconds = Math.floor(time);
      minutes = Math.floor(seconds / 60);
      hours = Math.floor(minutes / 60);
      seconds = seconds % 60;
      minutes = minutes % 60;
      if (hours) {
        return "" + hours + ":" + (pad(minutes)) + ":" + (pad(seconds % 60));
      } else {
        return "" + minutes + ":" + (pad(seconds % 60));
      }
    };

    Time.convert = function(time, oldSpeed, newSpeed) {
      return (time * oldSpeed / newSpeed).toFixed(3);
    };

    return Time;

  })();

}).call(this);

window.Poll = function (el) {
    RequireJS.require(['PollMain'], function (PollMain) {
        new PollMain(el);
    });
};

//////////////////////////////////////////////////////////////////////////////
//
//  Circuit simulator
//
//////////////////////////////////////////////////////////////////////////////

// Copyright (C) 2011 Massachusetts Institute of Technology


// create a circuit for simulation using "new cktsim.Circuit()"

// for modified nodal analysis (MNA) stamps see
// http://www.analog-electronics.eu/analog-electronics/modified-nodal-analysis/modified-nodal-analysis.xhtml

cktsim = (function() {
    
	///////////////////////////////////////////////////////////////////////////////
	//
	//  Circuit
	//
	//////////////////////////////////////////////////////////////////////////////

	// types of "nodes" in the linear system
	T_VOLTAGE = 0;
	T_CURRENT = 1;

        v_newt_lim = 0.3;   // Voltage limited Newton great for Mos/diodes
	v_abstol = 1e-6;	// Absolute voltage error tolerance
	i_abstol = 1e-12;	// Absolute current error tolerance
        eps = 1.0e-12;           // A very small number compared to one.
	dc_max_iters = 1000;	// max iterations before giving pu
	max_tran_iters = 20;	// max iterations before giving up
	time_step_increase_factor = 2.0;  // How much can lte let timestep grow.
	lte_step_decrease_factor = 8;    // Limit lte one-iter timestep shrink.
	nr_step_decrease_factor = 4;     // Newton failure timestep shink.
	reltol = 0.0001;		// Relative tol to max observed value
        lterel = 10;             // LTE/Newton tolerance ratio (> 10!)
        res_check_abs = Math.sqrt(i_abstol); // Loose Newton residue check
        res_check_rel = Math.sqrt(reltol); // Loose Newton residue check

	function Circuit() {
	    this.node_map = new Array();
	    this.ntypes = [];
	    this.initial_conditions = [];  // ic's for each element

	    this.devices = [];  // list of devices
	    this.device_map = new Array();  // map name -> device
	    this.voltage_sources = [];  // list of voltage sources
	    this.current_sources = [];  // list of current sources

	    this.finalized = false;
	    this.diddc = false;
	    this.node_index = -1;

	    this.periods = 1
	}

	// index of ground node
	Circuit.prototype.gnd_node = function() {
	    return -1;
	}

	// allocate a new node index
	Circuit.prototype.node = function(name,ntype,ic) {
	    this.node_index += 1;
	    if (name) this.node_map[name] = this.node_index;
	    this.ntypes.push(ntype);
	    this.initial_conditions.push(ic);
	    return this.node_index;
	}

	// call to finalize the circuit in preparation for simulation
	Circuit.prototype.finalize = function() {
	    if (!this.finalized) {
		this.finalized = true;
		this.N = this.node_index + 1;  // number of nodes

		// give each device a chance to finalize itself
		for (var i = this.devices.length - 1; i >= 0; --i)
		    this.devices[i].finalize(this);

		// set up augmented matrix and various temp vectors
		this.matrix = mat_make(this.N, this.N+1);
		this.Gl = mat_make(this.N, this.N);  // Matrix for linear conductances
		this.G = mat_make(this.N, this.N);  // Complete conductance matrix
		this.C = mat_make(this.N, this.N);  // Matrix for linear L's and C's

		this.soln_max = new Array(this.N);   // max abs value seen for each unknown
		this.abstol = new Array(this.N);
		this.solution = new Array(this.N);
		this.rhs = new Array(this.N);
		for (var i = this.N - 1; i >= 0; --i) {	    
		    this.soln_max[i] = 0.0;
		    this.abstol[i] = this.ntypes[i] == T_VOLTAGE ? v_abstol : i_abstol;
		    this.solution[i] = 0.0;
		    this.rhs[i] = 0.0;
		}

		// Load up the linear elements once and for all
		for (var i = this.devices.length - 1; i >= 0; --i) {
		    this.devices[i].load_linear(this)
		}

		// Check for voltage source loops. 
		n_vsrc = this.voltage_sources.length;
		if (n_vsrc > 0) { // At least one voltage source
		    var GV = mat_make(n_vsrc, this.N);  // Loop check
		    for (var i = n_vsrc - 1; i >= 0; --i) {
			var branch = this.voltage_sources[i].branch;
			for (var j = this.N - 1; j >= 0; j--)
			    GV[i][j] = this.Gl[branch][j];
		    }
		    var rGV = mat_rank(GV);
		    if (rGV < n_vsrc) {
			alert('Warning!!! Circuit has a voltage source loop or a source or current probe shorted by a wire, please remove the source or the wire causing the short.');
			alert('Warning!!! Simulator might produce meaningless results or no result with illegal circuits.');
			return false;		
		    }
		}
	    }
	    return true;		
	}

	// load circuit from JSON netlist (see schematic.js)
	Circuit.prototype.load_netlist = function(netlist) {
	    // set up mapping for all ground connections
	    for (var i = netlist.length - 1; i >= 0; --i) {
		var component = netlist[i];
		var type = component[0];
		if (type == 'g') {
		    var connections = component[3];
		    this.node_map[connections[0]] = this.gnd_node();
		}
	    }

	    // process each component in the JSON netlist (see schematic.js for format)
	    var found_ground = false;
	    for (var i = netlist.length - 1; i >= 0; --i) {
		var component = netlist[i];
		var type = component[0];

		// ignore wires, ground connections, scope probes and view info
		if (type == 'view' || type == 'w' || type == 'g' || type == 's' || type == 'L') {
		    continue;
		}

		var properties = component[2];
		var name = properties['name'];
		if (name==undefined || name=='')
		    name = '_' + properties['_json_'].toString();

		// convert node names to circuit indicies
		var connections = component[3];
		for (var j = connections.length - 1; j >= 0; --j) {
		    var node = connections[j];
		    var index = this.node_map[node];
		    if (index == undefined) index = this.node(node,T_VOLTAGE);
		    else if (index == this.gnd_node()) found_ground = true;
		    connections[j] = index;
		}

		// process the component
		if (type == 'r')	// resistor
		    this.r(connections[0],connections[1],properties['r'],name);
		else if (type == 'd')	// diode
		    this.d(connections[0],connections[1],properties['area'],properties['type'],name);
		else if (type == 'c')   // capacitor
		    this.c(connections[0],connections[1],properties['c'],name);
		else if (type == 'l')	// inductor
		    this.l(connections[0],connections[1],properties['l'],name);
		else if (type == 'v') 	// voltage source
		    this.v(connections[0],connections[1],properties['value'],name);
		else if (type == 'i') 	// current source
		    this.i(connections[0],connections[1],properties['value'],name);
		else if (type == 'o') 	// op amp
		    this.opamp(connections[0],connections[1],connections[2],connections[3],properties['A'],name);
		else if (type == 'n') 	// n fet
		    this.n(connections[0],connections[1],connections[2],properties['W/L'],name);
		else if (type == 'p') 	// p fet
		    this.p(connections[0],connections[1],connections[2],properties['W/L'],name);
		else if (type == 'a') 	// current probe == 0-volt voltage source
		    this.v(connections[0],connections[1],'0',name);
	    }

	    if (!found_ground) { // No ground on schematic
		alert('Please make at least one connection to ground  (inverted T symbol)');
		return false;
	    }
	    return true;
	    
	}

	// if converges: updates this.solution, this.soln_max, returns iter count
	// otherwise: return undefined and set this.problem_node
	// Load should compute -f and df/dx (note the sign pattern!)
        Circuit.prototype.find_solution = function(load,maxiters) {
	    var soln = this.solution;
	    var rhs = this.rhs;
	    var d_sol = new Array();
	    var abssum_compare;
	    var converged,abssum_old=0, abssum_rhs;
	    var use_limiting = false;
	    var down_count = 0;

	    // iteratively solve until values convere or iteration limit exceeded
	    for (var iter = 0; iter < maxiters; iter++) {
		// set up equations
		load(this,soln,rhs);

		// Compute norm of rhs, assume variables of v type go with eqns of i type
		abssum_rhs = 0;
		for (var i = this.N - 1; i >= 0; --i)
		    if (this.ntypes[i] == T_VOLTAGE)
			abssum_rhs += Math.abs(rhs[i]);

		if ((iter > 0) && (use_limiting == false) && (abssum_old < abssum_rhs)) {  
		    // Old rhsnorm was better, undo last iter and turn on limiting
		    for (var i = this.N - 1; i >= 0; --i)
			soln[i] -= d_sol[i];
		    iter -= 1;
		    use_limiting = true;
		}
	        else {  // Compute the Newton delta
		    //d_sol = mat_solve(this.matrix,rhs);
		    d_sol = mat_solve_rq(this.matrix,rhs);

		    // If norm going down for ten iters, stop limiting
		    if (abssum_rhs < abssum_old)
			down_count += 1;
		    else 
			down_count = 0;
		    if (down_count > 10) {
			use_limiting = false;
			down_count = 0;
		    }

		    // Update norm of rhs
		    abssum_old = abssum_rhs;		    
		}

		// Update the worst case abssum for comparison.
		if ((iter == 0) || (abssum_rhs > abssum_compare))
		    abssum_compare = abssum_rhs;

		// Check residue convergence, but loosely, and give up 
		// on last iteration
		if ( (iter < (maxiters - 1)) &&
		     (abssum_rhs > (res_check_abs+res_check_rel*abssum_compare)))
		    converged = false;
		else converged = true;


		// Update solution and check delta convergence
		for (var i = this.N - 1; i >= 0; --i) {
		    // Simple voltage step limiting to encourage Newton convergence
		    if (use_limiting) {
			if (this.ntypes[i] == T_VOLTAGE) {
			    d_sol[i] = (d_sol[i] > v_newt_lim) ? v_newt_lim : d_sol[i];
			    d_sol[i] = (d_sol[i] < -v_newt_lim) ? -v_newt_lim : d_sol[i];
			}
		    }
		    soln[i] += d_sol[i];
		    thresh = this.abstol[i] + reltol*this.soln_max[i];
		    if (Math.abs(d_sol[i]) > thresh) {
			converged = false;
			this.problem_node = i;
		    }
		}

		//alert(numeric.prettyPrint(this.solution);)
                if (converged == true) {
		    for (var i = this.N - 1; i >= 0; --i) 
			if (Math.abs(soln[i]) > this.soln_max[i])
			    this.soln_max[i] = Math.abs(soln[i]);
		    
		    return iter+1;
		}
	    }
	    return undefined;
	}

	// DC analysis
	Circuit.prototype.dc = function() {

	    // Allocation matrices for linear part, etc.
	    if (this.finalize() == false)
		return undefined;

	    // Define -f and df/dx for Newton solver
	    function load_dc(ckt,soln,rhs) {
		// rhs is initialized to -Gl * soln
		mat_v_mult(ckt.Gl, soln, rhs, -1.0);
		// G matrix is initialized with linear Gl
		mat_copy(ckt.Gl,ckt.G);
		// Now load up the nonlinear parts of rhs and G
		for (var i = ckt.devices.length - 1; i >= 0; --i)
			ckt.devices[i].load_dc(ckt,soln,rhs);
		// G matrix is copied in to the system matrix
		mat_copy(ckt.G,ckt.matrix);
	    }

	    // find the operating point
	    var iterations = this.find_solution(load_dc,dc_max_iters);

	    if (typeof iterations == 'undefined') {
	    // too many iterations
		if (this.current_sources.length > 0) {
		    alert('Newton Method Failed, do your current sources have a conductive path to ground?');
		} else {
		    alert('Newton Method Failed, it may be your circuit or it may be our simulator.');
		}

		return undefined
	    } else {
		// Note that a dc solution was computed
		this.diddc = true;
		// create solution dictionary
		var result = new Array();
		// capture node voltages
		for (var name in this.node_map) {
		    var index = this.node_map[name];
		    result[name] = (index == -1) ? 0 : this.solution[index];
		}
		// capture branch currents from voltage sources
		for (var i = this.voltage_sources.length - 1; i >= 0; --i) {
		    var v = this.voltage_sources[i];
		    result['I('+v.name+')'] = this.solution[v.branch];
		}
		return result;
	    }
	}

	// Transient analysis (needs work!)
        Circuit.prototype.tran = function(ntpts, tstart, tstop, probenames, no_dc) {

	    // Define -f and df/dx for Newton solver
	    function load_tran(ckt,soln,rhs) {
		// Crnt is initialized to -Gl * soln
		mat_v_mult(ckt.Gl, soln, ckt.c,-1.0);
		// G matrix is initialized with linear Gl
		mat_copy(ckt.Gl,ckt.G);
		// Now load up the nonlinear parts of crnt and G
		for (var i = ckt.devices.length - 1; i >= 0; --i)
		    ckt.devices[i].load_tran(ckt,soln,ckt.c,ckt.time);
		// Exploit the fact that storage elements are linear
		mat_v_mult(ckt.C, soln, ckt.q, 1.0);
		// -rhs = c - dqdt
		for (var i = ckt.N-1; i >= 0; --i) {
		    var dqdt = ckt.alpha0*ckt.q[i] + ckt.alpha1*ckt.oldq[i] + 
			ckt.alpha2*ckt.old2q[i];
		    //alert(numeric.prettyPrint(dqdt));
		    rhs[i] = ckt.beta0[i]*ckt.c[i] + ckt.beta1[i]*ckt.oldc[i] - dqdt;
		}
		// matrix = beta0*G + alpha0*C.
		mat_scale_add(ckt.G,ckt.C,ckt.beta0,ckt.alpha0,ckt.matrix);
	    }

	    var p = new Array(3);
	    function interp_coeffs(t, t0, t1, t2) {
		// Poly coefficients
		var dtt0 = (t - t0);
		var dtt1 = (t - t1);
		var dtt2 = (t - t2);
		var dt0dt1 = (t0 - t1);
		var dt0dt2 = (t0 - t2);
		var dt1dt2 = (t1 - t2);
		p[0] = (dtt1*dtt2)/(dt0dt1 * dt0dt2);
		p[1] = (dtt0*dtt2)/(-dt0dt1 * dt1dt2);
		p[2] = (dtt0*dtt1)/(dt0dt2 * dt1dt2);
		return p;
	    }

	    function pick_step(ckt, step_index) {
		var min_shrink_factor = 1.0/lte_step_decrease_factor;
	        var max_growth_factor = time_step_increase_factor;
		var N = ckt.N;
		var p = interp_coeffs(ckt.time, ckt.oldt, ckt.old2t, ckt.old3t);
		var trapcoeff = 0.5*(ckt.time - ckt.oldt)/(ckt.time - ckt.old3t);
		var maxlteratio = 0.0;
		for (var i = ckt.N-1; i >= 0; --i) {
		    if (ckt.ltecheck[i]) { // Check lte on variable
			var pred = p[0]*ckt.oldsol[i] + p[1]*ckt.old2sol[i] + p[2]*ckt.old3sol[i];
			var lte = Math.abs((ckt.solution[i] - pred))*trapcoeff;
			var lteratio = lte/(lterel*(ckt.abstol[i] + reltol*ckt.soln_max[i]));
			maxlteratio = Math.max(maxlteratio, lteratio);
		    }
		}
		var new_step;
		var lte_step_ratio = 1.0/Math.pow(maxlteratio,1/3); // Cube root because trap
		if (lte_step_ratio < 1.0) { // Shrink the timestep to make lte
		    lte_step_ratio = Math.max(lte_step_ratio,min_shrink_factor);
		    new_step = (ckt.time - ckt.oldt)*0.75*lte_step_ratio;
		    new_step = Math.max(new_step, ckt.min_step);
		} else {
		    lte_step_ratio = Math.min(lte_step_ratio, max_growth_factor);
		    if (lte_step_ratio > 1.2)  /* Increase timestep due to lte. */
			new_step = (ckt.time - ckt.oldt) * lte_step_ratio / 1.2;
		    else 
			new_step = (ckt.time - ckt.oldt);
		    new_step = Math.min(new_step, ckt.max_step);
		}
		return new_step;
	    }
	    
	    // Standard to do a dc analysis before transient
	    // Otherwise, do the setup also done in dc.
	    no_dc = false;
	    if ((this.diddc == false) && (no_dc == false)) {
		if (this.dc() == undefined) { // DC failed, realloc mats and vects.
		    alert('DC failed, trying transient analysis from zero.');		    
		    this.finalized = false;  // Reset the finalization.
		    if (this.finalize() == false) 
			return undefined;
		}
	    }
	    else {
		if (this.finalize() == false) // Allocate matrices and vectors.
		    return undefined;
	    }

	    // Tired of typing this, and using "with" generates hate mail.
	    var N = this.N;

	    // build array to hold list of results for each variable
	    // last entry is for timepoints.
	    var response = new Array(N + 1);
	    for (var i = N; i >= 0; --i) response[i] = new Array();

	    // Allocate back vectors for up to a second order method
	    this.old3sol = new Array(this.N);
	    this.old3q = new Array(this.N);
	    this.old2sol = new Array(this.N);
	    this.old2q = new Array(this.N);
	    this.oldsol = new Array(this.N);
	    this.oldq = new Array(this.N);
	    this.q = new Array(this.N);
	    this.oldc = new Array(this.N);
	    this.c = new Array(this.N);
	    this.alpha0 = 1.0;
	    this.alpha1 = 0.0;
	    this.alpha2 = 0.0;
	    this.beta0 = new Array(this.N);
	    this.beta1 = new Array(this.N);

	    // Mark a set of algebraic variable (don't miss hidden ones!).
	    this.ar = this.algebraic(this.C);

	    // Non-algebraic variables and probe variables get lte
	    this.ltecheck = new Array(this.N);
	    for (var i = N; i >= 0; --i) 
		this.ltecheck[i] = (this.ar[i] == 0);

	    for (var name in this.node_map) {
		var index = this.node_map[name];
		for (var i = probenames.length; i >= 0; --i) {
		    if (name == probenames[i]) {
			this.ltecheck[index] = true;
			break;
		    }
		}
	    }

	    // Check for periodic sources
	    var period = tstop - tstart;
	    for (var i = this.voltage_sources.length - 1; i >= 0; --i) {
		var per = this.voltage_sources[i].src.period;
		if (per > 0)
		    period = Math.min(period, per);
	    }
	    for (var i = this.current_sources.length - 1; i >= 0; --i) {
		var per = this.current_sources[i].src.period;
		if (per > 0)
		    period = Math.min(period, per);
	    }
	    this.periods = Math.ceil((tstop - tstart)/period);
	    //alert('number of periods ' + this.periods);

	
	    this.time = tstart;
	    // ntpts adjusted by numbers of periods in input
	    this.max_step = (tstop - tstart)/(this.periods*ntpts);
	    this.min_step = this.max_step/1e8;
	    var new_step = this.max_step/1e6;
	    this.oldt = this.time - new_step;

	    // Initialize old crnts, charges, and solutions.
	    load_tran(this,this.solution,this.rhs)
	    for (var i = N-1; i >= 0; --i) {
		this.old3sol[i] = this.solution[i];
		this.old2sol[i] = this.solution[i];
		this.oldsol[i] = this.solution[i];
		this.old3q[i] = this.q[i]; 
		this.old2q[i] = this.q[i]; 
		this.oldq[i] = this.q[i]; 
		this.oldc[i] = this.c[i]; 
	    }

	    
	    var beta0,beta1;
	    // Start with two pseudo-Euler steps, maximum 50000 steps/period
	    var max_nsteps = this.periods*50000;
	    for(var step_index = -3; step_index < max_nsteps; step_index++) {
		// Save the just computed solution, and move back q and c.
		for (var i = this.N - 1; i >= 0; --i) {
		    if (step_index >= 0)
			response[i].push(this.solution[i]);
		    this.oldc[i] = this.c[i];
		    this.old3sol[i] = this.old2sol[i];
		    this.old2sol[i] = this.oldsol[i];
		    this.oldsol[i] = this.solution[i];
		    this.old3q[i] = this.oldq[i];
		    this.old2q[i] = this.oldq[i];
		    this.oldq[i] = this.q[i];

		}

		if (step_index < 0) {  // Take a prestep using BE
		    this.old3t = this.old2t - (this.oldt-this.old2t)
		    this.old2t = this.oldt - (tstart-this.oldt)
		    this.oldt = tstart - (this.time - this.oldt);
		    this.time = tstart;
		    beta0 = 1.0;  
		    beta1 = 0.0;		
		} else {  // Take a regular step
		    // Save the time, and rotate time wheel
		    response[this.N].push(this.time);
		    this.old3t = this.old2t;
		    this.old2t = this.oldt;
		    this.oldt = this.time;
		    // Make sure we come smoothly in to the interval end.
		    if (this.time >= tstop) break;  // We're done.
		    else if(this.time + new_step > tstop)
			this.time = tstop;
		    else if(this.time + 1.5*new_step > tstop)
			this.time += (2/3)*(tstop - this.time);
		    else
			this.time += new_step;

		    // Use trap (average old and new crnts.
		    beta0 = 0.5;
		    beta1 = 0.5;	
		}

		// For trap rule, turn off current avging for algebraic eqns
		for (var i = this.N - 1; i >= 0; --i) {
		    this.beta0[i] = beta0 + this.ar[i]*beta1;
		    this.beta1[i] = (1.0 - this.ar[i])*beta1;
		}

		// Loop to find NR converging timestep with okay LTE
		while (true) {
		    // Set the timestep coefficients (alpha2 is for bdf2).
		    this.alpha0 = 1.0/(this.time - this.oldt);
		    this.alpha1 = -this.alpha0;
		    this.alpha2 = 0;

		    // If timestep is 1/10,000th of tstop, just use BE.
		    if ((this.time-this.oldt) < 1.0e-4*tstop) {
			for (var i = this.N - 1; i >= 0; --i) {
			    this.beta0[i] = 1.0;
			    this.beta1[i] = 0.0;
			}
		    }  
		    // Use Newton to compute the solution.
		    var iterations = this.find_solution(load_tran,max_tran_iters);

		    // If NR succeeds and stepsize is at min, accept and newstep=maxgrowth*minstep.
		    // Else if Newton Fails, shrink step by a factor and try again
		    // Else LTE picks new step, if bigger accept current step and go on.
		    if ((iterations != undefined) && 
			(step_index <= 0 || (this.time-this.oldt) < (1+reltol)*this.min_step)) {
			if (step_index > 0) new_step = time_step_increase_factor*this.min_step;
			break;
		    } else if (iterations == undefined) {  // NR nonconvergence, shrink by factor
			//alert('timestep nonconvergence ' + this.time + ' ' + step_index);
			this.time = this.oldt + 
			    (this.time - this.oldt)/nr_step_decrease_factor;
		    } else {  // Check the LTE and shrink step if needed.
			new_step = pick_step(this, step_index);
			if (new_step < (1.0 - reltol)*(this.time - this.oldt)) {
			    this.time = this.oldt + new_step;  // Try again   
			}
			else
			    break;  // LTE okay, new_step for next step
		    }
		}
	    }

	    // create solution dictionary
	    var result = new Array();
	    for (var name in this.node_map) {
		var index = this.node_map[name];
		result[name] = (index == -1) ? 0 : response[index];
	    }
	    // capture branch currents from voltage sources
	    for (var i = this.voltage_sources.length - 1; i >= 0; --i) {
		var v = this.voltage_sources[i];
		result['I('+v.name+')'] = response[v.branch];
	    }

	    result['_time_'] = response[this.N];
	    return result;
	}

	// AC analysis: npts/decade for freqs in range [fstart,fstop]
	// result['_frequencies_'] = vector of log10(sample freqs)
	// result['xxx'] = vector of dB(response for node xxx)
        // NOTE: Normalization removed in schematic.js, jkw.
        Circuit.prototype.ac = function(npts,fstart,fstop,source_name) {

	    if (this.dc() == undefined) { // DC failed, realloc mats and vects.
		return undefined;
	    }

	    var N = this.N;
	    var G = this.G;
	    var C = this.C;

	    // Complex numbers, we're going to need a bigger boat
	    var matrixac = mat_make(2*N, (2*N)+1);

            // Get the source used for ac
	    if (this.device_map[source_name] === undefined) {
		alert('AC analysis refers to unknown source ' + source_name);
		return 'AC analysis failed, unknown source';
	    }
	    this.device_map[source_name].load_ac(this,this.rhs);

	    // build array to hold list of magnitude and phases for each node
	    // last entry is for frequency values
	    var response = new Array(2*N + 1);
	    for (var i = 2*N; i >= 0; --i) response[i] = new Array();

	    // multiplicative frequency increase between freq points
	    var delta_f = Math.exp(Math.LN10/npts);

	    var phase_offset = new Array(N);
	    for (var i = N-1; i >= 0; --i) phase_offset[i] = 0;

	    var f = fstart;
	    fstop *= 1.0001;  // capture that last freq point!
	    while (f <= fstop) {
		var omega = 2 * Math.PI * f;
		response[2*N].push(f);   // 2*N for magnitude and phase

		// Find complex x+jy that sats Gx-omega*Cy=rhs; omega*Cx+Gy=0
		// Note: solac[0:N-1]=x, solac[N:2N-1]=y
		for (var i = N-1; i >= 0; --i) {
		    // First the rhs, replicated for real and imaginary
		    matrixac[i][2*N] = this.rhs[i];
		    matrixac[i+N][2*N] = 0;

		    for (var j = N-1; j >= 0; --j) {
			matrixac[i][j] = G[i][j];
			matrixac[i+N][j+N] = G[i][j];
			matrixac[i][j+N] = -omega*C[i][j];
			matrixac[i+N][j] = omega*C[i][j];
		    }
		}

		// Compute the small signal response
		var solac = mat_solve(matrixac);

		// Save magnitude and phase
		for (var i = N - 1; i >= 0; --i) {
		    var mag = Math.sqrt(solac[i]*solac[i] + solac[i+N]*solac[i+N]);
		    response[i].push(mag);

		    // Avoid wrapping phase, add or sub 180 for each jump
		    var phase = 180*(Math.atan2(solac[i+N],solac[i])/Math.PI);
		    var phasei = response[i+N];
		    var L = phasei.length;
		    // Look for a one-step jump greater than 90 degrees
		    if (L > 1) {
			var phase_jump = phase + phase_offset[i] - phasei[L-1];
			if (phase_jump > 90) {
			    phase_offset[i] -= 360;
			} else if (phase_jump < -90) {
			    phase_offset[i] += 360;
			}
		    }
		    response[i+N].push(phase + phase_offset[i]);
		}
		f *= delta_f;    // increment frequency
	    }

	    // create solution dictionary
	    var result = new Array();
	    for (var name in this.node_map) {
		var index = this.node_map[name];
		result[name] = (index == -1) ? 0 : response[index];
		result[name+'_phase'] = (index == -1) ? 0 : response[index+N];
	    }
	    result['_frequencies_'] = response[2*N];
	    return result;
	}


        // Helper for adding devices to a circuit, warns on duplicate device names.
        Circuit.prototype.add_device = function(d,name) {
	    // Add device to list of devices and to device map
	    this.devices.push(d);
	    d.name = name;
	    if (name) {
		if (this.device_map[name] === undefined) 
		    this.device_map[name] = d;
		else {
		    alert('Warning: two circuit elements share the same name ' + name);
		    this.device_map[name] = d;
		}
	    }
	    return d;
	}

	Circuit.prototype.r = function(n1,n2,v,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof v) == 'string') {
		v = parse_number(v,undefined);
		if (v === undefined) return undefined;
	    }

	    if (v != 0) {
		var d = new Resistor(n1,n2,v);
		return this.add_device(d, name);
	    } else return this.v(n1,n2,'0',name);   // zero resistance == 0V voltage source
	}

	Circuit.prototype.d = function(n1,n2,area,type,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof area) == 'string') {
		area = parse_number(area,undefined);
		if (area === undefined) return undefined;
	    }

	    if (area != 0) {
		var d = new Diode(n1,n2,area,type);
		return this.add_device(d, name);
	    } // zero area diodes discarded.
	}


	Circuit.prototype.c = function(n1,n2,v,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof v) == 'string') {
		v = parse_number(v,undefined);
		if (v === undefined) return undefined;
	    }
	    var d = new Capacitor(n1,n2,v);
	    return this.add_device(d, name);
	}

	Circuit.prototype.l = function(n1,n2,v,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof v) == 'string') {
		v = parse_number(v,undefined);
		if (v === undefined) return undefined;
	    }
	    var branch = this.node(undefined,T_CURRENT);
	    var d = new Inductor(n1,n2,branch,v);
	    return this.add_device(d, name);
	}

        Circuit.prototype.v = function(n1,n2,v,name) {
	    var branch = this.node(undefined,T_CURRENT);
	    var d = new VSource(n1,n2,branch,v);
	    this.voltage_sources.push(d);
	    return this.add_device(d, name);
	}

	Circuit.prototype.i = function(n1,n2,v,name) {
	    var d = new ISource(n1,n2,v);
	    this.current_sources.push(d);
	    return this.add_device(d, name);
	}

        Circuit.prototype.opamp = function(np,nn,no,ng,A,name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof A) == 'string') {
		ratio = parse_number(A,undefined);
		if (A === undefined) return undefined;
	    }
	    var branch = this.node(undefined,T_CURRENT);
	    var d = new Opamp(np,nn,no,ng,branch,A,name);
	    return this.add_device(d, name);
	}

        Circuit.prototype.n = function(d,g,s, ratio, name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof ratio) == 'string') {
		ratio = parse_number(ratio,undefined);
		if (ratio === undefined) return undefined;
	    }
	    var d = new Fet(d,g,s,ratio,name,'n');
	    return this.add_device(d, name);
	}

        Circuit.prototype.p = function(d,g,s, ratio, name) {
	    // try to convert string value into numeric value, barf if we can't
	    if ((typeof ratio) == 'string') {
		ratio = parse_number(ratio,undefined);
		if (ratio === undefined) return undefined;
	    }
	    var d = new Fet(d,g,s,ratio,name,'p');
	    return this.add_device(d, name);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Support for creating conductance and capacitance matrices associated with
        //  modified nodal analysis (unknowns are node voltages and inductor and voltage
        //  source currents). 
        //  The linearized circuit is written as 
        //          C d/dt x = G x + rhs
        //  x - vector of node voltages and element currents
        //  rhs - vector of source values
        //  C - Matrix whose values are capacitances and inductances, has many zero rows.
        //  G - Matrix whose values are conductances and +-1's.
	//
	////////////////////////////////////////////////////////////////////////////////

	// add val component between two nodes to matrix M
	// Index of -1 refers to ground node
        Circuit.prototype.add_two_terminal = function(i,j,g,M) {
	    if (i >= 0) {
		M[i][i] += g;
		if (j >= 0) {
		    M[i][j] -= g;
		    M[j][i] -= g;
		    M[j][j] += g;
		}
	    } else if (j >= 0)
		M[j][j] += g;
	}

	// add val component between two nodes to matrix M
	// Index of -1 refers to ground node
        Circuit.prototype.get_two_terminal = function(i,j,x) {
	    var xi_minus_xj = 0;
	    if (i >= 0) xi_minus_xj = x[i];
	    if (j >= 0) xi_minus_xj -= x[j];
	    return xi_minus_xj
	}

        Circuit.prototype.add_conductance_l = function(i,j,g) {
            this.add_two_terminal(i,j,g, this.Gl)
	}

        Circuit.prototype.add_conductance = function(i,j,g) {
            this.add_two_terminal(i,j,g, this.G)
	}

        Circuit.prototype.add_capacitance = function(i,j,c) {
            this.add_two_terminal(i,j,c,this.C)
	}

	// add individual conductance to Gl matrix
	Circuit.prototype.add_to_Gl = function(i,j,g) {
	    if (i >=0 && j >= 0)
		this.Gl[i][j] += g;
	}

	// add individual conductance to Gl matrix
	Circuit.prototype.add_to_G = function(i,j,g) {
	    if (i >=0 && j >= 0)
		this.G[i][j] += g;
	}

	// add individual capacitance to C matrix
	Circuit.prototype.add_to_C = function(i,j,c) {
	    if (i >=0 && j >= 0)
		this.C[i][j] += c;
	}

	// add source info to rhs
        Circuit.prototype.add_to_rhs = function(i,v,rhs) {
	    if (i >= 0)	rhs[i] += v;
	}


	///////////////////////////////////////////////////////////////////////////////
	//
	//  Generic matrix support - making, copying, factoring, rank, etc
	//  Note, Matrices are stored using nested javascript arrays.
	////////////////////////////////////////////////////////////////////////////////

        // Allocate an NxM matrix
        function mat_make(N,M) {
	    var mat = new Array(N);	
	    for (var i = N - 1; i >= 0; --i) {	    
		mat[i] = new Array(M);
		for (var j = M - 1; j >= 0; --j) {	    
		    mat[i][j] = 0.0;
		}
	    }
	    return mat;
	}

        // Form b = scale*Mx
        function mat_v_mult(M,x,b,scale) {
	    var n = M.length;
	    var m = M[0].length;
	    
	    if (n != b.length || m != x.length)
		throw 'Rows of M mismatched to b or cols mismatch to x.';

	    for (var i = 0; i < n; i++) {
		var temp = 0;
		for (var j = 0; j < m; j++) temp += M[i][j]*x[j];
		b[i] = scale*temp;  // Recall the neg in the name
	    }
	}

        // C = scalea*A + scaleb*B, scalea, scaleb eithers numbers or arrays (row scaling)
        function mat_scale_add(A, B, scalea, scaleb, C) {
	    var n = A.length;
	    var m = A[0].length;
	    
	    if (n > B.length || m > B[0].length)
		throw 'Row or columns of A to large for B';
	    if (n > C.length || m > C[0].length)
		throw 'Row or columns of A to large for C';
	    if ((typeof scalea == 'number') && (typeof scaleb == 'number'))
		for (var i = 0; i < n; i++)
		    for (var j = 0; j < m; j++)
			C[i][j] = scalea*A[i][j] + scaleb*B[i][j];
	    else if ((typeof scaleb == 'number') && (scalea instanceof Array))
		for (var i = 0; i < n; i++)
		    for (var j = 0; j < m; j++)
			C[i][j] = scalea[i]*A[i][j] + scaleb*B[i][j];
	    else if ((typeof scaleb instanceof Array) && (scalea instanceof Array))
		for (var i = 0; i < n; i++)
		    for (var j = 0; j < m; j++)
			C[i][j] = scalea[i]*A[i][j] + scaleb[i]*B[i][j];
	    else
		throw 'scalea and scaleb must be scalars or Arrays';
	}

        // Returns a vector of ones and zeros, ones denote algebraic
        // variables (rows that can be removed without changing rank(M).
        Circuit.prototype.algebraic = function(M) {
	    var Nr = M.length
	    Mc = mat_make(Nr, Nr);
	    mat_copy(M,Mc);
	    var R = mat_rank(Mc);

	    var one_if_alg = new Array(Nr);
	    for (var row = 0; row < Nr; row++) {  // psuedo gnd row small
		for (var col = Nr - 1; col >= 0; --col)
		    Mc[row][col] = 0;
		if (mat_rank(Mc) == R)  // Zeroing row left rank unchanged
		    one_if_alg[row] = 1;
		else { // Zeroing row changed rank, put back
		    for (var col = Nr - 1; col >= 0; --col)
			Mc[row][col] = M[row][col];
		    one_if_alg[row] = 0;
		}
	    }
	    return one_if_alg;
	}

        // Copy A -> using the bounds of A
	function mat_copy(src,dest) {
	    var n = src.length;
	    var m = src[0].length;
	    if (n > dest.length || m >  dest[0].length)
		throw 'Rows or cols > rows or cols of dest';

	    for (var i = 0; i < n; i++)
		for (var j = 0; j < m; j++)
		    dest[i][j] = src[i][j];
	}
	    
        // Copy and transpose A -> using the bounds of A
	function mat_copy_transposed(src,dest) {
	    var n = src.length;
	    var m = src[0].length;
	    if (n > dest[0].length || m >  dest.length)
		throw 'Rows or cols > cols or rows of dest';

	    for (var i = 0; i < n; i++)
		for (var j = 0; j < m; j++)
		    dest[j][i] = src[i][j];
	}


	// Uses GE to determine rank.
        function mat_rank(Mo) {
	    var Nr = Mo.length;  // Number of rows
	    var Nc = Mo[0].length;  // Number of columns
	    var temp,i,j;
	    // Make a copy to avoid overwriting
	    M = mat_make(Nr, Nc);
	    mat_copy(Mo,M);

	    // Find matrix maximum entry
	    var max_abs_entry = 0;
	    for(var row = Nr-1; row >= 0; --row) {
		for(var col = Nr-1; col >= 0; --col) {
		    if (Math.abs(M[row][col]) > max_abs_entry)
			max_abs_entry = Math.abs(M[row][col]);
		}
	    }

	    // Gaussian elimination to find rank
	    var the_rank = 0;
	    var start_col = 0;
	    for (var row = 0; row < Nr; row++) {
		// Search for first nonzero column in the remaining rows.
		for (var col = start_col; col < Nc; col++) {
		    var max_v = Math.abs(M[row][col]);
		    var max_row = row;
		    for (var i = row + 1; i < Nr; i++) {
			temp = Math.abs(M[i][col]);
			if (temp > max_v) { max_v = temp; max_row = i; }
		    }
		    // if max_v non_zero, column is nonzero, eliminate in subsequent rows
		    if (Math.abs(max_v) > eps*max_abs_entry) {
			start_col = col+1;
			the_rank += 1;
		        // Swap rows to get max in M[row][col]
			temp = M[row];
			M[row] = M[max_row];
			M[max_row] = temp;

			// now eliminate this column for all subsequent rows
			for (var i = row + 1; i < Nr; i++) {
			    temp = M[i][col]/M[row][col];   // multiplier for current row
			    if (temp != 0)  // subtract 
			    for (var j = col; j < Nc; j++) M[i][j] -= M[row][j]*temp;
			}
			// Now move on to the next row
			break;
		    }
		}
	    }

	    // return the rank
	    return the_rank;
	}

	// Solve Mx=b and return vector x using R^TQ^T factorization. 
        // Multiplication by R^T implicit, should be null-space free soln.
        // M should have the extra column!
        // Almost everything is in-lined for speed, sigh.
        function mat_solve_rq(M, rhs) {

	    var Nr = M.length;  // Number of rows
	    var Nc = M[0].length;  // Number of columns

	    // Copy the rhs in to the last column of M if one is given.
	    if (rhs != null) {
		for (var row = Nr - 1; row >= 0; --row)
		    M[row][Nc-1] = rhs[row];
	    }

	    var mat_scale = 0; // Sets the scale for comparison to zero.
	    var max_nonzero_row = Nr-1;  // Assumes M nonsingular.
	    for (var row = 0; row < Nr; row++) {  
		// Find largest row with largest 2-norm
		var max_row = row;
		var maxsumsq = 0;
		for (var rowp = row; rowp < Nr; rowp++) {
		    var Mr = M[rowp];
		    var sumsq = 0;
		    for (var col = Nc-2; col >= 0; --col)  // Last col=rhs
			sumsq += Mr[col]*Mr[col];
		    if ((row == rowp) || (sumsq > maxsumsq)) {
			max_row = rowp;
			maxsumsq = sumsq;
		    }
		}
		if (max_row > row) { // Swap rows if not max row
		    var temp = M[row];
		    M[row] = M[max_row];
		    M[max_row] = temp;
		}

		// Calculate row norm, save if this is first (largest)
		row_norm = Math.sqrt(maxsumsq);
		if (row == 0) mat_scale = row_norm;

		// Check for all zero rows
		if (row_norm > mat_scale*eps)
		    scale = 1.0/row_norm;
		else {
		    max_nonzero_row = row - 1;  // Rest will be nullspace of M
		    break;
		}


		// Nonzero row, eliminate from rows below
		var Mr = M[row];
		for (var col =  Nc-1; col >= 0; --col) // Scale rhs also
		    Mr[col] *= scale;
		for (var rowp = row + 1; rowp < Nr; rowp++) { // Update.
		    var Mrp = M[rowp];
		    var inner = 0;
		    for (var col =  Nc-2; col >= 0; --col)  // Project 
			inner += Mr[col]*Mrp[col];
		    for (var col =  Nc-1; col >= 0; --col) // Ortho (rhs also)
			Mrp[col] -= inner *Mr[col];
		}
	    }

	    // Last Column of M has inv(R^T)*rhs.  Scale rows of Q to get x.
	    var x = new Array(Nc-1);
	    for (var col = Nc-2; col >= 0; --col)
		x[col] = 0;
	    for (var row = max_nonzero_row; row >= 0; --row) {
		Mr = M[row];
		for (var col = Nc-2; col >= 0; --col) {
		    x[col] += Mr[col]*Mr[Nc-1];
		}
	    }

	    // Return solution.
	    return x;
	}

	// solve Mx=b and return vector x given augmented matrix M = [A | b]
	// Uses Gaussian elimination with partial pivoting
        function mat_solve(M,rhs) {
	    var N = M.length;      // augmented matrix M has N rows, N+1 columns
	    var temp,i,j;

	    // Copy the rhs in to the last column of M if one is given.
	    if (rhs != null) {
		for (var row = 0; row < N ; row++)
		    M[row][N] = rhs[row];
	    }

	    // gaussian elimination
	    for (var col = 0; col < N ; col++) {
		// find pivot: largest abs(v) in this column of remaining rows
		var max_v = Math.abs(M[col][col]);
		var max_col = col;
		for (i = col + 1; i < N; i++) {
		    temp = Math.abs(M[i][col]);
		    if (temp > max_v) { max_v = temp; max_col = i; }
		}

		// if no value found, generate a small conductance to gnd
		// otherwise swap current row with pivot row
		if (max_v == 0) M[col][col] = eps; 
		else {
		    temp = M[col];
		    M[col] = M[max_col];
		    M[max_col] = temp;
		}

		// now eliminate this column for all subsequent rows
		for (i = col + 1; i < N; i++) {
		    temp = M[i][col]/M[col][col];   // multiplier we'll use for current row
		    if (temp != 0)
			// subtract current row from row we're working on
			// remember to process b too!
			for (j = col; j <= N; j++) M[i][j] -= M[col][j]*temp;
		}
	    }

	    // matrix is now upper triangular, so solve for elements of x starting
	    // with the last row
	    var x = new Array(N);
	    for (i = N-1; i >= 0; --i) {
		temp = M[i][N];   // grab b[i] from augmented matrix as RHS
		// subtract LHS term from RHS using known x values
		for (j = N-1; j > i; --j) temp -= M[i][j]*x[j];
		// now compute new x value
		x[i] = temp/M[i][i];
	    }

	    // return solution
	    return x;
	}

	// test solution code, expect x = [2,3,-1]
	//M = [[2,1,-1,8],[-3,-1,2,-11],[-2,1,2,-3]];
	//x = mat_solve(M);
	//y = 1;  // so we have place to set a breakpoint :)

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Device base class
	//
	////////////////////////////////////////////////////////////////////////////////

	function Device() {
	}

	// complete initial set up of device
	Device.prototype.finalize = function() {
	}

        // Load the linear elements in to Gl and C
        Device.prototype.load_linear = function(ckt) {
	}

	// load linear system equations for dc analysis
	// (inductors shorted and capacitors opened)
        Device.prototype.load_dc = function(ckt,soln,rhs) {
	}

	// load linear system equations for tran analysis
	Device.prototype.load_tran = function(ckt,soln) {
	}

	// load linear system equations for ac analysis:
	// current sources open, voltage sources shorted
	// linear models at operating point for everyone else
	Device.prototype.load_ac = function(ckt,rhs) {
	}

	// return time of next breakpoint for the device
	Device.prototype.breakpoint = function(time) {
	    return undefined;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Parse numbers in engineering notation
	//
	///////////////////////////////////////////////////////////////////////////////

	// convert first character of argument into an integer
	function ord(ch) {
	    return ch.charCodeAt(0);
	}

	// convert string argument to a number, accepting usual notations
	// (hex, octal, binary, decimal, floating point) plus engineering
	// scale factors (eg, 1k = 1000.0 = 1e3).
	// return default if argument couldn't be interpreted as a number
	function parse_number(s,default_v) {
	    var slen = s.length;
	    var multiplier = 1;
	    var result = 0;
	    var index = 0;

	    // skip leading whitespace
	    while (index < slen && s.charAt(index) <= ' ') index += 1;
	    if (index == slen) return default_v;

	    // check for leading sign
	    if (s.charAt(index) == '-') {
		multiplier = -1;
		index += 1;
	    } else if (s.charAt(index) == '+')
		index += 1;
	    var start = index;   // remember where digits start

	    // if leading digit is 0, check for hex, octal or binary notation
	    if (index >= slen) return default_v;
	    else if (s.charAt(index) == '0') {
		index += 1;
		if (index >= slen) return 0;
		if (s.charAt(index) == 'x' || s.charAt(index) == 'X') { // hex
		    while (true) {
			index += 1;
			if (index >= slen) break;
			if (s.charAt(index) >= '0' && s.charAt(index) <= '9')
			    result = result*16 + ord(s.charAt(index)) - ord('0');
			else if (s.charAt(index) >= 'A' && s.charAt(index) <= 'F')
			    result = result*16 + ord(s.charAt(index)) - ord('A') + 10;
			else if (s.charAt(index) >= 'a' && s.charAt(index) <= 'f')
			    result = result*16 + ord(s.charAt(index)) - ord('a') + 10;
			else break;
		    }
		    return result*multiplier;
		} else if (s.charAt(index) == 'b' || s.charAt(index) == 'B') {  // binary
		    while (true) {
			index += 1;
			if (index >= slen) break;
			if (s.charAt(index) >= '0' && s.charAt(index) <= '1')
			    result = result*2 + ord(s.charAt(index)) - ord('0');
			else break;
		    }
		    return result*multiplier;
		} else if (s.charAt(index) != '.') { // octal
		    while (true) {
			if (s.charAt(index) >= '0' && s.charAt(index) <= '7')
			    result = result*8 + ord(s.charAt(index)) - ord('0');
			else break;
			index += 1;
			if (index >= slen) break;
		    }
		    return result*multiplier;
		}
	    }
    
	    // read decimal integer or floating-point number
	    while (true) {
		if (s.charAt(index) >= '0' && s.charAt(index) <= '9')
		    result = result*10 + ord(s.charAt(index)) - ord('0');
		else break;
		index += 1;
		if (index >= slen) break;
	    }

	    // fractional part?
	    if (index < slen && s.charAt(index) == '.') {
		while (true) {
		    index += 1;
		    if (index >= slen) break;
		    if (s.charAt(index) >= '0' && s.charAt(index) <= '9') {
			result = result*10 + ord(s.charAt(index)) - ord('0');
			multiplier *= 0.1;
		    } else break;
		}
	    }

	    // if we haven't seen any digits yet, don't check
	    // for exponents or scale factors
	    if (index == start) return default_v;

	    // type of multiplier determines type of result:
	    // multiplier is a float if we've seen digits past
	    // a decimal point, otherwise it's an int or long.
	    // Up to this point result is an int or long.
	    result *= multiplier;

	    // now check for exponent or engineering scale factor.  If there
	    // is one, result will be a float.
	    if (index < slen) {
		var scale = s.charAt(index);
		index += 1;
		if (scale == 'e' || scale == 'E') {
		    var exponent = 0;
		    multiplier = 10.0;
		    if (index < slen) {
			if (s.charAt(index) == '+') index += 1;
			else if (s.charAt(index) == '-') {
			    index += 1;
			    multiplier = 0.1;
			}
		    }
		    while (index < slen) {
			if (s.charAt(index) >= '0' && s.charAt(index) <= '9') {
			    exponent = exponent*10 + ord(s.charAt(index)) - ord('0');
			    index += 1;
			} else break;
		    }
		    while (exponent > 0) {
			exponent -= 1;
			result *= multiplier;
		    }
		} else if (scale == 't' || scale == 'T') result *= 1e12;
		else if (scale == 'g' || scale == 'G') result *= 1e9;
		else if (scale == 'M') result *= 1e6;
		else if (scale == 'k' || scale == 'K') result *= 1e3;
		else if (scale == 'm') result *= 1e-3;
		else if (scale == 'u' || scale == 'U') result *= 1e-6;
		else if (scale == 'n' || scale == 'N') result *= 1e-9;
		else if (scale == 'p' || scale == 'P') result *= 1e-12;
		else if (scale == 'f' || scale == 'F') result *= 1e-15;
	    }
	    // ignore any remaining chars, eg, 1kohms returns 1000
	    return result;
	}

	Circuit.prototype.parse_number = parse_number;  // make it easy to call from outside

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Sources
	//
	///////////////////////////////////////////////////////////////////////////////

	// argument is a string describing the source's value (see comments for details)
	// source types: dc,step,square,triangle,sin,pulse,pwl,pwl_repeating

	// returns an object with the following attributes:
	//   fun -- name of source function
	//   args -- list of argument values
	//   value(t) -- compute source value at time t
	//   inflection_point(t) -- compute time after t when a time point is needed
	//   dc -- value at time 0
	//   period -- repeat period for periodic sources (0 if not periodic)
	
	function parse_source(v) {
	    // generic parser: parse v as either <value> or <fun>(<value>,...)
	    var src = new Object();
	    src.period = 0; // Default not periodic
	    src.value = function(t) { return 0; }  // overridden below
	    src.inflection_point = function(t) { return undefined; };  // may be overridden below

	    // see if there's a "(" in the description
	    var index = v.indexOf('(');
	    var ch;
	    if (index >= 0) {
		src.fun = v.slice(0,index);   // function name is before the "("
		src.args = [];	// we'll push argument values onto this list
		var end = v.indexOf(')',index);
		if (end == -1) end = v.length;

		index += 1;     // start parsing right after "("
		while (index < end) {
		    // figure out where next argument value starts
		    ch = v.charAt(index);
		    if (ch <= ' ') { index++; continue; }
		    // and where it ends
		    var arg_end = v.indexOf(',',index);
		    if (arg_end == -1) arg_end = end;
		    // parse and save result in our list of arg values
		    src.args.push(parse_number(v.slice(index,arg_end),undefined));
		    index = arg_end + 1;
		}
	    } else {
		src.fun = 'dc';
		src.args = [parse_number(v,0)];
	    }

	    // post-processing for constant sources
	    // dc(v)
	    if (src.fun == 'dc') {
		var v = arg_value(src.args,0,0);
		src.args = [v];
		src.value = function(t) { return v; }  // closure
	    }

	    // post-processing for impulse sources
	    // impulse(height,width)
	    else if (src.fun == 'impulse') {
		var h = arg_value(src.args,0,1);  // default height: 1
		var w = Math.abs(arg_value(src.args,2,1e-9));  // default width: 1ns
		src.args = [h,w];  // remember any defaulted values
		pwl_source(src,[0,0,w/2,h,w,0],false);
	    }

	    // post-processing for step sources
	    // step(v_init,v_plateau,t_delay,t_rise)
	    else if (src.fun == 'step') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var td = Math.max(0,arg_value(src.args,2,0));  // time step starts
		var tr = Math.abs(arg_value(src.args,3,1e-9));  // default rise time: 1ns
		src.args = [v1,v2,td,tr];  // remember any defaulted values
		pwl_source(src,[td,v1,td+tr,v2],false);
	    }

	    // post-processing for square wave
	    // square(v_init,v_plateau,freq,duty_cycle)
	    else if (src.fun == 'square') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var freq = Math.abs(arg_value(src.args,2,1));  // default frequency: 1Hz
		var duty_cycle  = Math.min(100,Math.abs(arg_value(src.args,3,50)));  // default duty cycle: 0.5
		src.args = [v1,v2,freq,duty_cycle];  // remember any defaulted values

		var per = freq == 0 ? Infinity : 1/freq;
		var t_change = 0.01 * per;   // rise and fall time
		var t_pw = .01 * duty_cycle * 0.98 * per;  // fraction of cycle minus rise and fall time
		pwl_source(src,[0,v1,t_change,v2,t_change+t_pw,
				v2,t_change+t_pw+t_change,v1,per,v1],true);
	    }

	    // post-processing for triangle
	    // triangle(v_init,v_plateua,t_period)
	    else if (src.fun == 'triangle') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var freq = Math.abs(arg_value(src.args,2,1));  // default frequency: 1s
		src.args = [v1,v2,freq];  // remember any defaulted values

		var per = freq == 0 ? Infinity : 1/freq;
		pwl_source(src,[0,v1,per/2,v2,per,v1],true);
	    }

	    // post-processing for pwl and pwlr sources
	    // pwl[r](t1,v1,t2,v2,...)
	    else if (src.fun == 'pwl' || src.fun == 'pwl_repeating') {
		pwl_source(src,src.args,src.fun == 'pwl_repeating');
	    }

	    // post-processing for pulsed sources
	    // pulse(v_init,v_plateau,t_delay,t_rise,t_fall,t_width,t_period)
	    else if (src.fun == 'pulse') {
		var v1 = arg_value(src.args,0,0);  // default init value: 0V
		var v2 = arg_value(src.args,1,1);  // default plateau value: 1V
		var td = Math.max(0,arg_value(src.args,2,0));  // time pulse starts
		var tr = Math.abs(arg_value(src.args,3,1e-9));  // default rise time: 1ns
		var tf = Math.abs(arg_value(src.args,4,1e-9));  // default rise time: 1ns
		var pw = Math.abs(arg_value(src.args,5,1e9));  // default pulse width: "infinite"
		var per = Math.abs(arg_value(src.args,6,1e9));  // default period: "infinite"
		src.args = [v1,v2,td,tr,tf,pw,per];

		var t1 = td;       // time when v1 -> v2 transition starts
		var t2 = t1 + tr;  // time when v1 -> v2 transition ends
		var t3 = t2 + pw;  // time when v2 -> v1 transition starts
		var t4 = t3 + tf;  // time when v2 -> v1 transition ends

		pwl_source(src,[t1,v1, t2,v2, t3,v2, t4,v1, per,v1],true);
	    }

	    // post-processing for sinusoidal sources
	    // sin(v_offset,v_amplitude,freq_hz,t_delay,phase_offset_degrees)
	    else if (src.fun == 'sin') {
		var voffset = arg_value(src.args,0,0);  // default offset voltage: 0V
		var va = arg_value(src.args,1,1);  // default amplitude: -1V to 1V
		var freq = Math.abs(arg_value(src.args,2,1));  // default frequency: 1Hz
		src.period = 1.0/freq;

		var td = Math.max(0,arg_value(src.args,3,0));  // default time delay: 0sec
		var phase = arg_value(src.args,4,0);  // default phase offset: 0 degrees
		src.args = [voffset,va,freq,td,phase];

		phase /= 360.0;

		// return value of source at time t
		src.value = function(t) {  // closure
		    if (t < td) return voffset + va*Math.sin(2*Math.PI*phase);
		    else return voffset + va*Math.sin(2*Math.PI*(freq*(t - td) + phase));
		}

		// return time of next inflection point after time t
		src.inflection_point = function(t) {	// closure
		    if (t < td) return td;
		    else return undefined;
		}
	    }
	
	    // object has all the necessary info to compute the source value and inflection points
	    src.dc = src.value(0);   // DC value is value at time 0
	    return src;
	}

	function pwl_source(src,tv_pairs,repeat) {
	    var nvals = tv_pairs.length;
	    if (repeat)
		src.period = tv_pairs[nvals-2];  // Repeat period of source
	    if (nvals % 2 == 1) npts -= 1;  // make sure it's even!

	    if (nvals <= 2) {
		// handle degenerate case
		src.value = function(t) { return nvals == 2 ? tv_pairs[1] : 0; }
		src.inflection_point = function(t) { return undefined; }
	    } else {
		src.value = function(t) { // closure
		    if (repeat)
			// make time periodic if values are to be repeated
			t = Math.fmod(t,tv_pairs[nvals-2]);
		    var last_t = tv_pairs[0];
		    var last_v = tv_pairs[1];
		    if (t > last_t) {
			var next_t,next_v;
			for (var i = 2; i < nvals; i += 2) {
			    next_t = tv_pairs[i];
			    next_v = tv_pairs[i+1];
			    if (next_t > last_t)  // defend against bogus tv pairs
				if (t < next_t)
				    return last_v + (next_v - last_v)*(t - last_t)/(next_t - last_t);
			    last_t = next_t;
			    last_v = next_v;
			}
		    }
		    return last_v;
		}
		src.inflection_point = function(t) {  // closure
		    if (repeat)
			// make time periodic if values are to be repeated
			t = Math.fmod(t,tv_pairs[nvals-2]);
		    for (var i = 0; i < nvals; i += 2) {
			var next_t = tv_pairs[i];
			if (t < next_t) return next_t;
		    }
		    return undefined;
		}
	    }
	}

	// helper function: return args[index] if present, else default_v
	function arg_value(args,index,default_v) {
	    if (index < args.length) {
		var result = args[index];
		if (result === undefined) result = default_v;
		return result;
	    } else return default_v;
	}

	// we need fmod in the Math library!
	Math.fmod = function(numerator,denominator) {
	    var quotient = Math.floor(numerator/denominator);
	    return numerator - quotient*denominator;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Sources
	//
	///////////////////////////////////////////////////////////////////////////////

        function VSource(npos,nneg,branch,v) {
	    Device.call(this);
	    
	    this.src = parse_source(v);
	    this.npos = npos;
	    this.nneg = nneg;
	    this.branch = branch;
	}
	VSource.prototype = new Device();
	VSource.prototype.constructor = VSource;

	// load linear part for source evaluation
        VSource.prototype.load_linear = function(ckt) {
	    // MNA stamp for independent voltage source
	    ckt.add_to_Gl(this.branch,this.npos,1.0);
	    ckt.add_to_Gl(this.branch,this.nneg,-1.0);
	    ckt.add_to_Gl(this.npos,this.branch,1.0);
	    ckt.add_to_Gl(this.nneg,this.branch,-1.0);
	}

	// Source voltage added to b.
        VSource.prototype.load_dc = function(ckt,soln,rhs) {
	    ckt.add_to_rhs(this.branch,this.src.dc,rhs);  
	}

	// Load time-dependent value for voltage source for tran
        VSource.prototype.load_tran = function(ckt,soln,rhs,time) {
	    ckt.add_to_rhs(this.branch,this.src.value(time),rhs);  
	}

	// return time of next breakpoint for the device
	VSource.prototype.breakpoint = function(time) {
	    return this.src.inflection_point(time);
	}

	// small signal model ac value
        VSource.prototype.load_ac = function(ckt,rhs) {
	    ckt.add_to_rhs(this.branch,1.0,rhs);
	}

	function ISource(npos,nneg,v) {
	    Device.call(this);

	    this.src = parse_source(v);
	    this.npos = npos;
	    this.nneg = nneg;
	}
	ISource.prototype = new Device();
	ISource.prototype.constructor = ISource;

        ISource.prototype.load_linear = function(ckt) {
	    // Current source is open when off, no linear contribution
	}

	// load linear system equations for dc analysis
	ISource.prototype.load_dc = function(ckt,soln,rhs) {
	    var is = this.src.dc;

	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.npos,-is,rhs);  // current flow into npos
	    ckt.add_to_rhs(this.nneg,is,rhs);   // and out of nneg
	}

	// load linear system equations for tran analysis (just like DC)
        ISource.prototype.load_tran = function(ckt,soln,rhs,time) {
	    var is = this.src.value(time);

	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.npos,-is,rhs);  // current flow into npos
	    ckt.add_to_rhs(this.nneg,is,rhs);   // and out of nneg
	}

	// return time of next breakpoint for the device
	ISource.prototype.breakpoint = function(time) {
	    return this.src.inflection_point(time);
	}

	// small signal model: open circuit
        ISource.prototype.load_ac = function(ckt,rhs) {
	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.npos,-1.0,rhs);  // current flow into npos
	    ckt.add_to_rhs(this.nneg,1.0,rhs);   // and out of nneg
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Resistor
	//
	///////////////////////////////////////////////////////////////////////////////

	function Resistor(n1,n2,v) {
	    Device.call(this);
	    this.n1 = n1;
	    this.n2 = n2;
	    this.g = 1.0/v;
	}
	Resistor.prototype = new Device();
	Resistor.prototype.constructor = Resistor;

        Resistor.prototype.load_linear = function(ckt) {
	    // MNA stamp for admittance g
	    ckt.add_conductance_l(this.n1,this.n2,this.g);
	}

	Resistor.prototype.load_dc = function(ckt) {
	    // Nothing to see here, move along.
	}

	Resistor.prototype.load_tran = function(ckt,soln) {
	}

	Resistor.prototype.load_ac = function(ckt) {
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Diode
	//
	///////////////////////////////////////////////////////////////////////////////

	function Diode(n1,n2,v,type) {
	    Device.call(this);
	    this.anode = n1;
	    this.cathode = n2;
	    this.area = v;
	    this.type = type;  // 'normal' or 'ideal'
	    this.is = 1.0e-14;
	    this.ais = this.area * this.is;
	    this.vt = (type == 'normal') ? 25.8e-3 : 0.1e-3;  // 26mv or .1mv
	    this.exp_arg_max = 50;  // less than single precision max.
	    this.exp_max = Math.exp(this.exp_arg_max);
	}
	Diode.prototype = new Device();
        Diode.prototype.constructor = Diode;

        Diode.prototype.load_linear = function(ckt) {
	    // Diode is not linear, has no linear piece.
	}

        Diode.prototype.load_dc = function(ckt,soln,rhs) {
	    var vd = ckt.get_two_terminal(this.anode, this.cathode, soln);
	    var exp_arg = vd / this.vt;
	    var temp1, temp2;
	    // Estimate exponential with a quadratic if arg too big.
	    var abs_exp_arg = Math.abs(exp_arg);
	    var d_arg = abs_exp_arg - this.exp_arg_max;
	    if (d_arg > 0) {
		var quad = 1 + d_arg + 0.5*d_arg*d_arg;
		temp1 = this.exp_max * quad;
		temp2 = this.exp_max * (1 + d_arg);
	    } else {
		temp1 = Math.exp(abs_exp_arg);
		temp2 = temp1;
	    }
	    if (exp_arg < 0) {  // Use exp(-x) = 1.0/exp(x)
		temp1 = 1.0/temp1;
		temp2 = (temp1*temp2)*temp1;
	    }
	    var id = this.ais * (temp1 - 1);
	    var gd = this.ais * (temp2 / this.vt);

	    // MNA stamp for independent current source
	    ckt.add_to_rhs(this.anode,-id,rhs);  // current flows into anode
	    ckt.add_to_rhs(this.cathode,id,rhs);   // and out of cathode
	    ckt.add_conductance(this.anode,this.cathode,gd);
	}

        Diode.prototype.load_tran = function(ckt,soln,rhs,time) {
	    this.load_dc(ckt,soln,rhs);
	}

	Diode.prototype.load_ac = function(ckt) {
	}


	///////////////////////////////////////////////////////////////////////////////
	//
	//  Capacitor
	//
	///////////////////////////////////////////////////////////////////////////////

	function Capacitor(n1,n2,v) {
	    Device.call(this);
	    this.n1 = n1;
	    this.n2 = n2;
	    this.value = v;
	}
	Capacitor.prototype = new Device();
	Capacitor.prototype.constructor = Capacitor;

        Capacitor.prototype.load_linear = function(ckt) {
	    // MNA stamp for capacitance matrix 
	    ckt.add_capacitance(this.n1,this.n2,this.value);
	}

	Capacitor.prototype.load_dc = function(ckt,soln,rhs) {
	}

	Capacitor.prototype.load_ac = function(ckt) {
	}

	Capacitor.prototype.load_tran = function(ckt) {
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Inductor
	//
	///////////////////////////////////////////////////////////////////////////////

	function Inductor(n1,n2,branch,v) {
	    Device.call(this);
	    this.n1 = n1;
	    this.n2 = n2;
	    this.branch = branch;
	    this.value = v;
	}
	Inductor.prototype = new Device();
	Inductor.prototype.constructor = Inductor;

        Inductor.prototype.load_linear = function(ckt) {
	    // MNA stamp for inductor linear part
	    // L on diag of C because L di/dt = v(n1) - v(n2)
	    ckt.add_to_Gl(this.n1,this.branch,1);
	    ckt.add_to_Gl(this.n2,this.branch,-1);
	    ckt.add_to_Gl(this.branch,this.n1,-1);
	    ckt.add_to_Gl(this.branch,this.n2,1);
	    ckt.add_to_C(this.branch,this.branch,this.value)
	}

	Inductor.prototype.load_dc = function(ckt,soln,rhs) {
	    // Inductor is a short at dc, so is linear.
	}

	Inductor.prototype.load_ac = function(ckt) {
	}

	Inductor.prototype.load_tran = function(ckt) {
	}



	///////////////////////////////////////////////////////////////////////////////
	//
	//  Simple Voltage-Controlled Voltage Source Op Amp model 
	//
	///////////////////////////////////////////////////////////////////////////////

        function Opamp(np,nn,no,ng,branch,A,name) {
	    Device.call(this);
	    this.np = np;
	    this.nn = nn;
	    this.no = no;
	    this.ng = ng;
	    this.branch = branch;
	    this.gain = A;
	    this.name = name;
	}

	Opamp.prototype = new Device();
        Opamp.prototype.constructor = Opamp;
        
        Opamp.prototype.load_linear = function(ckt) {
            // MNA stamp for VCVS: 1/A(v(no) - v(ng)) - (v(np)-v(nn))) = 0.
	    var invA = 1.0/this.gain;
	    ckt.add_to_Gl(this.no,this.branch,1);
	    ckt.add_to_Gl(this.ng,this.branch,-1);
	    ckt.add_to_Gl(this.branch,this.no,invA);
	    ckt.add_to_Gl(this.branch,this.ng,-invA);
	    ckt.add_to_Gl(this.branch,this.np,-1);
	    ckt.add_to_Gl(this.branch,this.nn,1);
	}

	Opamp.prototype.load_dc = function(ckt,soln,rhs) {
	    // Op-amp is linear.
	}

	Opamp.prototype.load_ac = function(ckt) {
	}

	Opamp.prototype.load_tran = function(ckt) {
	}



	///////////////////////////////////////////////////////////////////////////////
	//
	//  Simplified MOS FET with no bulk connection and no body effect.
	//
	///////////////////////////////////////////////////////////////////////////////


        function Fet(d,g,s,ratio,name,type) {
	    Device.call(this);
	    this.d = d;
	    this.g = g;
	    this.s = s;
	    this.name = name;
	    this.ratio = ratio;
	    if (type != 'n' && type != 'p')
	    { throw 'fet type is not n or p';
	    }
	    this.type_sign = (type == 'n') ? 1 : -1;
	    this.vt = 0.5;
	    this.kp = 20e-6;
            this.beta = this.kp * this.ratio;
	    this.lambda = 0.05;
	}
	Fet.prototype = new Device();
        Fet.prototype.constructor = Fet;

        Fet.prototype.load_linear = function(ckt) {
	    // FET's are nonlinear, just like javascript progammers
	}

        Fet.prototype.load_dc = function(ckt,soln,rhs) {
	    var vds = this.type_sign * ckt.get_two_terminal(this.d, this.s, soln);
	    if (vds < 0) { // Drain and source have swapped roles
		var temp = this.d;
		this.d = this.s;
		this.s = temp;
		vds = this.type_sign * ckt.get_two_terminal(this.d, this.s, soln);
	    }
	    var vgs = this.type_sign * ckt.get_two_terminal(this.g, this.s, soln);
	    var vgst = vgs - this.vt;
	    with (this) {
		var gmgs,ids,gds;
		if (vgst > 0.0 ) { // vgst < 0, transistor off, no subthreshold here.
		    if (vgst < vds) { /* Saturation. */
			gmgs =  beta * (1 + (lambda * vds)) * vgst;
			ids = type_sign * 0.5 * gmgs * vgst;
			gds = 0.5 * beta * vgst * vgst * lambda;
		    } else {  /* Linear region */
			gmgs =  beta * (1 + lambda * vds);
			ids = type_sign * gmgs * vds * (vgst - 0.50 * vds);
			gds = gmgs * (vgst - vds) + beta * lambda * vds * (vgst - 0.5 * vds);
			gmgs *= vds;
		    }
		    ckt.add_to_rhs(d,-ids,rhs);  // current flows into the drain
		    ckt.add_to_rhs(s, ids,rhs);   // and out the source		    
		    ckt.add_conductance(d,s,gds);
		    ckt.add_to_G(s,s, gmgs);
		    ckt.add_to_G(d,s,-gmgs);
		    ckt.add_to_G(d,g, gmgs);
		    ckt.add_to_G(s,g,-gmgs);
		}
	    }
	}

	Fet.prototype.load_tran = function(ckt,soln,rhs) {
	    this.load_dc(ckt,soln,rhs);
	}

	Fet.prototype.load_ac = function(ckt) {
	}


	///////////////////////////////////////////////////////////////////////////////
	//
	//  Module definition
	//
	///////////////////////////////////////////////////////////////////////////////
	var module = {
	    'Circuit': Circuit,
	    'parse_number': parse_number,
	    'parse_source': parse_source
	}
	return module;
    }());

/////////////////////////////////////////////////////////////////////////////
//
//  Simple schematic capture
//
////////////////////////////////////////////////////////////////////////////////

// Copyright (C) 2011 Massachusetts Institute of Technology

// add schematics to a document with 
//
//   <input type="hidden" class="schematic" name="unique_form_id" value="JSON netlist..." .../>
//
// other attributes you can add to the input tag:
//   width -- width in pixels of diagram
//   height -- height in pixels of diagram
//   parts -- comma-separated list of parts for parts bin (see parts_map),
//            parts="" disables editing of diagram

// JSON schematic representation:
//  sch :=  [part, part, ...]
//  part := [type, coords, properties, connections]
//  type := string (see parts_map)
//  coords := [number, ...]  // (x,y,rot) or (x1,y1,x2,y2)
//  properties := {name: value, ...}
//  connections := [node, ...]   // one per connection point in canoncial order
//  node := string
// need a netlist? just use the part's type, properites and connections

// TO DO:
// - wire labels?
// - zoom/scroll canvas
// - rotate multiple objects around their center of mass
// - rubber band wires when moving components

// set up each schematic entry widget
function update_schematics() {
    // set up each schematic on the page
    var schematics = $('.schematic');
    for (var i = 0; i < schematics.length; ++i)
	if (schematics[i].getAttribute("loaded") != "true") {
	    try {
		new schematic.Schematic(schematics[i]);
	    } catch (err) {
		var msgdiv = document.createElement('div');
		msgdiv.style.border = 'thick solid #FF0000';
		msgdiv.style.margins = '20px';
		msgdiv.style.padding = '20px';
		var msg = document.createTextNode('Sorry, there a browser error in starting the schematic tool.  The tool is known to be compatible with the latest versions of Firefox and Chrome, which we recommend you use.');
		msgdiv.appendChild(msg);
		schematics[i].parentNode.insertBefore(msgdiv,schematics[i]);
	    }
	    schematics[i].setAttribute("loaded","true");
	}
}
window.update_schematics = update_schematics;

// add ourselves to the tasks that get performed when window is loaded
function add_schematic_handler(other_onload) {
    return function() {
	// execute othe onload functions first
	if (other_onload) other_onload();

	update_schematics();
    }
}
/*
 * THK: Attaching update_schematic to window.onload is rather presumptuous...
 *      The function is called for EVERY page load, whether in courseware or in
 *      course info, in 6.002x or the public health course. It is also redundant
 *      because courseware includes an explicit call to update_schematic after
 *      each ajax exchange. In this case, calling update_schematic twice appears 
 *      to contribute to a bug in Firefox that does not render the schematic
 *      properly depending on timing.
 */
//window.onload = add_schematic_handler(window.onload);

// ask each schematic input widget to update its value field for submission
function prepare_schematics() {
    var schematics = $('.schematic');
    for (var i = schematics.length - 1; i >= 0; i--)
	schematics[i].schematic.update_value();
}

schematic = (function() {
	background_style = 'rgb(220,220,220)';
	element_style = 'rgb(255,255,255)';
	thumb_style = 'rgb(128,128,128)';
	normal_style = 'rgb(0,0,0)';  // default drawing color
	component_style = 'rgb(64,64,255)';  // color for unselected components
	selected_style = 'rgb(64,255,64)';  // highlight color for selected components
	grid_style = "rgb(128,128,128)";
	annotation_style = 'rgb(255,64,64)';  // color for diagram annotations

	property_size = 5;  // point size for Component property text
	annotation_size = 6;  // point size for diagram annotations

	// list of all the defined parts
	parts_map = {
	    'g': [Ground, 'Ground connection'],
	    'L': [Label, 'Node label'],
	    'v': [VSource, 'Voltage source'],
	    'i': [ISource, 'Current source'],
	    'r': [Resistor, 'Resistor'],
	    'c': [Capacitor, 'Capacitor'],
	    'l': [Inductor, 'Inductor'],
	    'o': [OpAmp, 'Op Amp'],
	    'd': [Diode, 'Diode'],
	    'n': [NFet, 'NFet'],
	    'p': [PFet, 'PFet'],
	    's': [Probe, 'Voltage Probe'],
	    'a': [Ammeter, 'Current Probe']
	};

	// global clipboard
	if (typeof sch_clipboard == 'undefined')
	    sch_clipboard = [];

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Schematic = diagram + parts bin + status area
	//
	////////////////////////////////////////////////////////////////////////////////

	// setup a schematic by populating the <div> with the appropriate children
	function Schematic(input) {
	    // set up diagram viewing parameters
	    this.show_grid = true;
	    this.grid = 8;
	    this.scale = 2;
	    this.origin_x = input.getAttribute("origin_x");
	    if (this.origin_x == undefined) this.origin_x = 0;
	    this.origin_y = input.getAttribute("origin_y");
	    if (this.origin_y == undefined) this.origin_y = 0;
	    this.cursor_x = 0;
	    this.cursor_y = 0;

	    this.window_list = [];  // list of pop-up windows in increasing z order

	    // use user-supplied list of parts if supplied
	    // else just populate parts bin with all the parts
	    this.edits_allowed = true;
	    var parts = input.getAttribute('parts');
	    if (parts == undefined || parts == 'None') {
		parts = new Array();
		for (var p in parts_map) parts.push(p);
	    } else if (parts == '') {
		this.edits_allowed = false;
		parts = [];
	    } else parts = parts.split(',');

	    // now add the parts to the parts bin
	    this.parts_bin = [];
	    for (var i = 0; i < parts.length; i++) {
		var part = new Part(this);
		var pm = parts_map[parts[i]];
		part.set_component(new pm[0](0,0,0),pm[1]);
		this.parts_bin.push(part);
	    }

	    // use user-supplied list of analyses, otherwise provide them all
	    // analyses="" means no analyses
	    var analyses = input.getAttribute('analyses');
	    if (analyses == undefined || analyses == 'None')
		analyses = ['dc','ac','tran'];
	    else if (analyses == '') analyses = [];
	    else analyses = analyses.split(',');

	    if (parts.length == 0 && analyses.length == 0) this.diagram_only = true;
	    else this.diagram_only = false;

	    // see what we need to submit.  Expecting attribute of the form
	    // submit_analyses="{'tran':[[node_name,t1,t2,t3],...],
	    //                   'ac':[[node_name,f1,f2,...],...]}"
	    var submit = input.getAttribute('submit_analyses');
	    if (submit && submit.indexOf('{') != -1)
		this.submit_analyses = JSON.parse(submit);
	    else
		this.submit_analyses = undefined;

	    // toolbar
	    this.tools = new Array();
	    this.toolbar = [];

        /* DISABLE HELP BUTTON (target URL not consistent with multicourse hierarchy) -- SJSU
	    if (!this.diagram_only) {
		this.tools['help'] = this.add_tool(help_icon,'Help: display help page',this.help);
		this.enable_tool('help',true);
		this.toolbar.push(null);  // spacer
	    }
        END DISABLE HELP BUTTON -- SJSU */

	    if (this.edits_allowed) {
		this.tools['grid'] = this.add_tool(grid_icon,'Grid: toggle grid display',this.toggle_grid);
		this.enable_tool('grid',true);
		this.tools['cut'] = this.add_tool(cut_icon,'Cut: move selected components from diagram to the clipboard',this.cut);
		this.tools['copy'] = this.add_tool(copy_icon,'Copy: copy selected components into the clipboard',this.copy);
		this.tools['paste'] = this.add_tool(paste_icon,'Paste: copy clipboard into the diagram',this.paste);
		this.toolbar.push(null);  // spacer
	    }

	    // simulation interface if cktsim.js is loaded
	    if (typeof cktsim != 'undefined') {
		if (analyses.indexOf('dc') != -1) {
		    this.tools['dc'] = this.add_tool('DC','DC Analysis',this.dc_analysis);
		    this.enable_tool('dc',true);
		    this.dc_max_iters = '1000';  // default values dc solution
		}

		if (analyses.indexOf('ac') != -1) {
		    this.tools['ac'] = this.add_tool('AC','AC Small-Signal Analysis',this.setup_ac_analysis);
		    this.enable_tool('ac',true);
		    this.ac_npts = '50'; // default values for AC Analysis
		    this.ac_fstart = '10';
		    this.ac_fstop = '1G';
		    this.ac_source_name = undefined;
		}

		if (analyses.indexOf('tran') != -1) {
		    this.tools['tran'] = this.add_tool('TRAN','Transient Analysis',this.transient_analysis);
		    this.enable_tool('tran',true);
		    this.tran_npts = '100';  // default values for transient analysis
		    this.tran_tstop = '1';
		}
	    }
 
	    // set up diagram canvas
	    this.canvas = document.createElement('canvas');
	    this.width = input.getAttribute('width');
	    this.width = parseInt(this.width == undefined ? '400' : this.width);
	    this.canvas.width = this.width;
	    this.height = input.getAttribute('height');
	    this.height = parseInt(this.height == undefined ? '300' : this.height);
	    this.canvas.height = this.height;

	    this.sctl_r = 16;   // scrolling control parameters
	    this.sctl_x = this.sctl_r + 8;   // upper left
	    this.sctl_y = this.sctl_r + 8;
	    this.zctl_left = this.sctl_x - 8;
	    this.zctl_top = this.sctl_y + this.sctl_r + 8;

	    // repaint simply draws this buffer and then adds selected elements on top
	    this.bg_image = document.createElement('canvas');
	    this.bg_image.width = this.width;
	    this.bg_image.height = this.height;

	    if (!this.diagram_only) {
		this.canvas.tabIndex = 1; // so we get keystrokes
		this.canvas.style.borderStyle = 'solid';
		this.canvas.style.borderWidth = '1px';
		this.canvas.style.borderColor = grid_style;
		this.canvas.style.outline = 'none';
	    }

	    this.canvas.schematic = this;
	    if (this.edits_allowed) {
		this.canvas.addEventListener('mousemove',schematic_mouse_move,false);
		this.canvas.addEventListener('mouseover',schematic_mouse_enter,false);
		this.canvas.addEventListener('mouseout',schematic_mouse_leave,false);
		this.canvas.addEventListener('mousedown',schematic_mouse_down,false);
		this.canvas.addEventListener('mouseup',schematic_mouse_up,false);
		this.canvas.addEventListener('mousewheel',schematic_mouse_wheel,false);
		this.canvas.addEventListener('DOMMouseScroll',schematic_mouse_wheel,false);  // for FF
		this.canvas.addEventListener('dblclick',schematic_double_click,false);
		this.canvas.addEventListener('keydown',schematic_key_down,false);
		this.canvas.addEventListener('keyup',schematic_key_up,false);
	    }

	    // set up message area
	    if (!this.diagram_only) {
		this.status_div = document.createElement('div');
		this.status = document.createTextNode('');
		this.status_div.appendChild(this.status);
		this.status_div.style.height = status_height + 'px';
	    } else this.status_div = undefined;

	    this.connection_points = new Array();  // location string => list of cp's
	    this.components = [];

	    this.dragging = false;
	    this.select_rect = undefined;
	    this.wire = undefined;

	    this.operating_point = undefined;  // result from DC analysis
	    this.dc_results = undefined;   // saved analysis results for submission
	    this.ac_results = undefined;   // saved analysis results for submission
	    this.transient_results = undefined;   // saved analysis results for submission

	    // state of modifier keys
	    this.ctrlKey = false;
	    this.shiftKey = false;
	    this.altKey = false;
	    this.cmdKey = false;

	    // make sure other code can find us!
	    input.schematic = this;
	    this.input = input;

	    // set up DOM -- use nested tables to do the layout
	    var table,tr,td;
	    table = document.createElement('table');
	    table.rules = 'none';
	    if (!this.diagram_only) {
		table.frame = 'box';
		table.style.borderStyle = 'solid';
		table.style.borderWidth = '2px';
		table.style.borderColor = normal_style;
		table.style.backgroundColor = background_style;
	    }

	    // add tools to DOM
	    if (this.toolbar.length > 0) {
		tr = document.createElement('tr');
		table.appendChild(tr);
		td = document.createElement('td');
		td.style.verticalAlign = 'top';
		td.colSpan = 2;
		tr.appendChild(td);
		for (var i = 0; i < this.toolbar.length; ++i) {
		    var tool = this.toolbar[i];
		    if (tool != null) td.appendChild(tool);
		}
	    }
	    
	    // add canvas and parts bin to DOM
	    tr = document.createElement('tr');
	    table.appendChild(tr);

	    td = document.createElement('td');
	    tr.appendChild(td);
	    var wrapper = document.createElement('div'); // for inserting pop-up windows
	    td.appendChild(wrapper);
	    wrapper.style.position = 'relative';  // so we can position subwindows
	    wrapper.appendChild(this.canvas);

	    td = document.createElement('td');
	    td.style.verticalAlign = 'top';
	    tr.appendChild(td);
	    var parts_table = document.createElement('table');
	    td.appendChild(parts_table);
	    parts_table.rules = 'none';
	    parts_table.frame = 'void';
	    parts_table.cellPadding = '0';
	    parts_table.cellSpacing = '0';

	    // fill in parts_table
	    var parts_per_column = Math.floor(this.height / (part_h + 5));  // mysterious extra padding
	    for (var i = 0; i < parts_per_column; ++i) {
		tr = document.createElement('tr');
		parts_table.appendChild(tr);
		for (var j = i; j < this.parts_bin.length; j += parts_per_column) {
		    td = document.createElement('td');
		    tr.appendChild(td);
		    td.appendChild(this.parts_bin[j].canvas);
		}
	    }

	    if (this.status_div != undefined) {
		tr = document.createElement('tr');
		table.appendChild(tr);
		td = document.createElement('td');
		tr.appendChild(td);
		td.colSpan = 2;
		td.appendChild(this.status_div);
	    }

	    // add to dom
	    // avoid Chrome bug that changes to text cursor whenever
	    // drag starts.  Just do this in schematic tool...
	    var toplevel = document.createElement('div');
	    toplevel.onselectstart = function(){ return false; };
	    toplevel.appendChild(table);
	    this.input.parentNode.insertBefore(toplevel,this.input.nextSibling);

	    // process initial contents of diagram
	    this.load_schematic(this.input.getAttribute('value'),
				this.input.getAttribute('initial_value'));

	    // start by centering diagram on the screen
	    this.zoomall();
	}

	part_w = 42;   // size of a parts bin compartment
	part_h = 42;
	status_height = 18;

	Schematic.prototype.add_component = function(new_c) {
	    this.components.push(new_c);

	    // create undoable edit record here
	}

	Schematic.prototype.remove_component = function(c) {
	    var index = this.components.indexOf(c);
	    if (index != -1) this.components.splice(index,1);
	}

	Schematic.prototype.find_connections = function(cp) {
	    return this.connection_points[cp.location];
	}

	// add connection point to list of connection points at that location
	Schematic.prototype.add_connection_point = function(cp) {
	    var cplist = this.connection_points[cp.location];
	    if (cplist) cplist.push(cp);
	    else {
		cplist = [cp];
		this.connection_points[cp.location] = cplist;
	    }

	    // return list of conincident connection points
	    return cplist;
	}

	// remove connection point from the list points at the old location
	Schematic.prototype.remove_connection_point = function(cp,old_location) {
	    // remove cp from list at old location
	    var cplist = this.connection_points[old_location];
	    if (cplist) {
		var index = cplist.indexOf(cp);
		if (index != -1) {
		    cplist.splice(index,1);
		    // if no more connections at this location, remove
		    // entry from array to keep our search time short
		    if (cplist.length == 0)
			delete this.connection_points[old_location];
		}
	    }
	}

	// connection point has changed location: remove, then add
	Schematic.prototype.update_connection_point = function(cp,old_location) {
	    this.remove_connection_point(cp,old_location);
	    return this.add_connection_point(cp);
	}

	// add a wire to the schematic
	Schematic.prototype.add_wire = function(x1,y1,x2,y2) {
	    var new_wire = new Wire(x1,y1,x2,y2);
	    new_wire.add(this);
	    new_wire.move_end();
	    return new_wire;
	}

	Schematic.prototype.split_wire = function(w,cp) {
	    // remove bisected wire
	    w.remove();

	    // add two new wires with connection point cp in the middle
	    this.add_wire(w.x,w.y,cp.x,cp.y);
	    this.add_wire(w.x+w.dx,w.y+w.dy,cp.x,cp.y);
	}

	// see if connection points of component c split any wires
	Schematic.prototype.check_wires = function(c) {
	    for (var i = 0; i < this.components.length; i++) {
		var cc = this.components[i];
		if (cc != c) {  // don't check a component against itself
		    // only wires will return non-null from a bisect call
		    var cp = cc.bisect(c);
		    if (cp) {
			// cc is a wire bisected by connection point cp
			this.split_wire(cc,cp);
			this.redraw_background();
		    }
		}
	    }
	}

	// see if there are any existing connection points that bisect wire w
	Schematic.prototype.check_connection_points = function(w) {
	    for (var locn in this.connection_points) {
		var cplist = this.connection_points[locn];
		if (cplist && w.bisect_cp(cplist[0])) {
		    this.split_wire(w,cplist[0]);
		    this.redraw_background();

		    // stop here, new wires introduced by split will do their own checks
		    return;
		}
	    }
	}

	// merge collinear wires sharing an end point
	Schematic.prototype.clean_up_wires = function() {
	    for (var locn in this.connection_points) {
		var cplist = this.connection_points[locn];
		if (cplist && cplist.length == 2) {
		    // found a connection with just two connections, see if they're wires
		    var c1 = cplist[0].parent;
		    var c2 = cplist[1].parent;
		    if (c1.type == 'w' && c2.type == 'w') {
			var e1 = c1.other_end(cplist[0]);
			var e2 = c2.other_end(cplist[1]);
			var e3 = cplist[0];  // point shared by the two wires
			if (collinear(e1,e2,e3)) {
			    c1.remove();
			    c2.remove();
			    this.add_wire(e1.x,e1.y,e2.x,e2.y);
			}
		    }
		}
	    }
	}

	Schematic.prototype.unselect_all = function(which) {
	    this.operating_point = undefined;  // remove annotations

	    for (var i = this.components.length - 1; i >= 0; --i)
		if (i != which) this.components[i].set_select(false);
	}

	Schematic.prototype.drag_begin = function() {
	    // let components know they're about to move
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.selected) component.move_begin();
	    }

	    // remember where drag started
	    this.drag_x = this.cursor_x;
	    this.drag_y = this.cursor_y;
	    this.dragging = true;
	}

	Schematic.prototype.drag_end = function() {
	    // let components know they're done moving
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.selected) component.move_end();
	    }
	    this.dragging = false;

	    this.clean_up_wires();
	    this.redraw_background();
	}

	Schematic.prototype.help = function() {
	    window.open('/static/handouts/schematic_tutorial.pdf');
	}

	// zoom diagram around given coords
	Schematic.prototype.rescale = function(nscale,cx,cy) {
	    if (cx == undefined) {
		// use current center point if no point has been specified
		cx = this.origin_x + this.width/(2*this.scale);
		cy = this.origin_y + this.height/(2*this.scale);
	    }

	    this.origin_x += cx*(this.scale - nscale);
	    this.origin_y += cy*(this.scale - nscale);
	    this.scale = nscale;


	    //this.origin_x = cx - this.width/(2*this.scale);
	    //this.origin_y = cy - this.height/(2*this.scale);

	    this.redraw_background();
	}

	Schematic.prototype.toggle_grid = function() {
	    this.show_grid = !this.show_grid;
	    this.redraw_background();
	}

	zoom_factor = 1.25;    // scaling is some power of zoom_factor
	zoom_min = 0.5;
	zoom_max = 4.0;
	origin_min = -200;    // in grids
	origin_max = 200;

	Schematic.prototype.zoomin = function() {
	    var nscale = this.scale * zoom_factor;

	    if (nscale < zoom_max) {
		// keep center of view unchanged
		this.origin_x += (this.width/2)*(1.0/this.scale - 1.0/nscale);
		this.origin_y += (this.height/2)*(1.0/this.scale - 1.0/nscale);
		this.scale = nscale;
		this.redraw_background();
	    }
	}

	Schematic.prototype.zoomout = function() {
	    var nscale = this.scale / zoom_factor;

	    if (nscale > zoom_min) {
		// keep center of view unchanged
		this.origin_x += (this.width/2)*(1.0/this.scale - 1.0/nscale);
		this.origin_y += (this.height/2)*(1.0/this.scale - 1.0/nscale);
		this.scale = nscale;
		this.redraw_background();
	    }
	}

	Schematic.prototype.zoomall = function() {
	    // w,h for schematic including a 25% margin on all sides
	    var sch_w = 1.5*(this.bbox[2] - this.bbox[0]);
	    var sch_h = 1.5*(this.bbox[3] - this.bbox[1]);

	    if (sch_w == 0 && sch_h == 0) {
		this.origin_x = 0;
		this.origin_y = 0;
		this.scale = 2;
	    } else {
		// compute scales that would make schematic fit, choose smallest
		var scale_x = this.width/sch_w;
		var scale_y = this.height/sch_h;
		this.scale = Math.pow(zoom_factor,Math.ceil(Math.log(Math.min(scale_x,scale_y))/Math.log(zoom_factor)));
		if (this.scale < zoom_min) this.scale = zoom_min;
		else if (this.scale > zoom_max) this.scale = zoom_max;

		// center the schematic
		this.origin_x = (this.bbox[2] + this.bbox[0])/2 - this.width/(2*this.scale);
		this.origin_y = (this.bbox[3] + this.bbox[1])/2 - this.height/(2*this.scale);
	    }

	    this.redraw_background();
	}

	Schematic.prototype.cut = function() {
	    // clear previous contents
	    sch_clipboard = [];

	    // look for selected components, move them to clipboard.
	    for (var i = this.components.length - 1; i >=0; --i) {
		var c = this.components[i];
		if (c.selected) {
		    c.remove();
		    sch_clipboard.push(c);
		}
	    }

	    // update diagram view
	    this.redraw();
	}

	Schematic.prototype.copy = function() {
	    // clear previous contents
	    sch_clipboard = [];

	    // look for selected components, copy them to clipboard.
	    for (var i = this.components.length - 1; i >=0; --i) {
		var c = this.components[i];
		if (c.selected)
		    sch_clipboard.push(c.clone(c.x,c.y));
	    }
	}

	Schematic.prototype.paste = function() {
	    // compute left,top of bounding box for origins of
	    // components in the clipboard
	    var left = undefined;
	    var top = undefined;
	    for (var i = sch_clipboard.length - 1; i >= 0; --i) {
		var c = sch_clipboard[i];
		left = left ? Math.min(left,c.x) : c.x;
		top = top ? Math.min(top,c.y) : c.y;
	    }

	    this.message('cursor '+this.cursor_x+','+this.cursor_y);

	    // clear current selections
	    this.unselect_all(-1);
	    this.redraw_background();  // so we see any components that got unselected

	    // make clones of components on the clipboard, positioning
	    // them relative to the cursor
	    for (var i = sch_clipboard.length - 1; i >= 0; --i) {
		var c = sch_clipboard[i];
		var new_c = c.clone(this.cursor_x + (c.x - left),this.cursor_y + (c.y - top));
		new_c.set_select(true);
		new_c.add(this);
	    }

	    // see what we've wrought
	    this.redraw();
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Netlist and Simulation interface
	//
	////////////////////////////////////////////////////////////////////////////////

	// load diagram from JSON representation
	Schematic.prototype.load_schematic = function(value,initial_value) {
	    // use default value if no schematic info in value
	    if (value == undefined || value.indexOf('[') == -1)
		value = initial_value;
	    
	    if (value && value.indexOf('[') != -1) {
		// convert string value into data structure
		var json = JSON.parse(value);

		// top level is a list of components
		for (var i = json.length - 1; i >= 0; --i) {
		    var c = json[i];
		    if (c[0] == 'view') {
			// special hack: view component lets us recreate view
			// ignore saved view parameters as they sometimes screw students
			//this.origin_x = c[1];
			//this.origin_y = c[2];
			//this.scale = c[3];
			//this.ac_npts = c[4];
			this.ac_fstart = c[5];
			this.ac_fstop = c[6];
			this.ac_source_name = c[7];
			this.tran_npts = c[8];
			this.tran_tstop = c[9];
			this.dc_max_iters = c[10];
		    } else if (c[0] == 'w') {
			// wire
			this.add_wire(c[1][0],c[1][1],c[1][2],c[1][3]);
		    } else if (c[0] == 'dc') {
			this.dc_results = c[1];
		    } else if (c[0] == 'transient') {
			this.transient_results = c[1];
		    } else if (c[0] == 'ac') {
			this.ac_results = c[1];
		    } else {
			// ordinary component
			//  c := [type, coords, properties, connections]
			var type = c[0];
			var coords = c[1];
			var properties = c[2];

			// make the part
			var part = new parts_map[type][0](coords[0],coords[1],coords[2]);

			// give it its properties
			for (var name in properties)
			    part.properties[name] = properties[name];

			// add component to the diagram
			part.add(this);
		    }
		}
	    }

	    // see what we've got!
	    this.redraw_background();
	}

	// label all the nodes in the circuit
	Schematic.prototype.label_connection_points = function() {
	    // start by clearing all the connection point labels
	    for (var i = this.components.length - 1; i >=0; --i)
		this.components[i].clear_labels();

	    // components are in charge of labeling their unlabeled connections.
	    // labels given to connection points will propagate to coincident connection
	    // points and across Wires.

	    // let special components like GND label their connection(s)
	    for (var i = this.components.length - 1; i >=0; --i)
		this.components[i].add_default_labels();

	    // now have components generate labels for unlabeled connections
	    this.next_label = 0;
	    for (var i = this.components.length - 1; i >=0; --i)
		this.components[i].label_connections();
	}

	// generate a new label
	Schematic.prototype.get_next_label = function() {
	    // generate next label in sequence
	    this.next_label += 1;
	    return this.next_label.toString();
	}

	// propagate label to coincident connection points
	Schematic.prototype.propagate_label = function(label,location) {
	    var cplist = this.connection_points[location];
	    for (var i = cplist.length - 1; i >= 0; --i)
		cplist[i].propagate_label(label);
	}

	// update the value field of our corresponding input field with JSON
	// representation of schematic
	Schematic.prototype.update_value = function() {
	    // label connection points
	    this.label_connection_points();

	    // build JSON data structure, convert to string value for
	    // input field
	    this.input.value = JSON.stringify(this.json_with_analyses());
	}

	// produce a JSON representation of the diagram
	Schematic.prototype.json = function() {
	    var json = [];

	    // output all the components/wires in the diagram
	    var n = this.components.length;
	    for (var i = 0; i < n; i++)
		json.push(this.components[i].json(i));

	    // capture the current view parameters
	    json.push(['view',this.origin_x,this.origin_y,this.scale,
		       this.ac_npts,this.ac_fstart,this.ac_fstop,
		       this.ac_source_name,this.tran_npts,this.tran_tstop,
		       this.dc_max_iters]);

	    return json;
	}

	// produce a JSON representation of the diagram
	Schematic.prototype.json_with_analyses = function() {
	    var json = this.json();

	    if (this.dc_results != undefined) json.push(['dc',this.dc_results]);
	    if (this.ac_results != undefined) json.push(['ac',this.ac_results]);
	    if (this.transient_results != undefined) json.push(['transient',this.transient_results]);

	    return json;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Simulation interface
	//
	////////////////////////////////////////////////////////////////////////////////

	Schematic.prototype.extract_circuit = function() {
	    // give all the circuit nodes a name, extract netlist
	    this.label_connection_points();
	    var netlist = this.json();

	    // since we've done the heavy lifting, update input field value
	    // so user can grab diagram if they want
	    this.input.value = JSON.stringify(netlist);

	    // create a circuit from the netlist
	    var ckt = new cktsim.Circuit();
	    if (ckt.load_netlist(netlist))
		return ckt;
	    else
		return null;
	}

	Schematic.prototype.dc_analysis = function() {
	    // remove any previous annotations
	    this.unselect_all(-1);
	    this.redraw_background();

	    var ckt = this.extract_circuit();
	    if (ckt === null) return;

	    // run the analysis
	    this.operating_point = ckt.dc();

	    if (this.operating_point != undefined) {
		// save a copy of the results for submission
		this.dc_results = {};
		for (var i in this.operating_point) this.dc_results[i] = this.operating_point[i];

		// display results on diagram
		this.redraw();
	    }
	}

	// return a list of [color,node_label,offset,type] for each probe in the diagram
	// type == 'voltage' or 'current'
	Schematic.prototype.find_probes = function() {
	    var result = [];
	    var result = [];
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var c = this.components[i];
		var info = c.probe_info();
		if (info != undefined) result.push(c.probe_info());
	    }
	    return result;
	}

	// use a dialog to get AC analysis parameters
	Schematic.prototype.setup_ac_analysis = function() {
	    this.unselect_all(-1);
	    this.redraw_background();

	    var npts_lbl = 'Number of points/decade';
	    var fstart_lbl = 'Starting frequency (Hz)';
	    var fstop_lbl = 'Ending frequency (Hz)';
	    var source_name_lbl = 'Name of V or I source for ac'
    
	    if (this.find_probes().length == 0) {
		alert("AC Analysis: there are no voltage probes in the diagram!");
		return;
	    }

	    var fields = new Array();
	    //fields[npts_lbl] = build_input('text',10,this.ac_npts);
	    fields[fstart_lbl] = build_input('text',10,this.ac_fstart);
	    fields[fstop_lbl] = build_input('text',10,this.ac_fstop);
	    fields[source_name_lbl] = build_input('text',10,this.ac_source_name);

	    var content = build_table(fields);
	    content.fields = fields;
	    content.sch = this;

	    this.dialog('AC Analysis',content,function(content) {
		    var sch = content.sch;

		    // retrieve parameters, remember for next time
		    //sch.ac_npts = content.fields[npts_lbl].value;
		    sch.ac_fstart = content.fields[fstart_lbl].value;
		    sch.ac_fstop = content.fields[fstop_lbl].value;
		    sch.ac_source_name = content.fields[source_name_lbl].value;

		    sch.ac_analysis(cktsim.parse_number(sch.ac_npts),
				    cktsim.parse_number(sch.ac_fstart),
				    cktsim.parse_number(sch.ac_fstop),
				    sch.ac_source_name);
		});
	}

	// perform ac analysis
	Schematic.prototype.ac_analysis = function(npts,fstart,fstop,ac_source_name) {
	    // run the analysis
	    var ckt = this.extract_circuit();
	    if (ckt === null) return;
	    var results = ckt.ac(npts,fstart,fstop,ac_source_name);

	    if (typeof results == 'string') 
		this.message(results);
	    else {
		var x_values = results['_frequencies_'];

		// x axis will be a log scale
		for (var i = x_values.length - 1; i >= 0; --i)
		    x_values[i] = Math.log(x_values[i])/Math.LN10;


		if (this.submit_analyses != undefined) {
		    var submit = this.submit_analyses['ac'];
		    if (submit != undefined) {
			// save a copy of the results for submission
			this.ac_results = {};

			// save requested values for each requested node
			for (var j = 0; j < submit.length; j++) {
			    var flist = submit[j];    // [node_name,f1,f2,...]
			    var node = flist[0];
			    var values = results[node];
			    var fvlist = [];
			    // for each requested freq, interpolate response value
			    for (var k = 1; k < flist.length; k++) {
				var f = flist[k];
				var v = interpolate(f,x_values,values);
				// convert to dB
				fvlist.push([f,v == undefined ? 'undefined' : 20.0 * Math.log(v)/Math.LN10]);
			    }
			    // save results as list of [f,response] paris
			    this.ac_results[node] = fvlist;
			}
		    }
		}

		// set up plot values for each node with a probe
		var y_values = [];  // list of [color, result_array]
		var z_values = [];  // list of [color, result_array]
		var probes = this.find_probes();

		var probe_maxv = [];
		var probe_color = [];

		// Check for probe with near zero transfer function and warn
		for (var i = probes.length - 1; i >= 0; --i) {
		    if (probes[i][3] != 'voltage') continue;
		    probe_color[i] = probes[i][0];
		    var label = probes[i][1];
		    var v = results[label];
		    probe_maxv[i] = array_max(v); // magnitudes always > 0
		}
		var all_max = array_max(probe_maxv);

		if (all_max < 1.0e-16) {
		    alert('Zero ac response, -infinity on DB scale.');
		} else {
		    for (var i = probes.length - 1; i >= 0; --i) {
			if (probes[i][3] != 'voltage') continue;
			if ((probe_maxv[i] / all_max) < 1.0e-10) {
			    alert('Near zero ac response, remove ' + probe_color[i] + ' probe');
			    return;
			}
		    }
		}

		for (var i = probes.length - 1; i >= 0; --i) {
		    if (probes[i][3] != 'voltage') continue;
		    var color = probes[i][0];
		    var label = probes[i][1];
		    var offset = cktsim.parse_number(probes[i][2]);

		    var v = results[label];
		    // convert values into dB relative to source amplitude
		    var v_max = 1;
		    for (var j = v.length - 1; j >= 0; --j)
			// convert each value to dB relative to max
			v[j] = 20.0 * Math.log(v[j]/v_max)/Math.LN10;
		    y_values.push([color,offset,v]);

		    var v = results[label+'_phase'];
		    z_values.push([color,0,v]);
		}

		// graph the result and display in a window
		var graph2 = this.graph(x_values,'log(Frequency in Hz)',z_values,'degrees');
		this.window('AC Analysis - Phase',graph2);
		var graph1 = this.graph(x_values,'log(Frequency in Hz)',y_values,'dB');
		this.window('AC Analysis - Magnitude',graph1,50);
	    }
	}

	Schematic.prototype.transient_analysis = function() {
	    this.unselect_all(-1);
	    this.redraw_background();

	    var npts_lbl = 'Minimum number of timepoints';
	    var tstop_lbl = 'Stop Time (seconds)';
    
	    var probes = this.find_probes();
	    if (probes.length == 0) {
		alert("Transient Analysis: there are no probes in the diagram!");
		return;
	    }

	    var fields = new Array();
	    //fields[npts_lbl] = build_input('text',10,this.tran_npts);
	    fields[tstop_lbl] = build_input('text',10,this.tran_tstop);

	    var content = build_table(fields);
	    content.fields = fields;
	    content.sch = this;

	    this.dialog('Transient Analysis',content,function(content) {
		    var sch = content.sch;
		    var ckt = sch.extract_circuit();
		    if (ckt === null) return;

		    // retrieve parameters, remember for next time
		    //sch.tran_npts = content.fields[npts_lbl].value;
		    sch.tran_tstop = content.fields[tstop_lbl].value;

		    // gather a list of nodes that are being probed.  These
		    // will be added to the list of nodes checked during the
		    // LTE calculations in transient analysis
		    var probe_list = sch.find_probes();
		    var probe_names = new Array(probe_list.length);
		    for (var i = probe_list.length - 1; i >= 0; --i)
			probe_names[i] = probe_list[i][1];

		    // run the analysis
		    var results = ckt.tran(ckt.parse_number(sch.tran_npts), 0,
					   ckt.parse_number(sch.tran_tstop), probe_names, false);

		    if (typeof results == 'string') 
			sch.message(results);
		    else {
			if (sch.submit_analyses != undefined) {
			    var submit = sch.submit_analyses['tran'];
			    if (submit != undefined) {
				// save a copy of the results for submission
				sch.transient_results = {};
				var times = results['_time_'];

				// save requested values for each requested node
				for (var j = 0; j < submit.length; j++) {
				    var tlist = submit[j];    // [node_name,t1,t2,...]
				    var node = tlist[0];
				    var values = results[node];
				    var tvlist = [];
				    // for each requested time, interpolate waveform value
				    for (var k = 1; k < tlist.length; k++) {
					var t = tlist[k];
					var v = interpolate(t,times,values);
					tvlist.push([t,v == undefined ? 'undefined' : v]);
				    }
				    // save results as list of [t,value] pairs
				    sch.transient_results[node] = tvlist;
				}
			    }
			}

			var x_values = results['_time_'];
			var x_legend = 'Time';

			// set up plot values for each node with a probe
			var v_values = [];  // voltage values: list of [color, result_array]
			var i_values = [];  // current values: list of [color, result_array]
			var probes = sch.find_probes();

			for (var i = probes.length - 1; i >= 0; --i) {
			    var color = probes[i][0];
			    var label = probes[i][1];
			    var offset = cktsim.parse_number(probes[i][2]);
			    var v = results[label];
			    if (v == undefined) {
				alert('The ' + color + ' probe is connected to node ' + '"' + label + '"' + ' which is not an actual circuit node');
			    } else if (probes[i][3] == 'voltage') {
				if (color == 'x-axis') {
				    x_values = v;
				    x_legend = 'Voltage';
				} else v_values.push([color,offset,v]);
			    } else {
				if (color == 'x-axis') {
				    x_values = v;
				    x_legend = 'Current';
				} else i_values.push([color,offset,v]);
			    }
			}

			// graph the result and display in a window
			var graph = sch.graph(x_values,x_legend,v_values,'Voltage',i_values,'Current');
			sch.window('Results of Transient Analysis',graph);
		    }
	    })
	}

	// t is the time at which we want a value
	// times is a list of timepoints from the simulation
	function interpolate(t,times,values) {
	    if (values == undefined) return undefined;

	    for (var i = 0; i < times.length; i++)
		if (t < times[i]) {
		    // t falls between times[i-1] and times[i]
		    var t1 = (i == 0) ? times[0] : times[i-1];
		    var t2 = times[i];

		    if (t2 == undefined) return undefined;

		    var v1 = (i == 0) ? values[0] : values[i-1];
		    var v2 = values[i];
		    var v = v1;
		    if (t != t1) v += (t - t1)*(v2 - v1)/(t2 - t1);
		    return v;
		}
	}

	// external interface for setting the property value of a named component
	Schematic.prototype.set_property = function(component_name,property,value) {
	    this.unselect_all(-1);

	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.properties['name'] == component_name) {
		    component.properties[property] = value.toString();
		    break;
		}
	    }

	    // update diagram
	    this.redraw_background();
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Drawing support -- deals with scaling and scrolling of diagrama
	//
	////////////////////////////////////////////////////////////////////////////////

	// here to redraw background image containing static portions of the schematic.
	// Also redraws dynamic portion.
	Schematic.prototype.redraw_background = function() {
	    var c = this.bg_image.getContext('2d');

	    c.lineCap = 'round';

	    // paint background color
	    c.fillStyle = element_style;
	    c.fillRect(0,0,this.width,this.height);

	    if (!this.diagram_only && this.show_grid) {
		// grid
		c.strokeStyle = grid_style;
		var first_x = this.origin_x;
		var last_x = first_x + this.width/this.scale;
		var first_y = this.origin_y;
		var last_y = first_y + this.height/this.scale;

		for (var i = this.grid*Math.ceil(first_x/this.grid); i < last_x; i += this.grid)
		    this.draw_line(c,i,first_y,i,last_y,0.1);

		for (var i = this.grid*Math.ceil(first_y/this.grid); i < last_y; i += this.grid)
		    this.draw_line(c,first_x,i,last_x,i,0.1);
	    }

	    // unselected components
	    var min_x = Infinity;  // compute bounding box for diagram
	    var max_x = -Infinity;
	    var min_y = Infinity;
	    var max_y = -Infinity;
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (!component.selected) {
		    component.draw(c);
		    min_x = Math.min(component.bbox[0],min_x);
		    max_x = Math.max(component.bbox[2],max_x);
		    min_y = Math.min(component.bbox[1],min_y);
		    max_y = Math.max(component.bbox[3],max_y);
		}
	    }
	    this.unsel_bbox = [min_x,min_y,max_x,max_y];

	    this.redraw();   // background changed, redraw on screen
	}

	// redraw what user sees = static image + dynamic parts
	Schematic.prototype.redraw = function() {
	    var c = this.canvas.getContext('2d');

	    // put static image in the background
	    c.drawImage(this.bg_image, 0, 0);

	    // selected components
	    var min_x = this.unsel_bbox[0];   // compute bounding box for diagram
	    var max_x = this.unsel_bbox[2];
	    var min_y = this.unsel_bbox[1];
	    var max_y = this.unsel_bbox[3];
	    var selections = false;
	    for (var i = this.components.length - 1; i >= 0; --i) {
		var component = this.components[i];
		if (component.selected) {
		    component.draw(c);
		    selections = true;
		    min_x = Math.min(component.bbox[0],min_x);
		    max_x = Math.max(component.bbox[2],max_x);
		    min_y = Math.min(component.bbox[1],min_y);
		    max_y = Math.max(component.bbox[3],max_y);
		}
	    }
	    if (min_x == Infinity) this.bbox = [0,0,0,0];
	    else this.bbox = [min_x,min_y,max_x,max_y];
	    this.enable_tool('cut',selections);
	    this.enable_tool('copy',selections);
	    this.enable_tool('paste',sch_clipboard.length > 0);

	    // connection points: draw one at each location
	    for (var location in this.connection_points) {
		var cplist = this.connection_points[location];
		cplist[0].draw(c,cplist.length);
	    }
    
	    // draw new wire
	    if (this.wire) {
		var r = this.wire;
		c.strokeStyle = selected_style;
		this.draw_line(c,r[0],r[1],r[2],r[3],1);
	    }

	    // draw selection rectangle
	    if (this.select_rect) {
		var r = this.select_rect;
		c.lineWidth = 1;
		c.strokeStyle = selected_style;
		c.beginPath();
		c.moveTo(r[0],r[1]);
		c.lineTo(r[0],r[3]);
		c.lineTo(r[2],r[3]);
		c.lineTo(r[2],r[1]);
		c.lineTo(r[0],r[1]);
		c.stroke();
	    }
    
	    // display operating point results
	    if (this.operating_point) {
		if (typeof this.operating_point == 'string')
		    this.message(this.operating_point);
		else {
		    // make a copy of the operating_point info so we can mess with it
		    var temp = new Array();
		    for (var i in this.operating_point) temp[i] = this.operating_point[i];

		    // run through connection points displaying (once) the voltage
		    // for each electrical node
		    for (var location in this.connection_points)
			(this.connection_points[location])[0].display_voltage(c,temp);

		    // let components display branch current info if available
		    for (var i = this.components.length - 1; i >= 0; --i)
			this.components[i].display_current(c,temp)
		}
	    }
	    
	    // add scrolling/zooming control
	    if (!this.diagram_only) {
		var r = this.sctl_r;
		var x = this.sctl_x;
		var y = this.sctl_y;

		// circle with border
		c.fillStyle = element_style;
		c.beginPath();
		c.arc(x,y,r,0,2*Math.PI);
		c.fill();

		c.strokeStyle = grid_style;
		c.lineWidth = 0.5;
		c.beginPath();
		c.arc(x,y,r,0,2*Math.PI);
		c.stroke();

		// direction markers for scroll
		c.lineWidth = 3;
		c.beginPath();

		c.moveTo(x + 4,y - r + 8);   // north
		c.lineTo(x,y - r + 4);
		c.lineTo(x - 4,y - r + 8);

		c.moveTo(x + r - 8,y + 4);   // east
		c.lineTo(x + r - 4,y);
		c.lineTo(x + r - 8,y - 4);

		c.moveTo(x + 4,y + r - 8);   // south
		c.lineTo(x,y + r - 4);
		c.lineTo(x - 4,y + r - 8);

		c.moveTo(x - r + 8,y + 4);   // west
		c.lineTo(x - r + 4,y);
		c.lineTo(x - r + 8,y - 4);

		c.stroke();

		// zoom control
		x = this.zctl_left;
		y = this.zctl_top;
		c.lineWidth = 0.5;
		c.fillStyle = element_style;    // background
		c.fillRect(x,y,16,48);
		c.strokeStyle = grid_style;     // border
		c.strokeRect(x,y,16,48);
		c.lineWidth = 1.0;
		c.beginPath();
		// zoom in label
		c.moveTo(x+4,y+8); c.lineTo(x+12,y+8); c.moveTo(x+8,y+4); c.lineTo(x+8,y+12);
		// zoom out label
		c.moveTo(x+4,y+24); c.lineTo(x+12,y+24);
		// surround label
		c.strokeRect(x+4,y+36,8,8);
		c.stroke();
	    }
	}

	// draws a cross cursor
	Schematic.prototype.cross_cursor = function(c,x,y) {
	    this.draw_line(c,x-this.grid,y,x+this.grid,y,1);
	    this.draw_line(c,x,y-this.grid,x,y+this.grid,1);
	}

	Schematic.prototype.moveTo = function(c,x,y) {
	    c.moveTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Schematic.prototype.lineTo = function(c,x,y) {
	    c.lineTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Schematic.prototype.draw_line = function(c,x1,y1,x2,y2,width) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.moveTo((x1 - this.origin_x) * this.scale,(y1 - this.origin_y) * this.scale);
	    c.lineTo((x2 - this.origin_x) * this.scale,(y2 - this.origin_y) * this.scale);
	    c.stroke();
	}

	Schematic.prototype.draw_arc = function(c,x,y,radius,start_radians,end_radians,anticlockwise,width,filled) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.arc((x - this.origin_x)*this.scale,(y - this.origin_y)*this.scale,radius*this.scale,
		  start_radians,end_radians,anticlockwise);
	    if (filled) c.fill();
	    else c.stroke();
	}

	Schematic.prototype.draw_text = function(c,text,x,y,size) {
	    c.font = size*this.scale+'pt sans-serif'
	    c.fillText(text,(x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	// add method to canvas to compute relative coords for event
	try {
		if (HTMLCanvasElement)
		 HTMLCanvasElement.prototype.relMouseCoords = function(event){
		    // run up the DOM tree to figure out coords for top,left of canvas
		    var totalOffsetX = 0;
		    var totalOffsetY = 0;
		    var currentElement = this;
		    do {
			totalOffsetX += currentElement.offsetLeft;
			totalOffsetY += currentElement.offsetTop;
		    }
		    while (currentElement = currentElement.offsetParent);
	
		    // now compute relative position of click within the canvas
		    this.mouse_x = event.pageX - totalOffsetX;
		    this.mouse_y = event.pageY - totalOffsetY;
	
		    this.page_x = event.pageX;
		    this.page_y = event.pageY;
		 }
	}
	catch (err) { // ignore
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Event handling
	//
	////////////////////////////////////////////////////////////////////////////////

	// process keystrokes, consuming those that are meaningful to us
	function schematic_key_down(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;
	    var code = event.keyCode;

	    // keep track of modifier key state
	    if (code == 16) sch.shiftKey = true;
	    else if (code == 17) sch.ctrlKey = true;
	    else if (code == 18) sch.altKey = true;
	    else if (code == 91) sch.cmdKey = true;

	    // backspace or delete: delete selected components
	    else if (code == 8 || code == 46) {
		// delete selected components
		for (var i = sch.components.length - 1; i >= 0; --i) {
		    var component = sch.components[i];
		    if (component.selected) component.remove();
		}
		sch.clean_up_wires();
		sch.redraw_background();
		event.preventDefault();
		return false;
	    }

	    // cmd/ctrl x: cut
	    else if ((sch.ctrlKey || sch.cmdKey) && code == 88) {
		sch.cut();
		event.preventDefault();
		return false;
	    }

	    // cmd/ctrl c: copy
	    else if ((sch.ctrlKey || sch.cmdKey) && code == 67) {
		sch.copy();
		event.preventDefault();
		return false;
	    }

	    // cmd/ctrl v: paste
	    else if ((sch.ctrlKey || sch.cmdKey) && code == 86) {
		sch.paste();
		event.preventDefault();
		return false;
	    }

	    // 'r': rotate component
	    else if (!sch.ctrlKey && !sch.altKey && !sch.cmdKey && code == 82) {
		// rotate
		for (var i = sch.components.length - 1; i >= 0; --i) {
		    var component = sch.components[i];
		    if (component.selected) {
			component.rotate(1);
			sch.check_wires(component);
		    }
		}
		sch.clean_up_wires();
		sch.redraw_background();
		event.preventDefault();
		return false;
	    }

	    else return true;

	    // consume keystroke
	    sch.redraw();
	    event.preventDefault();
	    return false;
	}

	function schematic_key_up(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;
	    var code = event.keyCode;

	    if (code == 16) sch.shiftKey = false;
	    else if (code == 17) sch.ctrlKey = false;
	    else if (code == 18) sch.altKey = false;
	    else if (code == 91) sch.cmdKey = false;
	}

	function schematic_mouse_enter(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // see if user has selected a new part
	    if (sch.new_part) {
		// grab incoming part, turn off selection of parts bin
		var part = sch.new_part;
		sch.new_part = undefined;
		part.select(false);

		// unselect everything else in the schematic, add part and select it
		sch.unselect_all(-1);
		sch.redraw_background();  // so we see any components that got unselected

		// make a clone of the component in the parts bin
		part = part.component.clone(sch.cursor_x,sch.cursor_y);
		part.add(sch);  // add it to schematic
		part.set_select(true);

		// and start dragging it
		sch.drag_begin();
	    }

	    sch.drawCursor = true;
	    sch.redraw();
	    sch.canvas.focus();  // capture key strokes
	    return false;
	}

	function schematic_mouse_leave(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;
	    sch.drawCursor = false;
	    sch.redraw();
	    return false;
	}

	function schematic_mouse_down(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // determine where event happened in schematic coordinates
	    sch.canvas.relMouseCoords(event);

	    var mx = sch.canvas.mouse_x;
	    var my = sch.canvas.mouse_y;
	    var sx = mx - sch.sctl_x;
	    var sy = my - sch.sctl_y;
	    var zx = mx - sch.zctl_left;
	    var zy = my - sch.zctl_top;
	    if (sx*sx + sy*sy <= sch.sctl_r*sch.sctl_r) {   // click in scrolling control
		// click on scrolling control, check which quadrant
		if (Math.abs(sy) > Math.abs(sx)) {   // N or S
		    var delta = this.height / 8;
		    if (sy > 0) delta = -delta;
		    var temp = sch.origin_y - delta;
		    if (temp > origin_min*sch.grid && temp < origin_max*sch.grid) sch.origin_y = temp;
		} else {			    // E or W
		    var delta = this.width / 8;
		    if (sx < 0) delta = -delta;
		    var temp = sch.origin_x + delta;
		    if (temp > origin_min*sch.grid && temp < origin_max*sch.grid) sch.origin_x = temp;
		}
	    } else if (zx >= 0 && zx < 16 && zy >= 0 && zy < 48) {   // click in zoom control
		if (zy < 16) sch.zoomin();
		else if (zy < 32) sch.zoomout();
		else sch.zoomall();
	    } else {
		var x = mx/sch.scale + sch.origin_x;
		var y = my/sch.scale + sch.origin_y;
		sch.cursor_x = Math.round(x/sch.grid) * sch.grid;
		sch.cursor_y = Math.round(y/sch.grid) * sch.grid;

		// is mouse over a connection point?  If so, start dragging a wire
		var cplist = sch.connection_points[sch.cursor_x + ',' + sch.cursor_y];
		if (cplist && !event.shiftKey) {
		    sch.unselect_all(-1);
		    sch.wire = [sch.cursor_x,sch.cursor_y,sch.cursor_x,sch.cursor_y];
		} else {
		    // give all components a shot at processing the selection event
		    var which = -1;
		    for (var i = sch.components.length - 1; i >= 0; --i)
			if (sch.components[i].select(x,y,event.shiftKey)) {
			    if (sch.components[i].selected) {
				sch.drag_begin();
				which = i;  // keep track of component we found
			    }
			    break;
			}
		    // did we just click on a previously selected component?
		    var reselect = which!=-1 && sch.components[which].was_previously_selected;

		    if (!event.shiftKey) {
			// if shift key isn't pressed and we didn't click on component
			// that was already selected, unselect everyone except component
			// we just clicked on
			if (!reselect) sch.unselect_all(which);

			// if there's nothing to drag, set up a selection rectangle
			if (!sch.dragging) sch.select_rect = [sch.canvas.mouse_x,sch.canvas.mouse_y,
							      sch.canvas.mouse_x,sch.canvas.mouse_y];
		    }
		}
	    }

	    sch.redraw_background();
	    return false;
	}

	function schematic_mouse_move(event) {
	    if (!event) event = window.event;
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    sch.canvas.relMouseCoords(event);
	    var x = sch.canvas.mouse_x/sch.scale + sch.origin_x;
	    var y = sch.canvas.mouse_y/sch.scale + sch.origin_y;
	    sch.cursor_x = Math.round(x/sch.grid) * sch.grid;
	    sch.cursor_y = Math.round(y/sch.grid) * sch.grid;

	    if (sch.wire) {
		// update new wire end point
		sch.wire[2] = sch.cursor_x;
		sch.wire[3] = sch.cursor_y;
	    } else if (sch.dragging) {
		// see how far we moved
		var dx = sch.cursor_x - sch.drag_x;
		var dy = sch.cursor_y - sch.drag_y;
		if (dx != 0 || dy != 0) {
		    // update position for next time
		    sch.drag_x = sch.cursor_x;
		    sch.drag_y = sch.cursor_y;

		    // give all components a shot at processing the event
		    for (var i = sch.components.length - 1; i >= 0; --i) {
			var component = sch.components[i];
			if (component.selected) component.move(dx,dy);
		    }
		}
	    } else if (sch.select_rect) {
		// update moving corner of selection rectangle
		sch.select_rect[2] = sch.canvas.mouse_x;
		sch.select_rect[3] = sch.canvas.mouse_y;
		//sch.message(sch.select_rect.toString());
	    }
    
	    // just redraw dynamic components
	    sch.redraw();
	    //sch.message(sch.canvas.page_x + ',' + sch.canvas.page_y + ';' + sch.canvas.mouse_x + ',' + sch.canvas.mouse_y + ';' + sch.cursor_x + ',' + sch.cursor_y);

	    return false;
	}

	function schematic_mouse_up(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // drawing a new wire
	    if (sch.wire) {
		var r = sch.wire;
		sch.wire = undefined;

		if (r[0]!=r[2] || r[1]!=r[3]) {
		    // insert wire component
		    sch.add_wire(r[0],r[1],r[2],r[3]);
		    sch.clean_up_wires();
		    sch.redraw_background();
		} else sch.redraw();
	    }

	    // dragging
	    if (sch.dragging) sch.drag_end();

	    // selection rectangle
	    if (sch.select_rect) {
		var r = sch.select_rect;

		// if select_rect is a point, we've already dealt with selection
		// in mouse_down handler
		if (r[0]!=r[2] || r[1]!=r[3]) {
		    // convert to schematic coordinates
		    var s = [r[0]/sch.scale + sch.origin_x, r[1]/sch.scale + sch.origin_y,
			     r[2]/sch.scale + sch.origin_x, r[3]/sch.scale + sch.origin_y];
		    canonicalize(s);
	    
		    if (!event.shiftKey) sch.unselect_all();

		    // select components that intersect selection rectangle
		    for (var i = sch.components.length - 1; i >= 0; --i)
			sch.components[i].select_rect(s,event.shiftKey);
		}

		sch.select_rect = undefined;
		sch.redraw_background();
	    }
	    return false;
	}

	function schematic_mouse_wheel(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    var delta = 0;
	    if (event.wheelDelta) delta = event.wheelDelta;
	    else if (event.detail) delta = -event.detail;

	    if (delta) {
		var nscale = (delta > 0) ? sch.scale*zoom_factor : sch.scale/zoom_factor;

		if (nscale > zoom_min && nscale < zoom_max) {
		    // zoom around current mouse position
		    sch.canvas.relMouseCoords(event);
		    var s = 1.0/sch.scale - 1.0/nscale;
		    sch.origin_x += sch.canvas.mouse_x*s;
		    sch.origin_y += sch.canvas.mouse_y*s;
		    sch.scale = nscale;
		    sch.redraw_background();
		}
	    }
	}

	function schematic_double_click(event) {
	    if (!event) event = window.event;
	    else event.preventDefault();
	    var sch = (window.event) ? event.srcElement.schematic : event.target.schematic;

	    // determine where event happened in schematic coordinates
	    sch.canvas.relMouseCoords(event);
	    var x = sch.canvas.mouse_x/sch.scale + sch.origin_x;
	    var y = sch.canvas.mouse_y/sch.scale + sch.origin_y;
	    sch.cursor_x = Math.round(x/sch.grid) * sch.grid;
	    sch.cursor_y = Math.round(y/sch.grid) * sch.grid;

	    // see if we double-clicked a component.  If so, edit it's properties
	    for (var i = sch.components.length - 1; i >= 0; --i)
		if (sch.components[i].edit_properties(x,y))
		    break;

	    return false;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Status message and dialogs
	//
	////////////////////////////////////////////////////////////////////////////////

	Schematic.prototype.message = function(message) {
	    this.status.nodeValue = message;
	}

	Schematic.prototype.append_message = function(message) {
	    this.status.nodeValue += ' / '+message;
	}
    
	// set up a dialog with specified title, content and two buttons at
	// the bottom: OK and Cancel.  If Cancel is clicked, dialog goes away
	// and we're done.  If OK is clicked, dialog goes away and the
	// callback function is called with the content as an argument (so
	// that the values of any fields can be captured).
	Schematic.prototype.dialog = function(title,content,callback) {
	    // create the div for the top level of the dialog, add to DOM
	    var dialog = document.createElement('div');
	    dialog.sch = this;
	    dialog.content = content;
	    dialog.callback = callback;

	    // look for property input fields in the content and give
	    // them a keypress listener that interprets ENTER as
	    // clicking OK.
	    var plist = content.getElementsByClassName('property');
	    for (var i = plist.length - 1; i >= 0; --i) {
		var field = plist[i];
		field.dialog = dialog;  // help event handler find us...
		field.addEventListener('keypress',dialog_check_for_ENTER,false);
	    }

	    // div to hold the content
	    var body = document.createElement('div');
	    content.style.marginBotton = '5px';
	    body.appendChild(content);
	    body.style.padding = '5px';
	    dialog.appendChild(body);

	    // OK button
	    var ok_button = document.createElement('span');
	    ok_button.appendChild(document.createTextNode('OK'));
	    ok_button.dialog = dialog;   // for the handler to use
	    ok_button.addEventListener('click',dialog_okay,false);
	    ok_button.style.display = 'inline';
	    ok_button.style.border = '1px solid';
	    ok_button.style.padding = '5px';
	    ok_button.style.margin = '10px';

	    // cancel button
	    var cancel_button = document.createElement('span');
	    cancel_button.appendChild(document.createTextNode('Cancel'));
	    cancel_button.dialog = dialog;   // for the handler to use
	    cancel_button.addEventListener('click',dialog_cancel,false);
	    cancel_button.style.display = 'inline';
	    cancel_button.style.border = '1px solid';
	    cancel_button.style.padding = '5px';
	    cancel_button.style.margin = '10px';

	    // div to hold the two buttons
	    var buttons = document.createElement('div');
	    buttons.style.textAlign = 'center';
	    buttons.appendChild(ok_button);
	    buttons.appendChild(cancel_button);
	    buttons.style.padding = '5px';
	    buttons.style.margin = '10px';
	    dialog.appendChild(buttons);

	    // put into an overlay window
	    this.window(title,dialog);
	}

	// callback when user click "Cancel" in a dialog
	function dialog_cancel(event) {
	    if (!event) event = window.event;
	    var dialog = (window.event) ? event.srcElement.dialog : event.target.dialog;

	    window_close(dialog.win);
	}

	// callback when user click "OK" in a dialog
	function dialog_okay(event) {
	    if (!event) event = window.event;
	    var dialog = (window.event) ? event.srcElement.dialog : event.target.dialog;

	    window_close(dialog.win);

	    // invoke the callback with the dialog contents as the argument
	    if (dialog.callback) dialog.callback(dialog.content);
	}

	// callback for keypress in input fields: if user typed ENTER, act
	// like they clicked OK button.
	function dialog_check_for_ENTER(event) {
	    var key = (window.event) ? window.event.keyCode : event.keyCode;
	    if (key == 13) dialog_okay(event);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Draggable, resizeable, closeable window
	//
	////////////////////////////////////////////////////////////////////////////////

	// build a 2-column HTML table from an associative array (keys as text in
	// column 1, values in column 2).
	function build_table(a) {
	    var tbl = document.createElement('table');

	    // build a row for each element in associative array
	    for (var i in a) {
		var label = document.createTextNode(i + ': ');
		var col1 = document.createElement('td');
		col1.appendChild(label);
		var col2 = document.createElement('td');
		col2.appendChild(a[i]);
		var row = document.createElement('tr');
		row.appendChild(col1);
		row.appendChild(col2);
		row.style.verticalAlign = 'center';
		tbl.appendChild(row);
	    }

	    return tbl;
	}

	// build an input field
	function build_input(type,size,value) {
	    var input = document.createElement('input');
	    input.type = type;
	    input.size = size;
	    input.className = 'property';  // make this easier to find later
	    if (value == undefined) input.value = '';
	    else input.value = value.toString();
	    return input;
	}

	// build a select widget using the strings found in the options array
	function build_select(options,selected) {
	    var select = document.createElement('select');
	    for (var i = 0; i < options.length; i++) {
		var option = document.createElement('option');
		option.text = options[i];
		select.add(option);
		if (options[i] == selected) select.selectedIndex = i;
	    }
	    return select;
	}

	Schematic.prototype.window = function(title,content,offset) {
	    // create the div for the top level of the window
	    var win = document.createElement('div');
	    win.sch = this;
	    win.content = content;
	    win.drag_x = undefined;
	    win.draw_y = undefined;

	    // div to hold the title
	    var head = document.createElement('div');
	    head.style.backgroundColor = 'black';
	    head.style.color = 'white';
	    head.style.textAlign = 'center';
	    head.style.padding = '5px';
	    head.appendChild(document.createTextNode(title));
	    head.win = win;
	    win.head = head;

	    var close_button = new Image();
	    close_button.src = close_icon;
	    close_button.style.cssFloat = 'right';
	    close_button.addEventListener('click',window_close_button,false);
	    close_button.win = win;
	    head.appendChild(close_button);

	    win.appendChild(head);

	    // capture mouse events in title bar
	    head.addEventListener('mousedown',window_mouse_down,false);

	    // div to hold the content
	    //var body = document.createElement('div');
	    //body.appendChild(content);
	    win.appendChild(content);
	    content.win = win;   // so content can contact us

	    // compute location relative to canvas
	    if (offset == undefined) offset = 0;
	    win.left = this.canvas.mouse_x + offset;
	    win.top = this.canvas.mouse_y + offset;

	    // add to DOM
	    win.style.background = 'white';
	    //win.style.zIndex = '1000';
	    win.style.position = 'absolute';
	    win.style.left = win.left + 'px';
	    win.style.top = win.top + 'px';
	    win.style.border = '2px solid';

	    this.canvas.parentNode.insertBefore(win,this.canvas);
	    bring_to_front(win,true);
	}

	// adjust zIndex of pop-up window so that it is in front
	function bring_to_front(win,insert) {
	    var wlist = win.sch.window_list;
	    var i = wlist.indexOf(win);

	    // remove from current position (if any) in window list
	    if (i != -1) wlist.splice(i,1);

	    // if requested, add to end of window list
	    if (insert) wlist.push(win);

	    // adjust all zIndex values
	    for (i = 0; i < wlist.length; i += 1)
		wlist[i].style.zIndex = 1000 + i;
	}

	// close the window
	function window_close(win) {
	    // remove the window from the top-level div of the schematic
	    win.parentNode.removeChild(win);

	    // remove from list of pop-up windows
	    bring_to_front(win,false);
	}

	function window_close_button(event) {
	    if (!event) event = window.event;
	    var src = (window.event) ? event.srcElement : event.target;
	    window_close(src.win);
	}

	// capture mouse events in title bar of window
	function window_mouse_down(event) {
	    if (!event) event = window.event;
	    var src = (window.event) ? event.srcElement : event.target;
	    var win = src.win;

	    bring_to_front(win,true);

	    // add handlers to document so we capture them no matter what
	    document.addEventListener('mousemove',window_mouse_move,false);
	    document.addEventListener('mouseup',window_mouse_up,false);
	    document.tracking_window = win;
    
	    // remember where mouse is so we can compute dx,dy during drag
	    win.drag_x = event.pageX;
	    win.drag_y = event.pageY;

	    return false;
	}

	function window_mouse_up(event) {
	    var win = document.tracking_window;
    
	    // show's over folks...
	    document.removeEventListener('mousemove',window_mouse_move,false);
	    document.removeEventListener('mouseup',window_mouse_up,false);
	    document.tracking_window = undefined;
	    win.drag_x = undefined;
	    win.drag_y = undefined;
	    return true;  // consume event
	}

	function window_mouse_move(event) {
	    var win = document.tracking_window;
    
	    if (win.drag_x) {
		var dx = event.pageX - win.drag_x;
		var dy = event.pageY - win.drag_y;

		// move the window
		win.left += dx;
		win.top += dy;
		win.style.left = win.left + 'px';
		win.style.top = win.top + 'px';
	
		// update reference point
		win.drag_x += dx;
		win.drag_y += dy;

		return true;  // consume event
	    }
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Toolbar
	//
	////////////////////////////////////////////////////////////////////////////////

	Schematic.prototype.add_tool = function(icon,tip,callback) {
	    var tool;
	    if (icon.search('data:image') != -1) {
		tool = document.createElement('img');
		tool.src = icon;
	    } else {
		tool = document.createElement('span');
		tool.style.font = 'small-caps small sans-serif';
		var label = document.createTextNode(icon);
		tool.appendChild(label);
	    }

	    // decorate tool
	    tool.style.borderWidth = '1px';
	    tool.style.borderStyle = 'solid';
	    tool.style.borderColor = background_style;
	    tool.style.padding = '2px';
	    tool.style.verticalAlign = 'middle';
	    tool.style.cursor = 'default';

	    // set up event processing
	    tool.addEventListener('mouseover',tool_enter,false);
	    tool.addEventListener('mouseout',tool_leave,false);
	    tool.addEventListener('click',tool_click,false);

	    // add to toolbar
	    tool.sch = this;
	    tool.tip = tip;
	    tool.callback = callback;
	    this.toolbar.push(tool);

	    tool.enabled = false;
	    tool.style.opacity = 0.2;

	    return tool;
	}

	Schematic.prototype.enable_tool = function(tname,which) {
	    var tool = this.tools[tname];

	    if (tool != undefined) {
		tool.style.opacity = which ? 1.0 : 0.2;
		tool.enabled = which;

		// if disabling tool, remove border and tip
		if (!which) {
		    tool.style.borderColor = background_style;
		    tool.sch.message('');
		}
	    }
	}

	// highlight tool button by turning on border, changing background
	function tool_enter(event) {
	    if (!event) event = window.event;
	    var tool = (window.event) ? event.srcElement : event.target;

	    if (tool.enabled) {
		tool.style.borderColor = normal_style;
		tool.sch.message(tool.tip);
		tool.opacity = 1.0;
	    }
	}

	// unhighlight tool button by turning off border, reverting to normal background
	function tool_leave(event) {
	    if (!event) event = window.event;
	    var tool = (window.event) ? event.srcElement : event.target;

	    if (tool.enabled) {
		tool.style.borderColor = background_style;
		tool.sch.message('');
	    }
	}

	// handle click on a tool
	function tool_click(event) {
	    if (!event) event = window.event;
	    var tool = (window.event) ? event.srcElement : event.target;

	    if (tool.enabled) {
		tool.sch.canvas.relMouseCoords(event);  // so we can position pop-up window correctly
		tool.callback.call(tool.sch);
	    }
	}

	help_icon = 'data:image/gif;base64,R0lGODlhEAAQAJEAAAAAAP///wAAAAAAACH5BAkAAAIAIf8LSUNDUkdCRzEwMTL/AAAHqGFwcGwCIAAAbW50clJHQiBYWVogB9kAAgAZAAsAGgALYWNzcEFQUEwAAAAAYXBwbAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZGVzYwAAAQgAAABvZHNjbQAAAXgAAAVsY3BydAAABuQAAAA4d3RwdAAABxwAAAAUclhZWgAABzAAAAAUZ1hZWgAAB0QAAAAUYlhZWgAAB1gAAAAUclRSQwAAB2wAAAAOY2hhZAAAB3wAAAAsYlRSQwAAB2wAAAAOZ1RS/0MAAAdsAAAADmRlc2MAAAAAAAAAFEdlbmVyaWMgUkdCIFByb2ZpbGUAAAAAAAAAAAAAABRHZW5lcmljIFJHQiBQcm9maWxlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtbHVjAAAAAAAAAB4AAAAMc2tTSwAAACgAAAF4aHJIUgAAACgAAAGgY2FFUwAAACQAAAHIcHRCUgAAACYAAAHsdWtVQQAAACoAAAISZnJGVQAAACgAAAI8emhUVwAAABYAAAJkaXRJVAAAACgAAAJ6bmJOTwAAACYAAAKia29LUgAAABYAAP8CyGNzQ1oAAAAiAAAC3mhlSUwAAAAeAAADAGRlREUAAAAsAAADHmh1SFUAAAAoAAADSnN2U0UAAAAmAAAConpoQ04AAAAWAAADcmphSlAAAAAaAAADiHJvUk8AAAAkAAADomVsR1IAAAAiAAADxnB0UE8AAAAmAAAD6G5sTkwAAAAoAAAEDmVzRVMAAAAmAAAD6HRoVEgAAAAkAAAENnRyVFIAAAAiAAAEWmZpRkkAAAAoAAAEfHBsUEwAAAAsAAAEpHJ1UlUAAAAiAAAE0GFyRUcAAAAmAAAE8mVuVVMAAAAmAAAFGGRhREsAAAAuAAAFPgBWAWEAZQBvAGIAZQD/YwBuAP0AIABSAEcAQgAgAHAAcgBvAGYAaQBsAEcAZQBuAGUAcgBpAQ0AawBpACAAUgBHAEIAIABwAHIAbwBmAGkAbABQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6AByAGkAYwBQAGUAcgBmAGkAbAAgAFIARwBCACAARwBlAG4A6QByAGkAYwBvBBcEMAQzBDAEOwRMBD0EOAQ5ACAEPwRABD4ERAQwBDkEOwAgAFIARwBCAFAAcgBvAGYAaQBsACAAZwDpAG4A6QByAGkAcQB1AGUAIABSAFYAQpAadSgAIABSAEcAQgAggnJfaWPPj/AAUAByAG8AZgBp/wBsAG8AIABSAEcAQgAgAGcAZQBuAGUAcgBpAGMAbwBHAGUAbgBlAHIAaQBzAGsAIABSAEcAQgAtAHAAcgBvAGYAaQBsx3y8GAAgAFIARwBCACDVBLhc0wzHfABPAGIAZQBjAG4A/QAgAFIARwBCACAAcAByAG8AZgBpAGwF5AXoBdUF5AXZBdwAIABSAEcAQgAgBdsF3AXcBdkAQQBsAGwAZwBlAG0AZQBpAG4AZQBzACAAUgBHAEIALQBQAHIAbwBmAGkAbADBAGwAdABhAGwA4QBuAG8AcwAgAFIARwBCACAAcAByAG8AZgBpAGxmbpAaACAAUgBHAEIAIGPPj//wZYdO9k4AgiwAIABSAEcAQgAgMNcw7TDVMKEwpDDrAFAAcgBvAGYAaQBsACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjA5MDtQO9A7kDugPMACADwAPBA78DxgOvA7sAIABSAEcAQgBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6QByAGkAYwBvAEEAbABnAGUAbQBlAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGUAbA5CDhsOIw5EDh8OJQ5MACAAUgBHAEIAIA4XDjEOSA4nDkQOGwBHAGUAbgBlAGwAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGkAWQBsAGX/AGkAbgBlAG4AIABSAEcAQgAtAHAAcgBvAGYAaQBpAGwAaQBVAG4AaQB3AGUAcgBzAGEAbABuAHkAIABwAHIAbwBmAGkAbAAgAFIARwBCBB4EMQRJBDgEOQAgBD8EQAQ+BEQEOAQ7BEwAIABSAEcAQgZFBkQGQQAgBioGOQYxBkoGQQAgAFIARwBCACAGJwZEBjkGJwZFAEcAZQBuAGUAcgBpAGMAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGUARwBlAG4AZQByAGUAbAAgAFIARwBCAC0AYgBlAHMAawByAGkAdgBlAGwAcwBldGV4dAAAAABDb3B5cmlnaHQgMjAwrzcgQXBwbGUgSW5jLiwgYWxsIHJpZ2h0cyByZXNlcnZlZC4AWFlaIAAAAAAAAPNSAAEAAAABFs9YWVogAAAAAAAAdE0AAD3uAAAD0FhZWiAAAAAAAABadQAArHMAABc0WFlaIAAAAAAAACgaAAAVnwAAuDZjdXJ2AAAAAAAAAAEBzQAAc2YzMgAAAAAAAQxCAAAF3v//8yYAAAeSAAD9kf//+6L///2jAAAD3AAAwGwALAAAAAAQABAAAAIglI+pwK3XInhSLoZc0oa/7lHRB4bXRJZoaqau+o6ujBQAOw==';

	cut_icon = 'data:image/gif;base64,R0lGODlhEAAQALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAAcALAAAAAAQABAAAAQu8MhJqz1g5qs7lxv2gRkQfuWomarXEgDRHjJhf3YtyRav0xcfcFgR0nhB5OwTAQA7';

	copy_icon = 'data:image/gif;base64,R0lGODlhEAAQALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAAcALAAAAAAQABAAAAQ+8MhJ6wE4Wwqef9gmdV8HiKZJrCz3ecS7TikWfzExvk+M9a0a4MbTkXCgTMeoHPJgG5+yF31SLazsTMTtViIAOw==';

	paste_icon = 'data:image/gif;base64,R0lGODlhEAAQALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAAcALAAAAAAQABAAAARL8MhJqwUYWJnxWp3GDcgAgCdQIqLKXmVLhhnyHiqpr7rME8AgocVDEB5IJHD0SyofBFzxGIQGAbvB0ZkcTq1CKK6z5YorwnR0w44AADs=';

	close_icon = 'data:image/gif;base64,R0lGODlhEAAQAMQAAGtra/f3/62tre/v9+bm787O1pycnHNzc6WlpcXFxd7e3tbW1nt7e7W1te/v74SEhMXFzmNjY+bm5v///87OzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAALAAAAAAQABAAAAVt4DRMZGmSwRQQBUS9MAwRIyQ5Uq7neEFSDtxOF4T8cobIQaE4RAQ5yjHHiCCSD510QtFGvoCFdppDfBu7bYzy+D7WP5ggAgA8Y3FKwi5IAhIweW1vbBGEWy5rilsFi2tGAwSJixAFBCkpJ5ojIQA7';

	grid_icon = 'data:image/gif;base64,R0lGODlhEAAQAMQAAAAAAP///zAwYT09bpGRqZ6et5iYsKWlvbi40MzM5cXF3czM5OHh5tTU2fDw84uMom49DbWKcfLy8g0NDcDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABQALAAAAAAQABAAAAUtICWOZGmeKDCqIlu68AvMdO2ueHvGuslTN6Bt6MsBd8Zg77hsDW3FpRJFrYpCADs=';

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Graphing
	//
	///////////////////////////////////////////////////////////////////////////////

	// add dashed lines!
	// from http://davidowens.wordpress.com/2010/09/07/html-5-canvas-and-dashed-lines/
	try {
		if (CanvasRenderingContext2D)
			CanvasRenderingContext2D.prototype.dashedLineTo = function(fromX, fromY, toX, toY, pattern) {
			    // Our growth rate for our line can be one of the following:
			    //   (+,+), (+,-), (-,+), (-,-)
			    // Because of this, our algorithm needs to understand if the x-coord and
			    // y-coord should be getting smaller or larger and properly cap the values
			    // based on (x,y).
			    var lt = function (a, b) { return a <= b; };
			    var gt = function (a, b) { return a >= b; };
			    var capmin = function (a, b) { return Math.min(a, b); };
			    var capmax = function (a, b) { return Math.max(a, b); };
		
			    var checkX = { thereYet: gt, cap: capmin };
			    var checkY = { thereYet: gt, cap: capmin };
		
			    if (fromY - toY > 0) {
				checkY.thereYet = lt;
				checkY.cap = capmax;
			    }
			    if (fromX - toX > 0) {
				checkX.thereYet = lt;
				checkX.cap = capmax;
			    }
		
			    this.moveTo(fromX, fromY);
			    var offsetX = fromX;
			    var offsetY = fromY;
			    var idx = 0, dash = true;
			    while (!(checkX.thereYet(offsetX, toX) && checkY.thereYet(offsetY, toY))) {
				var ang = Math.atan2(toY - fromY, toX - fromX);
				var len = pattern[idx];
		
				offsetX = checkX.cap(toX, offsetX + (Math.cos(ang) * len));
				offsetY = checkY.cap(toY, offsetY + (Math.sin(ang) * len));
		
				if (dash) this.lineTo(offsetX, offsetY);
				else this.moveTo(offsetX, offsetY);
		
				idx = (idx + 1) % pattern.length;
				dash = !dash;
			    }
			};
	}
	catch (err) { //noop
	}
	// given a range of values, return a new range [vmin',vmax'] where the limits
	// have been chosen "nicely".  Taken from matplotlib.ticker.LinearLocator
	function view_limits(vmin,vmax) {
	    // deal with degenerate case...
	    if (vmin == vmax) {
		if (vmin == 0) { vmin = -0.5; vmax = 0.5; }
		else {
		    vmin = vmin > 0 ? 0.9*vmin : 1.1*vmin;
		    vmax = vmax > 0 ? 1.1*vmax : 0.9*vmax;
		}
	    }

	    var log_range = Math.log(vmax - vmin)/Math.LN10;
	    var exponent = Math.floor(log_range);
	    //if (log_range - exponent < 0.5) exponent -= 1;
	    var scale = Math.pow(10,-exponent);
	    vmin = Math.floor(scale*vmin)/scale;
	    vmax = Math.ceil(scale*vmax)/scale;

	    return [vmin,vmax,1.0/scale];
	}

	function engineering_notation(n,nplaces,trim) {
	    if (n == 0) return '0';
	    if (n == undefined) return 'undefined';
	    if (trim == undefined) trim = true;

	    var sign = n < 0 ? -1 : 1;
	    var log10 = Math.log(sign*n)/Math.LN10;
	    var exp = Math.floor(log10/3);   // powers of 1000
	    var mantissa = sign*Math.pow(10,log10 - 3*exp);

	    // keep specified number of places following decimal point
	    var mstring = (mantissa + sign*0.5*Math.pow(10,-nplaces)).toString();
	    var mlen = mstring.length;
	    var endindex = mstring.indexOf('.');
	    if (endindex != -1) {
		if (nplaces > 0) {
		    endindex += nplaces + 1;
		    if (endindex > mlen) endindex = mlen;
		    if (trim) {
			while (mstring.charAt(endindex-1) == '0') endindex -= 1;
			if (mstring.charAt(endindex-1) == '.') endindex -= 1;
		    }
		}
		if (endindex < mlen)
		    mstring = mstring.substring(0,endindex);
	    }

	    switch(exp) {
	    case -5:	return mstring+"f";
	    case -4:	return mstring+"p";
	    case -3:	return mstring+"n";
	    case -2:	return mstring+"u";
	    case -1:	return mstring+"m";
	    case 0:	return mstring;
	    case 1:	return mstring+"K";
	    case 2:	return mstring+"M";
	    case 3:	return mstring+"G";
	    }

	    // don't have a good suffix, so just print the number
	    return n.toString();
	}

	var grid_pattern = [1,2];
	var cursor_pattern = [5,5];

	// x_values is an array of x coordinates for each of the plots
	// y_values is an array of [color, value_array], one entry for each plot on left vertical axis
	// z_values is an array of [color, value_array], one entry for each plot on right vertical axis
	Schematic.prototype.graph = function(x_values,x_legend,y_values,y_legend,z_values,z_legend) {
	    var pwidth = 400;	// dimensions of actual plot
	    var pheight = 300;	// dimensions of actual plot
	    var left_margin = (y_values != undefined && y_values.length > 0) ? 55 : 25;
	    var top_margin = 25;
	    var right_margin = (z_values != undefined && z_values.length > 0) ? 55 : 25;
	    var bottom_margin = 45;
	    var tick_length = 5;

	    var w = pwidth + left_margin + right_margin;
	    var h = pheight + top_margin + bottom_margin;

	    var canvas = document.createElement('canvas');
	    canvas.width = w;
	    canvas.height = h;

	    // the graph itself will be drawn here and this image will be copied
	    // onto canvas, where it can be overlayed with mouse cursors, etc.
	    var bg_image = document.createElement('canvas');
	    bg_image.width = w;
	    bg_image.height = h;
	    canvas.bg_image = bg_image;	// so we can find it during event handling

	    // start by painting an opaque background
	    var c = bg_image.getContext('2d');
	    c.fillStyle = background_style;
	    c.fillRect(0,0,w,h);
	    c.fillStyle = element_style;
	    c.fillRect(left_margin,top_margin,pwidth,pheight);

	    // figure out scaling for plots
	    var x_min = array_min(x_values);
	    var x_max = array_max(x_values);
	    var x_limits = view_limits(x_min,x_max);
	    x_min = x_limits[0];
	    x_max = x_limits[1];
	    var x_scale = pwidth/(x_max - x_min);

	    function plot_x(x) {
		return (x - x_min)*x_scale + left_margin;
	    }

	    // draw x grid
	    c.strokeStyle = grid_style;
	    c.lineWidth = 1;
	    c.fillStyle = normal_style;
	    c.font = '10pt sans-serif';
	    c.textAlign = 'center';
	    c.textBaseline = 'top';
	    var end = top_margin + pheight;
	    for (var x = x_min; x <= x_max; x += x_limits[2]) {
		var temp = plot_x(x) + 0.5;  // keep lines crisp!

		// grid line
		c.beginPath();
		if (x == x_min) {
		    c.moveTo(temp,top_margin);
		    c.lineTo(temp,end);
		} else 
		    c.dashedLineTo(temp,top_margin,temp,end,grid_pattern);
		c.stroke();

		// tick mark
		c.beginPath();
		c.moveTo(temp,end);
		c.lineTo(temp,end + tick_length);
		c.stroke();
		c.fillText(engineering_notation(x,2),temp,end + tick_length);
	    }

	    if (y_values != undefined && y_values.length > 0) {
		var y_min = Infinity;
		var y_max = -Infinity;
		var plot;
		for (plot = y_values.length - 1; plot >= 0; --plot) {
		    var values = y_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = y_values[plot][1];
		    var temp = array_min(values) + offset;
		    if (temp < y_min) y_min = temp;
		    temp = array_max(values) + offset;
		    if (temp > y_max) y_max = temp;
		}
		var y_limits = view_limits(y_min,y_max);
		y_min = y_limits[0];
		y_max = y_limits[1];
		var y_scale = pheight/(y_max - y_min);

		function plot_y(y) {
		    return (y_max - y)*y_scale + top_margin;
		}

		// draw y grid
		c.textAlign = 'right';
		c.textBaseline = 'middle';
		for (var y = y_min; y <= y_max; y += y_limits[2]) {
		    if (Math.abs(y/y_max) < 0.001) y = 0.0; // Just 3 digits
		    var temp = plot_y(y) + 0.5;  // keep lines crisp!

		    // grid line
		    c.beginPath();
		    if (y == y_min) {
			c.moveTo(left_margin,temp);
			c.lineTo(left_margin + pwidth,temp);
		    } else 
			c.dashedLineTo(left_margin,temp,left_margin + pwidth,temp,grid_pattern);
		    c.stroke();

		    // tick mark
		    c.beginPath();
		    c.moveTo(left_margin - tick_length,temp);
		    c.lineTo(left_margin,temp);
		    c.stroke();
		    c.fillText(engineering_notation(y,2),left_margin - tick_length -2,temp);
		}

		// now draw each plot
		var x,y;
		var nx,ny;
		c.lineWidth = 3;
		c.lineCap = 'round';
		for (plot = y_values.length - 1; plot >= 0; --plot) {
		    var color = probe_colors_rgb[y_values[plot][0]];
		    if (color == undefined) continue;  // no plot color (== x-axis)
		    c.strokeStyle = color;
		    var values = y_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = y_values[plot][1];

		    x = plot_x(x_values[0]);
		    y = plot_y(values[0] + offset);
		    c.beginPath();
		    c.moveTo(x,y);
		    for (var i = 1; i < x_values.length; i++) {
			nx = plot_x(x_values[i]);
			ny = plot_y(values[i] + offset);
			c.lineTo(nx,ny);
			x = nx;
			y = ny;
			if (i % 100 == 99) {
			    // too many lineTo's cause canvas to break
			    c.stroke();
			    c.beginPath();
			    c.moveTo(x,y);
			}
		    }
		    c.stroke();
		}
	    }

	    if (z_values != undefined && z_values.length > 0) {
		var z_min = Infinity;
		var z_max = -Infinity;
		for (plot = z_values.length - 1; plot >= 0; --plot) {
		    var values = z_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = z_values[plot][1];
		    var temp = array_min(values) + offset;
		    if (temp < z_min) z_min = temp;
		    temp = array_max(values) + offset;
		    if (temp > z_max) z_max = temp;
		}
		var z_limits = view_limits(z_min,z_max);
		z_min = z_limits[0];
		z_max = z_limits[1];
		var z_scale = pheight/(z_max - z_min);

		function plot_z(z) {
		    return (z_max - z)*z_scale + top_margin;
		}

		// draw z ticks
		c.textAlign = 'left';
		c.textBaseline = 'middle';
		c.lineWidth = 1;
		c.strokeStyle = normal_style;
		var tick_length_half = Math.floor(tick_length/2);
		var tick_delta = tick_length - tick_length_half;
		for (var z = z_min; z <= z_max; z += z_limits[2]) {
		    if (Math.abs(z/z_max) < 0.001) z = 0.0; // Just 3 digits
		    var temp = plot_z(z) + 0.5;  // keep lines crisp!

		    // tick mark
		    c.beginPath();
		    c.moveTo(left_margin + pwidth - tick_length_half,temp);
		    c.lineTo(left_margin + pwidth + tick_delta,temp);
		    c.stroke();
		    c.fillText(engineering_notation(z,2),left_margin + pwidth + tick_length + 2,temp);
		}

		var z;
		var nz;
		c.lineWidth = 3;
		for (plot = z_values.length - 1; plot >= 0; --plot) {
		    var color = probe_colors_rgb[z_values[plot][0]];
		    if (color == undefined) continue;  // no plot color (== x-axis)
		    c.strokeStyle = color;
		    var values = z_values[plot][2];
		    if (values == undefined) continue;  // no data points
		    var offset = z_values[plot][1];
		    
		    x = plot_x(x_values[0]);
		    z = plot_z(values[0] + offset);
		    c.beginPath();
		    c.moveTo(x,z);
		    for (var i = 1; i < x_values.length; i++) {
			nx = plot_x(x_values[i]);
			nz = plot_z(values[i] + offset);
			c.lineTo(nx,nz);
			x = nx;
			z = nz;
			if (i % 100 == 99) {
			    // too many lineTo's cause canvas to break
			    c.stroke();
			    c.beginPath();
			    c.moveTo(x,z);
			}
		    }
		    c.stroke();
		}
	    }

	    // draw legends
	    c.font = '12pt sans-serif';
	    c.textAlign = 'center';
	    c.textBaseline = 'bottom';
	    c.fillText(x_legend,left_margin + pwidth/2,h - 5);

	    if (y_values != undefined && y_values.length > 0) {
		c.textBaseline = 'top';
		c.save();
		c.translate(5 ,top_margin + pheight/2);
		c.rotate(-Math.PI/2);
		c.fillText(y_legend,0,0);
		c.restore();
	    }

	    if (z_values != undefined && z_values.length > 0) {
		c.textBaseline = 'bottom';
		c.save();
		c.translate(w-5 ,top_margin + pheight/2);
		c.rotate(-Math.PI/2);
		c.fillText(z_legend,0,0);
		c.restore();
	    }

	    // save info need for interactions with the graph
	    canvas.x_values = x_values;
	    canvas.y_values = y_values;
	    canvas.z_values = z_values;
	    canvas.x_legend = x_legend;
	    canvas.y_legend = y_legend;
	    canvas.z_legend = y_legend;
	    canvas.x_min = x_min;
	    canvas.x_scale = x_scale;
	    canvas.y_min = y_min;
	    canvas.y_scale = y_scale;
	    canvas.z_min = z_min;
	    canvas.z_scale = z_scale;
	    canvas.left_margin = left_margin;
	    canvas.top_margin = top_margin;
	    canvas.pwidth = pwidth;
	    canvas.pheight = pheight;
	    canvas.tick_length = tick_length;

	    canvas.cursor1_x = undefined;
	    canvas.cursor2_x = undefined;
	    canvas.sch = this;

	    // do something useful when user mouses over graph
	    canvas.addEventListener('mousemove',graph_mouse_move,false);

	    // return our masterpiece
	    redraw_plot(canvas);
	    return canvas;
	}

	function array_max(a) {
	    max = -Infinity;
	    for (var i = a.length - 1; i >= 0; --i)
		if (a[i] > max) max = a[i];
	    return max;
	}

	function array_min(a) {
	    min = Infinity;
	    for (var i = a.length - 1; i >= 0; --i)
		if (a[i] < min) min = a[i];
	    return min;
	}

	function plot_cursor(c,graph,cursor_x,left_margin) {
	    // draw dashed vertical marker that follows mouse
	    var x = graph.left_margin + cursor_x;
	    var end_y = graph.top_margin + graph.pheight + graph.tick_length;
	    c.strokeStyle = grid_style;
	    c.lineWidth = 1;
	    c.beginPath();
	    c.dashedLineTo(x,graph.top_margin,x,end_y,cursor_pattern);
	    c.stroke();

	    // add x label at bottom of marker
	    var graph_x = cursor_x/graph.x_scale + graph.x_min;
	    c.font = '10pt sans-serif';
	    c.textAlign = 'center';
	    c.textBaseline = 'top';
	    c.fillStyle = background_style;
	    c.fillText('\u2588\u2588\u2588\u2588\u2588',x,end_y);
	    c.fillStyle = normal_style;
	    c.fillText(engineering_notation(graph_x,3,false),x,end_y);

	    // compute which points marker is between
	    var x_values = graph.x_values;
	    var len = x_values.length;
	    var index = 0;
	    while (index < len && graph_x >= x_values[index]) index += 1;
	    var x1 = (index == 0) ? x_values[0] : x_values[index-1];
	    var x2 = x_values[index];

	    if (x2 != undefined) {
		// for each plot, interpolate and output value at intersection with marker
		c.textAlign = 'left';
		var tx = graph.left_margin + left_margin;
		var ty = graph.top_margin;
		if (graph.y_values != undefined) {
		    for (var plot = 0; plot < graph.y_values.length; plot++) {
			var values = graph.y_values[plot][2];
			var color = probe_colors_rgb[graph.y_values[plot][0]];
			if (values == undefined || color == undefined) continue;  // no data points or x-axis
		    
			// interpolate signal value at graph_x using values[index-1] and values[index]
			var y1 = (index == 0) ? values[0] : values[index-1];
			var y2 = values[index];
			var y = y1;
			if (graph_x != x1) y += (graph_x - x1)*(y2 - y1)/(x2 - x1);
		    
			// annotate plot with value of signal at marker
			c.fillStyle = element_style;
			c.fillText('\u2588\u2588\u2588\u2588\u2588',tx-3,ty);
			c.fillStyle = color;
			c.fillText(engineering_notation(y,3,false),tx,ty);
			ty += 14;
		    }
		}

		c.textAlign = 'right';
		if (graph.z_values != undefined) {
		    var tx = graph.left_margin + graph.pwidth - left_margin;
		    var ty = graph.top_margin;
		    for (var plot = 0; plot < graph.z_values.length; plot++) {
			var values = graph.z_values[plot][2];
			var color = probe_colors_rgb[graph.z_values[plot][0]];
			if (values == undefined || color == undefined) continue;  // no data points or x-axis
		    
			// interpolate signal value at graph_x using values[index-1] and values[index]
			var z1 = (index == 0) ? values[0]: values[index-1];
			var z2 = values[index];
			var z = z1;
			if (graph_x != x1) z += (graph_x - x1)*(z2 - z1)/(x2 - x1);
		    
			// annotate plot with value of signal at marker
			c.fillStyle = element_style;
			c.fillText('\u2588\u2588\u2588\u2588\u2588',tx+3,ty);
			c.fillStyle = color;
			c.fillText(engineering_notation(z,3,false),tx,ty);
			ty += 14;
		    }
		}
	    }
	}

	function redraw_plot(graph) {
	    var c = graph.getContext('2d');
	    c.drawImage(graph.bg_image,0,0);

	    if (graph.cursor1_x != undefined) plot_cursor(c,graph,graph.cursor1_x,4);
	    if (graph.cursor2_x != undefined) plot_cursor(c,graph,graph.cursor2_x,30);

	    /*
	    if (graph.cursor1_x != undefined) {
		// draw dashed vertical marker that follows mouse
		var x = graph.left_margin + graph.cursor1_x;
		var end_y = graph.top_margin + graph.pheight + graph.tick_length;
		c.strokeStyle = grid_style;
		c.lineWidth = 1;
		c.beginPath();
		c.dashedLineTo(x,graph.top_margin,x,end_y,cursor_pattern);
		c.stroke();

		// add x label at bottom of marker
		var graph_x = graph.cursor1_x/graph.x_scale + graph.x_min;
		c.font = '10pt sans-serif';
		c.textAlign = 'center';
		c.textBaseline = 'top';
		c.fillStyle = background_style;
		c.fillText('\u2588\u2588\u2588\u2588\u2588',x,end_y);
		c.fillStyle = normal_style;
		c.fillText(engineering_notation(graph_x,3,false),x,end_y);

		// compute which points marker is between
		var x_values = graph.x_values;
		var len = x_values.length;
		var index = 0;
		while (index < len && graph_x >= x_values[index]) index += 1;
		var x1 = (index == 0) ? x_values[0] : x_values[index-1];
		var x2 = x_values[index];

		if (x2 != undefined) {
		    // for each plot, interpolate and output value at intersection with marker
		    c.textAlign = 'left';
		    var tx = graph.left_margin + 4;
		    var ty = graph.top_margin;
		    for (var plot = 0; plot < graph.y_values.length; plot++) {
			var values = graph.y_values[plot][1];

			// interpolate signal value at graph_x using values[index-1] and values[index]
			var y1 = (index == 0) ? values[0] : values[index-1];
			var y2 = values[index];
			var y = y1;
			if (graph_x != x1) y += (graph_x - x1)*(y2 - y1)/(x2 - x1);

			// annotate plot with value of signal at marker
			c.fillStyle = element_style;
			c.fillText('\u2588\u2588\u2588\u2588\u2588',tx-3,ty);
			c.fillStyle = probe_colors_rgb[graph.y_values[plot][0]];
			c.fillText(engineering_notation(y,3,false),tx,ty);
			ty += 14;
		    }
		}
	    }
	    */
	}

	function graph_mouse_move(event) {
	    if (!event) event = window.event;
	    var g = (window.event) ? event.srcElement : event.target;

	    g.relMouseCoords(event);
	    // not sure yet where the 3,-3 offset correction comes from (borders? padding?)
	    var gx = g.mouse_x - g.left_margin - 3;
	    var gy = g.pheight - (g.mouse_y - g.top_margin) + 3;
	    if (gx >= 0 && gx <= g.pwidth && gy >=0 && gy <= g.pheight) {
		//g.sch.message('button: '+event.button+', which: '+event.which);
		g.cursor1_x = gx;
	    } else {
		g.cursor1_x = undefined;
		g.cursor2_x = undefined;
	    }

	    redraw_plot(g);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Parts bin
	//
	////////////////////////////////////////////////////////////////////////////////

	// one instance will be created for each part in the parts bin
	function Part(sch) {
	    this.sch = sch;
	    this.component = undefined;
	    this.selected = false;

	    // set up canvas
	    this.canvas = document.createElement('canvas');
	    this.canvas.style.borderStyle = 'solid';
	    this.canvas.style.borderWidth = '1px';
	    this.canvas.style.borderColor = background_style;
	    //this.canvas.style.position = 'absolute';
	    this.canvas.style.cursor = 'default';
	    this.canvas.height = part_w;
	    this.canvas.width = part_h;
	    this.canvas.part = this;

	    this.canvas.addEventListener('mouseover',part_enter,false);
	    this.canvas.addEventListener('mouseout',part_leave,false);
	    this.canvas.addEventListener('mousedown',part_mouse_down,false);
	    this.canvas.addEventListener('mouseup',part_mouse_up,false);

	    // make the part "clickable" by registering a dummy click handler
	    // this should make things work on the iPad
	    this.canvas.addEventListener('click',function(){},false);
	}

	Part.prototype.set_location = function(left,top) {
	    this.canvas.style.left = left + 'px';
	    this.canvas.style.top = top + 'px';
	}

	Part.prototype.right = function() {
	    return this.canvas.offsetLeft + this.canvas.offsetWidth;
	}

	Part.prototype.bottom = function() {
	    return this.canvas.offsetTop + this.canvas.offsetHeight;
	}

	Part.prototype.set_component = function(component,tip) {
	    component.sch = this;
	    this.component = component;
	    this.tip = tip;

	    // figure out scaling and centering of parts icon
	    var b = component.bounding_box;
	    var dx = b[2] - b[0];
	    var dy = b[3] - b[1];
	    this.scale = 0.8; //Math.min(part_w/(1.2*dx),part_h/(1.2*dy));
	    this.origin_x = b[0] + dx/2.0 - part_w/(2.0*this.scale);
	    this.origin_y = b[1] + dy/2.0 - part_h/(2.0*this.scale);

	    this.redraw();
	}

	Part.prototype.redraw = function(part) {
	    var c = this.canvas.getContext('2d');

	    // paint background color
	    c.fillStyle = this.selected ? selected_style : background_style;
	    c.fillRect(0,0,part_w,part_h);

	    if (this.component) this.component.draw(c);
	}

	Part.prototype.select = function(which) {
	    this.selected = which;
	    this.redraw();
	}

	Part.prototype.update_connection_point = function(cp,old_location) {
	    // no connection points in the parts bin
	}

	Part.prototype.moveTo = function(c,x,y) {
	    c.moveTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Part.prototype.lineTo = function(c,x,y) {
	    c.lineTo((x - this.origin_x) * this.scale,(y - this.origin_y) * this.scale);
	}

	Part.prototype.draw_line = function(c,x1,y1,x2,y2,width) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.moveTo((x1 - this.origin_x) * this.scale,(y1 - this.origin_y) * this.scale);
	    c.lineTo((x2 - this.origin_x) * this.scale,(y2 - this.origin_y) * this.scale);
	    c.stroke();
	}

	Part.prototype.draw_arc = function(c,x,y,radius,start_radians,end_radians,anticlockwise,width,filled) {
	    c.lineWidth = width*this.scale;
	    c.beginPath();
	    c.arc((x - this.origin_x)*this.scale,(y - this.origin_y)*this.scale,radius*this.scale,
		  start_radians,end_radians,anticlockwise);
	    if (filled) c.fill();
	    else c.stroke();
	}

	Part.prototype.draw_text = function(c,text,x,y,size) {
	    // no text displayed for the parts icon
	}

	function part_enter(event) {
	    if (!event) event = window.event;
	    var canvas = (window.event) ? event.srcElement : event.target;
	    var part = canvas.part;

	    // avoid Chrome bug that changes to text cursor whenever
	    // drag starts.  We'll restore the default handler at
	    // the appropriate point so behavior in other parts of
	    // the document are unaffected.
	    //part.sch.saved_onselectstart = document.onselectstart;
	    //document.onselectstart = function () { return false; };

	    canvas.style.borderColor = normal_style;
	    part.sch.message(part.tip+': drag onto diagram to insert');
	    return false;
	}

	function part_leave(event) {
	    if (!event) event = window.event;
	    var canvas = (window.event) ? event.srcElement : event.target;
	    var part = canvas.part;

	    if (typeof part.sch.new_part == 'undefined') {
		// leaving with no part selected?  revert handler
		//document.onselectstart = part.sch.saved_onselectstart;
	    }

	    canvas.style.borderColor = background_style;
	    part.sch.message('');
	    return false;
	}

	function part_mouse_down(event) {
	    if (!event) event = window.event;
	    var part = (window.event) ? event.srcElement.part : event.target.part;

	    part.select(true);
	    part.sch.new_part = part;
	    return false;
	}

	function part_mouse_up(event) {
	    if (!event) event = window.event;
	    var part = (window.event) ? event.srcElement.part : event.target.part;

	    part.select(false);
	    part.sch.new_part = undefined;
	    return false;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Rectangle helper functions
	//
	////////////////////////////////////////////////////////////////////////////////

	// rect is an array of the form [left,top,right,bottom]

	// ensure left < right, top < bottom
	function canonicalize(r) {
	    var temp;

	    // canonicalize bounding box
	    if (r[0] > r[2]) {
		temp = r[0];
		r[0] = r[2];
		r[2] = temp;
	    }
	    if (r[1] > r[3]) {
		temp = r[1];
		r[1] = r[3];
		r[3] = temp;
	    }
	}
    
	function between(x,x1,x2) {
	    return x1 <= x && x <= x2;
	}

	function inside(rect,x,y) {
	    return between(x,rect[0],rect[2]) && between(y,rect[1],rect[3]);
	}

	// only works for manhattan rectangles
	function intersect(r1,r2) {
	    // look for non-intersection, negate result
	    var result = !(r2[0] > r1[2] ||
			   r2[2] < r1[0] ||
			   r2[1] > r1[3] ||
			   r2[3] < r1[1]);

	    // if I try to return the above expression, javascript returns undefined!!!
	    return result;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Component base class
	//
	////////////////////////////////////////////////////////////////////////////////

	function Component(type,x,y,rotation) {
	    this.sch = undefined;
	    this.type = type;
	    this.x = x;
	    this.y = y;
	    this.rotation = rotation;
	    this.selected = false;
	    this.properties = new Array();
	    this.bounding_box = [0,0,0,0];   // in device coords [left,top,right,bottom]
	    this.bbox = this.bounding_box;   // in absolute coords
	    this.connections = [];
	}

	Component.prototype.json = function(index) {
	    this.properties['_json_'] = index; // remember where we are in the JSON list

	    var props = {};
	    for (var p in this.properties) props[p] = this.properties[p];

	    var conns = [];
	    for (var i = 0; i < this.connections.length; i++)
		conns.push(this.connections[i].json());

	    var json = [this.type,[this.x, this.y, this.rotation],props,conns];
	    return json;
	}

	Component.prototype.add_connection = function(offset_x,offset_y) {
	    this.connections.push(new ConnectionPoint(this,offset_x,offset_y));
	}

	Component.prototype.update_coords = function() {
	    var x = this.x;
	    var y = this.y;

	    // update bbox
	    var b = this.bounding_box;
	    this.bbox[0] = this.transform_x(b[0],b[1]) + x;
	    this.bbox[1] = this.transform_y(b[0],b[1]) + y;
	    this.bbox[2] = this.transform_x(b[2],b[3]) + x;
	    this.bbox[3] = this.transform_y(b[2],b[3]) + y;
	    canonicalize(this.bbox);

	    // update connections
	    for (var i = this.connections.length - 1; i >= 0; --i)
		this.connections[i].update_location();
	}

	Component.prototype.rotate = function(amount) {
	    var old_rotation = this.rotation;
	    this.rotation = (this.rotation + amount) % 8;
	    this.update_coords();

	    // create an undoable edit record here
	    // using old_rotation
	}

	Component.prototype.move_begin = function() {
	    // remember where we started this move
	    this.move_x = this.x;
	    this.move_y = this.y;
	}

	Component.prototype.move = function(dx,dy) {
	    // update coordinates
	    this.x += dx;
	    this.y += dy;
	    this.update_coords();
	}
    
	Component.prototype.move_end = function() {
	    var dx = this.x - this.move_x;
	    var dy = this.y - this.move_y;

	    if (dx != 0 || dy != 0) {
		// create an undoable edit record here

		this.sch.check_wires(this);
	    }
	}

	Component.prototype.add = function(sch) {
	    this.sch = sch;   // we now belong to a schematic!
	    sch.add_component(this);
	    this.update_coords();
	}

	Component.prototype.remove = function() {
	    // remove connection points from schematic
	    for (var i = this.connections.length - 1; i >= 0; --i) {
		var cp = this.connections[i];
		this.sch.remove_connection_point(cp,cp.location);
	    }

	    // remove component from schematic
	    this.sch.remove_component(this);
	    this.sch = undefined;

	    // create an undoable edit record here
	}

	Component.prototype.transform_x = function(x,y) {
	    var rot = this.rotation;
	    if (rot == 0 || rot == 6) return x;
	    else if (rot == 1 || rot == 5) return -y;
	    else if (rot == 2 || rot == 4) return -x;
	    else return y;
	}

	Component.prototype.transform_y = function(x,y) {
	    var rot = this.rotation;
	    if (rot == 1 || rot == 7) return x;
	    else if (rot == 2 || rot == 6) return -y;
	    else if (rot == 3 || rot == 5) return -x;
	    else return y;
	}

	Component.prototype.moveTo = function(c,x,y) {
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;
	    this.sch.moveTo(c,nx,ny);
	}

	Component.prototype.lineTo = function(c,x,y) {
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;
	    this.sch.lineTo(c,nx,ny);
	}

	Component.prototype.draw_line = function(c,x1,y1,x2,y2) {
	    c.strokeStyle = this.selected ? selected_style :
                            this.type == 'w' ? normal_style : component_style;
	    var nx1 = this.transform_x(x1,y1) + this.x;
	    var ny1 = this.transform_y(x1,y1) + this.y;
	    var nx2 = this.transform_x(x2,y2) + this.x;
	    var ny2 = this.transform_y(x2,y2) + this.y;
	    this.sch.draw_line(c,nx1,ny1,nx2,ny2,1);
	}

	Component.prototype.draw_circle = function(c,x,y,radius,filled) {
	    if (filled) c.fillStyle = this.selected ? selected_style : normal_style;
	    else c.strokeStyle = this.selected ? selected_style :
		     this.type == 'w' ? normal_style : component_style;
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;

	    this.sch.draw_arc(c,nx,ny,radius,0,2*Math.PI,false,1,filled);
	}

	rot_angle = [
		     0.0,		// NORTH (identity)
		     Math.PI/2,	// EAST (rot270)
		     Math.PI,	// SOUTH (rot180)
		     3*Math.PI/2,  // WEST (rot90)
		     0.0,		// RNORTH (negy)
		     Math.PI/2,	// REAST (int-neg)
		     Math.PI,	// RSOUTH (negx)
		     3*Math.PI/2,	// RWEST (int-pos)
		     ];

	Component.prototype.draw_arc = function(c,x,y,radius,start_radians,end_radians) {
	    c.strokeStyle = this.selected ? selected_style :
                            this.type == 'w' ? normal_style : component_style;
	    var nx = this.transform_x(x,y) + this.x;
	    var ny = this.transform_y(x,y) + this.y;
	    this.sch.draw_arc(c,nx,ny,radius,
			      start_radians+rot_angle[this.rotation],end_radians+rot_angle[this.rotation],
			      false,1,false);
	}

	Component.prototype.draw = function(c) {
	    /*
	    for (var i = this.connections.length - 1; i >= 0; --i) {
		var cp = this.connections[i];
		cp.draw_x(c);
	    }
	    */
	}

	// result of rotating an alignment [rot*9 + align]
	aOrient = [
		   0, 1, 2, 3, 4, 5, 6, 7, 8,		// NORTH (identity)
		   2, 5, 8, 1, 4, 7, 0, 3, 6, 		// EAST (rot270)
		   8, 7, 6, 5, 4, 3, 2, 1, 0,		// SOUTH (rot180)
		   6, 3, 0, 7, 4, 1, 8, 5, 3,		// WEST (rot90)
		   2, 1, 0, 5, 4, 3, 8, 7, 6,		// RNORTH (negy)
		   8, 5, 2, 7, 4, 1, 6, 3, 0, 		// REAST (int-neg)
		   6, 7, 8, 3, 4, 5, 0, 1, 2,		// RSOUTH (negx)
		   0, 3, 6, 1, 4, 7, 2, 5, 8		// RWEST (int-pos)
		   ];

	textAlign = [
		     'left', 'center', 'right',
		     'left', 'center', 'right',
		     'left', 'center', 'right'
		     ];

	textBaseline = [
			'top', 'top', 'top',
			'middle', 'middle', 'middle',
			'bottom', 'bottom', 'bottom'
			];

	Component.prototype.draw_text = function(c,text,x,y,alignment,size,fill) {
	    var a = aOrient[this.rotation*9 + alignment];
	    c.textAlign = textAlign[a];
	    c.textBaseline = textBaseline[a];
	    if (fill == undefined)
		c.fillStyle = this.selected ? selected_style : normal_style;
	    else
		c.fillStyle = fill;
	    this.sch.draw_text(c,text,
			       this.transform_x(x,y) + this.x,
			       this.transform_y(x,y) + this.y,
			       size);
	}

	Component.prototype.set_select = function(which) {
	    if (which != this.selected) {
		this.selected = which;
		// create an undoable edit record here
	    }
	}
    
	Component.prototype.select = function(x,y,shiftKey) {
	    this.was_previously_selected = this.selected;
	    if (this.near(x,y)) {
		this.set_select(shiftKey ? !this.selected : true);
		return true;
	    } else return false;
	}

	Component.prototype.select_rect = function(s) {
	    this.was_previously_selected = this.selected;
	    if (intersect(this.bbox,s))
		this.set_select(true);
	}

	// if connection point of component c bisects the
	// wire represented by this compononent, return that
	// connection point.  Otherwise return null.
	Component.prototype.bisect = function(c) {
	    return null;
	}

	// does mouse click fall on this component?
	Component.prototype.near = function(x,y) {
	    return inside(this.bbox,x,y);
	}

	Component.prototype.edit_properties = function(x,y) {
	    if (this.near(x,y)) {
		// make an <input> widget for each property
		var fields = new Array();
		for (var i in this.properties)
		    // underscore at beginning of property name => system property
		    if (i.charAt(0) != '_')
			fields[i] = build_input('text',10,this.properties[i]);

		var content = build_table(fields);
		content.fields = fields;
		content.component = this;

		this.sch.dialog('Edit Properties',content,function(content) {
			for (var i in content.fields)
			    content.component.properties[i] = content.fields[i].value;
			content.component.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}

	// clear the labels on all connections
	Component.prototype.clear_labels = function() {
	    for (var i = this.connections.length - 1; i >=0; --i) {
		this.connections[i].clear_label();
	    }
	}

	// default action: don't propagate label
	Component.prototype.propagate_label = function(label) {
	}

	// give components a chance to generate default labels for their connection(s)
	// default action: do nothing
	Component.prototype.add_default_labels = function() {
	}

	// component should generate labels for all unlabeled connections
	Component.prototype.label_connections = function() {
	    for (var i = this.connections.length - 1; i >=0; --i) {
		var cp = this.connections[i];
		if (!cp.label)
		    cp.propagate_label(this.sch.get_next_label());
	    }
	}

	// default behavior: no probe info
	Component.prototype.probe_info = function() { return undefined; }

	// default behavior: nothing to display for DC analysis
	Component.prototype.display_current = function(c,vmap) {
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Connection point
	//
	////////////////////////////////////////////////////////////////////////////////

	connection_point_radius = 2;

	function ConnectionPoint(parent,x,y) {
	    this.parent = parent;
	    this.offset_x = x;
	    this.offset_y = y;
	    this.location = '';
	    this.update_location();
	    this.label = undefined;
	}

	ConnectionPoint.prototype.toString = function() {
	    return '<ConnectionPoint ('+this.offset_x+','+this.offset_y+') '+this.parent.toString()+'>';
	}

	ConnectionPoint.prototype.json = function() {
	    return this.label;
	}

	ConnectionPoint.prototype.clear_label = function() {
	    this.label = undefined;
	}

	ConnectionPoint.prototype.propagate_label = function(label) {
	    // should we check if existing label is the same?  it should be...

	    if (this.label === undefined) {
		// label this connection point
		this.label = label;

		// propagate label to coincident connection points
		this.parent.sch.propagate_label(label,this.location);

		// possibly label other cp's for this device?
		this.parent.propagate_label(label);
	    } else if (this.label != '0' && label != '0' && this.label != label)
		alert("Node has two conflicting labels: "+this.label+", "+label);
	}

	ConnectionPoint.prototype.update_location = function() {
	    // update location string which we use as a key to find coincident connection points
	    var old_location = this.location;
	    var parent = this.parent;
	    var nx = parent.transform_x(this.offset_x,this.offset_y) + parent.x;
	    var ny = parent.transform_y(this.offset_x,this.offset_y) + parent.y;
	    this.x = nx;
	    this.y = ny;
	    this.location = nx + ',' + ny;

	    // add ourselves to the connection list for the new location
	    if (parent.sch) 
		parent.sch.update_connection_point(this,old_location);
	}

	ConnectionPoint.prototype.coincident = function(x,y) {
	    return this.x==x && this.y==y;
	}

	ConnectionPoint.prototype.draw = function(c,n) {
	    if (n != 2)
		this.parent.draw_circle(c,this.offset_x,this.offset_y,connection_point_radius,n > 2);
	}

	ConnectionPoint.prototype.draw_x = function(c) {
	    this.parent.draw_line(c,this.offset_x-2,this.offset_y-2,this.offset_x+2,this.offset_y+2,grid_style);
	    this.parent.draw_line(c,this.offset_x+2,this.offset_y-2,this.offset_x-2,this.offset_y+2,grid_style);
	}

	ConnectionPoint.prototype.display_voltage = function(c,vmap) {
	    var v = vmap[this.label];
	    if (v != undefined) {
		var label = v.toFixed(2) + 'V';
		
		// first draw some solid blocks in the background
		c.globalAlpha = 0.85;
		this.parent.draw_text(c,'\u2588\u2588\u2588',this.offset_x,this.offset_y,
				      4,annotation_size,element_style);
		c.globalAlpha = 1.0;

		// display the node voltage at this connection point
		this.parent.draw_text(c,label,this.offset_x,this.offset_y,
				      4,annotation_size,annotation_style);

		// only display each node voltage once
		delete vmap[this.label];
	    }
	}

	// see if three connection points are collinear
	function collinear(p1,p2,p3) {
	    // from http://mathworld.wolfram.com/Collinear.html
	    var area = p1.x*(p2.y - p3.y) + p2.x*(p3.y - p1.y) + p3.x*(p1.y - p2.y);
	    return area == 0;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Wire
	//
	////////////////////////////////////////////////////////////////////////////////

	near_distance = 2;   // how close to wire counts as "near by"

	function Wire(x1,y1,x2,y2) {
	    // arbitrarily call x1,y1 the origin
	    Component.call(this,'w',x1,y1,0);
	    this.dx = x2 - x1;
	    this.dy = y2 - y1;
	    this.add_connection(0,0);
	    this.add_connection(this.dx,this.dy);

	    // compute bounding box (expanded slightly)
	    var r = [0,0,this.dx,this.dy];
	    canonicalize(r);
	    r[0] -= near_distance;
	    r[1] -= near_distance;
	    r[2] += near_distance;
	    r[3] += near_distance;
	    this.bounding_box = r;
	    this.update_coords();    // update bbox

	    // used in selection calculations
	    this.len = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
	}
	Wire.prototype = new Component();
	Wire.prototype.constructor = Wire;

	Wire.prototype.toString = function() {
	    return '<Wire ('+this.x+','+this.y+') ('+(this.x+this.dx)+','+(this.y+this.dy)+')>';
	}
    
	// return connection point at other end of wire from specified cp
	Wire.prototype.other_end = function(cp) {
	    if (cp == this.connections[0]) return this.connections[1];
	    else if (cp == this.connections[1]) return this.connections[0];
	    else return undefined;
	}

	Wire.prototype.json = function(index) {
	    var json = ['w',[this.x, this.y, this.x+this.dx, this.y+this.dy]];
	    return json;
	}

	Wire.prototype.draw = function(c) {
	    this.draw_line(c,0,0,this.dx,this.dy);
	}

	Wire.prototype.clone = function(x,y) {
	    return new Wire(x,y,x+this.dx,y+this.dy);
	}

	Wire.prototype.near = function(x,y) {
	    // crude check: (x,y) within expanded bounding box of wire
	    if (inside(this.bbox,x,y)) {
		// compute distance between x,y and nearst point on line
		// http://www.allegro.cc/forums/thread/589720
		var D = Math.abs((x - this.x)*this.dy - (y - this.y)*this.dx)/this.len;
		if (D <= near_distance) return true;
	    }
	    return false;
	}

	// selection rectangle selects wire only if it includes
	// one of the end points
	Wire.prototype.select_rect = function(s) {
	    this.was_previously_selected = this.selected;
	    if (inside(s,this.x,this.y) || inside(s,this.x+this.dx,this.y+this.dy))
		this.set_select(true);
	}

	// if connection point cp bisects the
	// wire represented by this compononent, return true
	Wire.prototype.bisect_cp = function(cp) {
	    var x = cp.x;
	    var y = cp.y;

	    // crude check: (x,y) within expanded bounding box of wire
	    if (inside(this.bbox,x,y)) {
		// compute distance between x,y and nearst point on line
		// http://www.allegro.cc/forums/thread/589720
		var D = Math.abs((x - this.x)*this.dy - (y - this.y)*this.dx)/this.len;
		// final check: ensure point isn't an end point of the wire
		if (D < 1 && !this.connections[0].coincident(x,y) && !this.connections[1].coincident(x,y))
		    return true;
	    }
	    return false;
	}

	// if some connection point of component c bisects the
	// wire represented by this compononent, return that
	// connection point.  Otherwise return null.
	Wire.prototype.bisect = function(c) {
	    if (c == undefined) return;
	    for (var i = c.connections.length - 1; i >= 0; --i) {
		var cp = c.connections[i];
		if (this.bisect_cp(cp)) return cp;
	    }
	    return null;
	}

	Wire.prototype.move_end = function() {
	    // look for wires bisected by this wire
	    this.sch.check_wires(this);

	    // look for connection points that might bisect us
	    this.sch.check_connection_points(this);
	}

	// wires "conduct" their label to the other end
	Wire.prototype.propagate_label = function(label) {
	    // don't worry about relabeling a cp, it won't recurse!
	    this.connections[0].propagate_label(label);
	    this.connections[1].propagate_label(label);
	}

	// Wires have no properties to edit
	Wire.prototype.edit_properties = function(x,y) {
	    return false;
	}

	// some actual component will start the labeling of electrical nodes,
	// so do nothing here
	Wire.prototype.label_connections = function() {
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Ground
	//
	////////////////////////////////////////////////////////////////////////////////

	function Ground(x,y,rotation) {
	    Component.call(this,'g',x,y,rotation);
	    this.add_connection(0,0);
	    this.bounding_box = [-6,0,6,8];
	    this.update_coords();
	}
	Ground.prototype = new Component();
	Ground.prototype.constructor = Ground;

	Ground.prototype.toString = function() {
	    return '<Ground ('+this.x+','+this.y+')>';
	}
    
	Ground.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,8);
	    this.draw_line(c,-6,8,6,8);
	}

	Ground.prototype.clone = function(x,y) {
	    return new Ground(x,y,this.rotation);
	}

	// Grounds no properties to edit
	Ground.prototype.edit_properties = function(x,y) {
	    return false;
	}

	// give components a chance to generate a label for their connection(s)
	// default action: do nothing
	Ground.prototype.add_default_labels = function() {
	    this.connections[0].propagate_label('0');   // canonical label for GND node
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Label
	//
	////////////////////////////////////////////////////////////////////////////////

	function Label(x,y,rotation,label) {
	    Component.call(this,'L',x,y,rotation);
	    this.properties['label'] = label ? label : '???';
	    this.add_connection(0,0);
	    this.bounding_box = [-2,0,2,8];
	    this.update_coords();
	}
	Label.prototype = new Component();
	Label.prototype.constructor = Label;

	Label.prototype.toString = function() {
	    return '<Label'+' ('+this.x+','+this.y+')>';
	}
    
	Label.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,8);
	    this.draw_text(c,this.properties['label'],0,9,1,property_size);
	}

	Label.prototype.clone = function(x,y) {
	    return new Label(x,y,this.rotation,this.properties['label']);
	}

	// give components a chance to generate a label for their connection(s)
	// default action: do nothing
	Label.prototype.add_default_labels = function() {
	    this.connections[0].propagate_label(this.properties['label']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Voltage Probe
	//
	////////////////////////////////////////////////////////////////////////////////

	probe_colors = ['red','green','blue','cyan','magenta','yellow','black','x-axis'];
	probe_colors_rgb = {
	    'red': 'rgb(255,64,64)',
	    'green': 'rgb(64,255,64)',
	    'blue': 'rgb(64,64,255)',
	    'cyan': 'rgb(64,255,255)',
	    'magenta' : 'rgb(255,64,255)',
	    'yellow': 'rgb(255,255,64)',
	    'black': 'rgb(0,0,0)',
	    'x-axis': undefined
	};

	function Probe(x,y,rotation,color,offset) {
	    Component.call(this,'s',x,y,rotation);
	    this.add_connection(0,0);
	    this.properties['color'] = color ? color : 'cyan';
	    this.properties['offset'] = (offset==undefined || offset=='') ? '0' : offset;
	    this.bounding_box = [0,0,27,-21];
	    this.update_coords();
	}
	Probe.prototype = new Component();
	Probe.prototype.constructor = Probe;

	Probe.prototype.toString = function() {
	    return '<Probe ('+this.x+','+this.y+')>';
	}
    
	Probe.prototype.draw = function(c) {
	    // draw outline
	    this.draw_line(c,0,0,4,-4);
	    this.draw_line(c,2,-6,6,-2);
	    this.draw_line(c,2,-6,17,-21);
	    this.draw_line(c,6,-2,21,-17);
	    this.draw_line(c,17,-21,21,-17);
	    this.draw_arc(c,19,-11,8,3*Math.PI/2,0);

	    // fill body with plot color
	    var color = probe_colors_rgb[this.properties['color']];
	    if (color != undefined) {
		c.fillStyle = color;
		c.beginPath();
		this.moveTo(c,2,-6);
		this.lineTo(c,6,-2);
		this.lineTo(c,21,-17);
		this.lineTo(c,17,-21);
		this.lineTo(c,2,-6);
		c.fill();
	    } else {
		this.draw_text(c,this.properties['color'],27,-11,1,property_size);
	    }
	}

	Probe.prototype.clone = function(x,y) {
	    return new Probe(x,y,this.rotation,this.properties['color'],this.properties['offset']);
	}

	Probe.prototype.edit_properties = function(x,y) {
	    if (inside(this.bbox,x,y)) {
		var fields = new Array();
		fields['Plot color'] = build_select(probe_colors,this.properties['color']);
		fields['Plot offset'] = build_input('text',10,this.properties['offset']);

		var content = build_table(fields);
		content.fields = fields;
		content.component = this;

		this.sch.dialog('Edit Properties',content,function(content) {
			var color_choice = content.fields['Plot color'];
			content.component.properties['color'] = probe_colors[color_choice.selectedIndex];
			content.component.properties['offset'] = content.fields['Plot offset'].value;
			content.component.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}

	// return [color, node_label, offset, type] for this probe
	Probe.prototype.probe_info = function() {
	    var color = this.properties['color'];
	    var offset = this.properties['offset'];
	    if (offset==undefined || offset=="") offset = '0';
	    return [color,this.connections[0].label,offset,'voltage'];
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Ammeter Probe
	//
	////////////////////////////////////////////////////////////////////////////////

	function Ammeter(x,y,rotation,color,offset) {
	    Component.call(this,'a',x,y,rotation);
	    this.add_connection(0,0);   // pos
	    this.add_connection(16,0);   // neg
	    this.properties['color'] = color ? color : 'magenta';
	    this.properties['offset'] = (offset==undefined || offset=='') ? '0' : offset;
	    this.bounding_box = [-3,0,16,3];
	    this.update_coords();
	}
	Ammeter.prototype = new Component();
	Ammeter.prototype.constructor = Ammeter;

	Ammeter.prototype.toString = function() {
	    return '<Ammeter ('+this.x+','+this.y+')>';
	}
    
	Ammeter.prototype.move_end = function() {
	    Component.prototype.move_end.call(this);   // do the normal processing

	    // special for current probes: see if probe has been placed
	    // in the middle of wire, creating three wire segments one
	    // of which is shorting the two terminals of the probe.  If
	    // so, auto remove the shorting segment.
	    var e1 = this.connections[0].location;
	    var e2 = this.connections[1].location;
	    var cplist = this.sch.find_connections(this.connections[0]);
	    for (var i = cplist.length - 1; i >= 0; --i) {
		var c = cplist[i].parent;  // a component connected to ammeter terminal
		// look for a wire whose end points match those of the ammeter
		if (c.type == 'w') {
		    var c_e1 = c.connections[0].location;
		    var c_e2 = c.connections[1].location;
		    if ((e1 == c_e1 && c2 == c_e2) || (e1 == c_e2 && e2 == c_e1)) {
			c.remove();
			break;
		    }
		}
	    }
	}

	Ammeter.prototype.draw = function(c) {
	    this.draw_line(c,0,0,16,0);

	    // draw chevron in probe color
	    c.strokeStyle = probe_colors_rgb[this.properties['color']];
	    if (c.strokeStyle != undefined) {
		c.beginPath();
		this.moveTo(c,6,-3);
		this.lineTo(c,10,0);
		this.lineTo(c,6,3);
		c.stroke();
	    }
	}

	Ammeter.prototype.clone = function(x,y) {
	    return new Ammeter(x,y,this.rotation,this.properties['color'],this.properties['offset']);
	}

	// share code with voltage probe
	Ammeter.prototype.edit_properties = Probe.prototype.edit_properties;

	Ammeter.prototype.label = function() {
	    var name = this.properties['name'];
	    var label = 'I(' + (name ? name : '_' + this.properties['_json_']) + ')';
	    return label;
	}

	// display current for DC analysis
	Ammeter.prototype.display_current = function(c,vmap) {
	    var label = this.label();
	    var v = vmap[label];
	    if (v != undefined) {
		var i = engineering_notation(v,2) + 'A';
		this.draw_text(c,i,8,-5,7,annotation_size,annotation_style);

		// only display each current once
		delete vmap[label];
	    }
	}

	// return [color, current_label, offset, type] for this probe
	Ammeter.prototype.probe_info = function() {
	    var color = this.properties['color'];
	    var offset = this.properties['offset'];
	    if (offset==undefined || offset=="") offset = '0';
	    return [color,this.label(),offset,'current'];
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Resistor
	//
	////////////////////////////////////////////////////////////////////////////////

	function Resistor(x,y,rotation,name,r) {
	    Component.call(this,'r',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['r'] = r ? r : '1';
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-5,0,5,48];
	    this.update_coords();
	}
	Resistor.prototype = new Component();
	Resistor.prototype.constructor = Resistor;

	Resistor.prototype.toString = function() {
	    return '<Resistor '+this.properties['r']+' ('+this.x+','+this.y+')>';
	}
    
	Resistor.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,12);
	    this.draw_line(c,0,12,4,14);
	    this.draw_line(c,4,14,-4,18);
	    this.draw_line(c,-4,18,4,22);
	    this.draw_line(c,4,22,-4,26);
	    this.draw_line(c,-4,26,4,30);
	    this.draw_line(c,4,30,-4,34);
	    this.draw_line(c,-4,34,0,36);
	    this.draw_line(c,0,36,0,48);
	    if (this.properties['r'])
		this.draw_text(c,this.properties['r']+'\u03A9',5,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-5,24,5,property_size);
	}

	Resistor.prototype.clone = function(x,y) {
	    return new Resistor(x,y,this.rotation,this.properties['name'],this.properties['r']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Capacitor
	//
	////////////////////////////////////////////////////////////////////////////////

	function Capacitor(x,y,rotation,name,c) {
	    Component.call(this,'c',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['c'] = c ? c : '1p';
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-8,0,8,48];
	    this.update_coords();
	}
	Capacitor.prototype = new Component();
	Capacitor.prototype.constructor = Capacitor;

	Capacitor.prototype.toString = function() {
	    return '<Capacitor '+this.properties['r']+' ('+this.x+','+this.y+')>';
	}
    
	Capacitor.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,22);
	    this.draw_line(c,-8,22,8,22);
	    this.draw_line(c,-8,26,8,26);
	    this.draw_line(c,0,26,0,48);
	    if (this.properties['c'])
		this.draw_text(c,this.properties['c']+'F',9,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-9,24,5,property_size);
	}

	Capacitor.prototype.clone = function(x,y) {
	    return new Capacitor(x,y,this.rotation,this.properties['name'],this.properties['c']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Inductor
	//
	////////////////////////////////////////////////////////////////////////////////

	function Inductor(x,y,rotation,name,l) {
	    Component.call(this,'l',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['l'] = l ? l : '1n';
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-4,0,5,48];
	    this.update_coords();
	}
	Inductor.prototype = new Component();
	Inductor.prototype.constructor = Inductor;

	Inductor.prototype.toString = function() {
	    return '<Inductor '+this.properties['l']+' ('+this.x+','+this.y+')>';
	}
    
	Inductor.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,14);
	    this.draw_arc(c,0,18,4,6*Math.PI/4,3*Math.PI/4);
	    this.draw_arc(c,0,24,4,5*Math.PI/4,3*Math.PI/4);
	    this.draw_arc(c,0,30,4,5*Math.PI/4,2*Math.PI/4);
	    this.draw_line(c,0,34,0,48);

	    if (this.properties['l'])
		this.draw_text(c,this.properties['l']+'H',6,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-3,24,5,property_size);
	}

	Inductor.prototype.clone = function(x,y) {
	    return new Inductor(x,y,this.rotation,this.properties['name'],this.properties['l']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Diode
	//
	////////////////////////////////////////////////////////////////////////////////

	diode_types = ['normal','ideal'];

	function Diode(x,y,rotation,name,area,type) {
	    Component.call(this,'d',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['area'] = area ? area : '1';
	    this.properties['type'] = type ? type : 'normal';
	    this.add_connection(0,0);   // anode
	    this.add_connection(0,48);  // cathode
	    this.bounding_box = (type == 'ideal') ? [-12,0,12,48] : [-8,0,8,48];
	    this.update_coords();
	}
	Diode.prototype = new Component();
	Diode.prototype.constructor = Diode;

	Diode.prototype.toString = function() {
	    return '<Diode '+this.properties['area']+' ('+this.x+','+this.y+')>';
	}
    
	Diode.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,16);
	    this.draw_line(c,-8,16,8,16);
	    this.draw_line(c,-8,16,0,32);
	    this.draw_line(c,8,16,0,32);
	    this.draw_line(c,-8,32,8,32);
	    this.draw_line(c,0,32,0,48);

	    if (this.properties['type'] == 'ideal') {
		// put a box around an ideal diode
		this.draw_line(c,-10,12,10,12);
		this.draw_line(c,-10,12,-10,36);
		this.draw_line(c,10,12,10,36);
		this.draw_line(c,-10,36,10,36);
	    }

	    if (this.properties['area'])
		this.draw_text(c,this.properties['area'],10,24,3,property_size);
	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-10,24,5,property_size);
	}

	Diode.prototype.clone = function(x,y) {
	    return new Diode(x,y,this.rotation,this.properties['name'],this.properties['area'],this.properties['type']);
	}

	Diode.prototype.edit_properties = function(x,y) {
	    if (inside(this.bbox,x,y)) {
		var fields = new Array();
		fields['name'] = build_input('text',10,this.properties['name']);
		fields['area'] = build_input('text',10,this.properties['area']);
		fields['type'] = build_select(diode_types,this.properties['type']);

		var content = build_table(fields);
		content.fields = fields;
		content.component = this;

		this.sch.dialog('Edit Properties',content,function(content) {
			content.component.properties['name'] = content.fields['name'].value;
			content.component.properties['area'] = content.fields['area'].value;
			content.component.properties['type'] = diode_types[content.fields['type'].selectedIndex];
			content.component.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  N-channel Mosfet
	//
	////////////////////////////////////////////////////////////////////////////////

	function NFet(x,y,rotation,name,w_over_l) {
	    Component.call(this,'n',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['W/L'] = w_over_l ? w_over_l : '2';
	    this.add_connection(0,0);   // drain
	    this.add_connection(-24,24);  // gate
	    this.add_connection(0,48);  // source
	    this.bounding_box = [-24,0,8,48];
	    this.update_coords();
	}
	NFet.prototype = new Component();
	NFet.prototype.constructor = NFet;

	NFet.prototype.toString = function() {
	    return '<NFet '+this.properties['W/L']+' ('+this.x+','+this.y+')>';
	}
    
	NFet.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,16);
	    this.draw_line(c,-8,16,0,16);
	    this.draw_line(c,-8,16,-8,32);
	    this.draw_line(c,-8,32,0,32);
	    this.draw_line(c,0,32,0,48);

	    this.draw_line(c,-24,24,-12,24);
	    this.draw_line(c,-12,16,-12,32);

	    var dim = this.properties['W/L'];
	    if (this.properties['name']) {
		this.draw_text(c,this.properties['name'],2,22,6,property_size);
		this.draw_text(c,dim,2,26,0,property_size);
	    } else
		this.draw_text(c,dim,2,24,3,property_size);
	}

	NFet.prototype.clone = function(x,y) {
	    return new NFet(x,y,this.rotation,this.properties['name'],this.properties['W/L']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  P-channel Mosfet
	//
	////////////////////////////////////////////////////////////////////////////////

	function PFet(x,y,rotation,name,w_over_l) {
	    Component.call(this,'p',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['W/L'] = w_over_l ? w_over_l : '2';
	    this.add_connection(0,0);   // drain
	    this.add_connection(-24,24);  // gate
	    this.add_connection(0,48);  // source
	    this.bounding_box = [-24,0,8,48];
	    this.update_coords();
	}
	PFet.prototype = new Component();
	PFet.prototype.constructor = PFet;

	PFet.prototype.toString = function() {
	    return '<PFet '+this.properties['W/L']+' ('+this.x+','+this.y+')>';
	}
    
	PFet.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,16);
	    this.draw_line(c,-8,16,0,16);
	    this.draw_line(c,-8,16,-8,32);
	    this.draw_line(c,-8,32,0,32);
	    this.draw_line(c,0,32,0,48);

	    this.draw_line(c,-24,24,-16,24);

	    this.draw_circle(c,-14,24,2,false);
	    this.draw_line(c,-12,16,-12,32);

	    var dim = this.properties['W/L'];
	    if (this.properties['name']) {
		this.draw_text(c,this.properties['name'],2,22,6,property_size);
		this.draw_text(c,dim,2,26,0,property_size);
	    } else
		this.draw_text(c,dim,2,24,3,property_size);
	}

	PFet.prototype.clone = function(x,y) {
	    return new PFet(x,y,this.rotation,this.properties['name'],this.properties['W/L']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Op Amp
	//
	////////////////////////////////////////////////////////////////////////////////

	function OpAmp(x,y,rotation,name,A) {
	    Component.call(this,'o',x,y,rotation);
	    this.properties['name'] = name;
	    this.properties['A'] = A ? A : '30000';
	    this.add_connection(0,0);   // +
	    this.add_connection(0,16);  // -
	    this.add_connection(48,8);  // output
	    this.add_connection(24,32);  // ground
	    this.bounding_box = [0,-8,48,32];
	    this.update_coords();
	}
	OpAmp.prototype = new Component();
	OpAmp.prototype.constructor = OpAmp;

	OpAmp.prototype.toString = function() {
	    return '<OpAmp'+this.properties['A']+' ('+this.x+','+this.y+')>';
	}
    
	OpAmp.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    // triangle
	    this.draw_line(c,8,-8,8,24);
	    this.draw_line(c,8,-8,40,8);
	    this.draw_line(c,8,24,40,8);
	    // inputs and output
	    this.draw_line(c,0,0,8,0);
	    this.draw_line(c,0,16,8,16);
	    this.draw_text(c,'gnd',37,18,property_size);
	    this.draw_line(c,40,8,48,8);
	    this.draw_line(c,24,16,24,32);
	    // + and -
	    this.draw_line(c,10,0,16,0);
	    this.draw_line(c,13,-3,13,3);
	    this.draw_line(c,10,16,16,16);

	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],32,16,0,property_size);
	}

	OpAmp.prototype.clone = function(x,y) {
	    return new OpAmp(x,y,this.rotation,this.properties['name'],this.properties['A']);
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//  Source
	//
	////////////////////////////////////////////////////////////////////////////////

	
	function Source(x,y,rotation,name,type,value) {
	    Component.call(this,type,x,y,rotation);
	    this.properties['name'] = name;
	    if (value == undefined) value = 'dc(1)';
	    this.properties['value'] = value;
	    this.add_connection(0,0);
	    this.add_connection(0,48);
	    this.bounding_box = [-12,0,12,48];
	    this.update_coords();

	    this.content = document.createElement('div');  // used by edit_properties
	}
	Source.prototype = new Component();
	Source.prototype.constructor = Source;

	Source.prototype.toString = function() {
	    return '<'+this.type+'source '+this.properties['params']+' ('+this.x+','+this.y+')>';
	}
    
	Source.prototype.draw = function(c) {
	    Component.prototype.draw.call(this,c);   // give superclass a shot
	    this.draw_line(c,0,0,0,12);
	    this.draw_circle(c,0,24,12,false);
	    this.draw_line(c,0,36,0,48);

	    if (this.type == 'v') {  // voltage source
		//this.draw_text(c,'+',0,12,1,property_size);
		//this.draw_text(c,'\u2013',0,36,7,property_size);  // minus sign
		// draw + and -
		this.draw_line(c,0,15,0,21);
		this.draw_line(c,-3,18,3,18);
		this.draw_line(c,-3,30,3,30);
		// draw V
		//this.draw_line(c,-3,20,0,28);
		//this.draw_line(c,3,20,0,28);
	    } else if (this.type == 'i') {  // current source
		// draw arrow: pos to neg
		this.draw_line(c,0,15,0,32);
		this.draw_line(c,-3,26,0,32);
		this.draw_line(c,3,26,0,32);
	    }

	    if (this.properties['name'])
		this.draw_text(c,this.properties['name'],-13,24,5,property_size);
	    if (this.properties['value'])
		this.draw_text(c,this.properties['value'],13,24,3,property_size);
	}

	// map source function name to labels for each source parameter
	source_functions = {
	    'dc': ['DC value'],

	    'impulse': ['Height',
			'Width (secs)'],

	    'step': ['Initial value',
		     'Plateau value',
		     'Delay until step (secs)',
		     'Rise time (secs)'],

	    'square': ['Initial value',
		       'Plateau value',
		       'Frequency (Hz)',
		       'Duty cycle (%)'],

	    'triangle': ['Initial value',
			 'Plateau value',
			 'Frequency (Hz)'],

	    'pwl': ['Comma-separated list of alternating times and values'],

	    'pwl_repeating': ['Comma-separated list of alternating times and values'],

	    'pulse': ['Initial value',
		      'Plateau value',
		      'Delay until pulse (secs)',
		      'Time for first transition (secs)',
		      'Time for second transition (secs)',
		      'Pulse width (secs)',
		      'Period (secs)'],

	    'sin': ['Offset value',
		    'Amplitude',
		    'Frequency (Hz)',
		    'Delay until sin starts (secs)',
		    'Phase offset (degrees)']
	}

	// build property editor div
	Source.prototype.build_content = function(src) {
	    // make an <input> widget for each property
	    var fields = []
	    fields['name'] = build_input('text',10,this.properties['name']);

	    if (src == undefined) {
		fields['value'] = this.properties['value'];
	    } else {
		// fancy version: add select tag for source type
		var src_types = [];
		for (var t in source_functions) src_types.push(t);
		var type_select = build_select(src_types,src.fun);
		type_select.component = this;
		type_select.addEventListener('change',source_type_changed,false)
		fields['type'] = type_select;

		if (src.fun == 'pwl' || src.run == 'pwl_repeating') {
		    var v = '';
		    var first = true;
		    for (var i = 0; i < src.args.length; i++) {
			if (first) first = false;
			else v += ',';
			v += engineering_notation(src.args[i],3);
			if (i % 2 == 0) v += 's';
		    }
		    fields[source_functions[src.fun][0]] = build_input('text',30,v);
		} else {
		    // followed separate input tag for each parameter
		    var labels = source_functions[src.fun];
		    for (var i = 0; i < labels.length; i++) {
			var v = engineering_notation(src.args[i],3);
			fields[labels[i]] = build_input('text',10,v);
		    }
		}
	    }

	    var div = this.content;
	    if (div.hasChildNodes())
		div.removeChild(div.firstChild);  // remove table of input fields
	    div.appendChild(build_table(fields));
	    div.fields = fields;
	    div.component = this;
	    return div;
	}

	function source_type_changed(event) {
	    if (!event) event = window.event;
	    var select = (window.event) ? event.srcElement : event.target;

	    // see where to get source parameters from
	    var type = select.options[select.selectedIndex].value;
	    var src = undefined;
	    if (this.src != undefined && type == this.src.fun)
		src = this.src;
	    else if (typeof cktsim != 'undefined')
		src = cktsim.parse_source(type+'()');

	    select.component.build_content(src);
	}

	Source.prototype.edit_properties = function(x,y) {
	    if (this.near(x,y)) {
		this.src = undefined;
		if (typeof cktsim != 'undefined')
		    this.src = cktsim.parse_source(this.properties['value']);
		var content = this.build_content(this.src);

		this.sch.dialog('Edit Properties',content,function(content) {
			var c = content.component;
			var fields = content.fields;

			var first = true;
			var value = '';
			for (var label in fields) {
			    if (label == 'name') 
				c.properties['name'] = fields['name'].value;
			    else if (label == 'value')  {
				// if unknown source type
				value = fields['value'].value;
				c.sch.redraw_background();
				return;
			    } else if (label == 'type') {
				var select = fields['type'];
				value = select.options[select.selectedIndex].value + '(';
			    } else {
				if (first) first = false;
				else value += ',';
				value += fields[label].value;
			    }
			}
			c.properties['value'] = value + ')';
			c.sch.redraw_background();
		    });
		return true;
	    } else return false;
	}


	function VSource(x,y,rotation,name,value) {
	    Source.call(this,x,y,rotation,name,'v',value);
	    this.type = 'v';
	}
	VSource.prototype = new Component();
	VSource.prototype.constructor = VSource;
	VSource.prototype.toString = Source.prototype.toString;
	VSource.prototype.draw = Source.prototype.draw;
	VSource.prototype.clone = Source.prototype.clone;
	VSource.prototype.build_content = Source.prototype.build_content;
	VSource.prototype.edit_properties = Source.prototype.edit_properties;

	// display current for DC analysis
	VSource.prototype.display_current = function(c,vmap) {
	    var name = this.properties['name'];
	    var label = 'I(' + (name ? name : '_' + this.properties['_json_']) + ')';
	    var v = vmap[label];
	    if (v != undefined) {
		// first draw some solid blocks in the background
		c.globalAlpha = 0.5;
		this.draw_text(c,'\u2588\u2588\u2588',-8,8,4,annotation_size,element_style);
		c.globalAlpha = 1.0;

		// display the element current 
		var i = engineering_notation(v,2) + 'A';
		this.draw_text(c,i,-3,5,5,annotation_size,annotation_style);
		// draw arrow for current
		this.draw_line(c,-3,4,0,8);
		this.draw_line(c,3,4,0,8);
		// only display each current once
		delete vmap[label];
	    }
	}

	VSource.prototype.clone = function(x,y) {
	    return new VSource(x,y,this.rotation,this.properties['name'],this.properties['value']);
	}

	function ISource(x,y,rotation,name,value) {
	    Source.call(this,x,y,rotation,name,'i',value);
	    this.type = 'i';
	}
	ISource.prototype = new Component();
	ISource.prototype.constructor = ISource;
	ISource.prototype.toString = Source.prototype.toString;
	ISource.prototype.draw = Source.prototype.draw;
	ISource.prototype.clone = Source.prototype.clone;
	ISource.prototype.build_content = Source.prototype.build_content;
	ISource.prototype.edit_properties = Source.prototype.edit_properties;

	ISource.prototype.clone = function(x,y) {
	    return new ISource(x,y,this.rotation,this.properties['name'],this.properties['value']);
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  JQuery slider support for setting a component value
	//
	///////////////////////////////////////////////////////////////////////////////

	function component_slider(event,ui) {
	    var sname = $(this).slider("option","schematic");

	    // set value of specified component
	    var cname = $(this).slider("option","component");
	    var pname = $(this).slider("option","property");
	    var suffix = $(this).slider("option","suffix");
	    if (typeof suffix != "string") suffix = "";

	    var v = ui.value;
	    $(this).slider("value",v);  // move slider's indicator

	    var choices = $(this).slider("option","choices");
	    if (choices instanceof Array) v = choices[v];

	    // selector may match several schematics
	    $("." + sname).each(function(index,element) {
		    element.schematic.set_property(cname,pname,v.toString() + suffix);
		})

	    // perform requested analysis
	    var analysis = $(this).slider("option","analysis");
	    if (analysis == "dc")
		$("." + sname).each(function(index,element) {
			element.schematic.dc_analysis();
		    })

	    return false;
	}

	///////////////////////////////////////////////////////////////////////////////
	//
	//  Module definition
	//
	///////////////////////////////////////////////////////////////////////////////

	var module = {
	    'Schematic': Schematic,
	    'component_slider': component_slider
	}
	return module;
    }());

/**
 * @file HTML5 video player module. Provides methods to control the in-browser HTML5 video player.
 *
 * The goal was to write this module so that it closely resembles the YouTube API. The main reason
 * for this is because initially the edX video player supported only YouTube videos. When HTML5
 * support was added, for greater compatibility, and to reduce the amount of code that needed to
 * be modified, it was decided to write a similar API as the one provided by YouTube.
 *
 * @external RequireJS
 *
 * @module HTML5Video
 */

(function (requirejs, require, define) {

define(
'video/02_html5_video.js',
[],
function () {
    var HTML5Video = {};

    HTML5Video.Player = (function () {
        Player.prototype.callStateChangeCallback = function () {
            if ($.isFunction(this.config.events.onStateChange)) {
                this.config.events.onStateChange({
                    data: this.playerState
                });
            }
        };

        Player.prototype.pauseVideo = function () {
            this.video.pause();
        };

        Player.prototype.seekTo = function (value) {
            if ((typeof value === 'number') && (value <= this.video.duration) && (value >= 0)) {
                this.start = 0;
                this.end = this.video.duration;

                this.video.currentTime = value;
            }
        };

        Player.prototype.setVolume = function (value) {
            if ((typeof value === 'number') && (value <= 100) && (value >= 0)) {
                this.video.volume = value * 0.01;
            }
        };

        Player.prototype.getCurrentTime = function () {
            return this.video.currentTime;
        };

        Player.prototype.playVideo = function () {
            this.video.play();
        };

        Player.prototype.getPlayerState = function () {
            return this.playerState;
        };

        Player.prototype.getVolume = function () {
            return this.video.volume;
        };

        Player.prototype.getDuration = function () {
            if (isNaN(this.video.duration)) {
                return 0;
            }

            return this.video.duration;
        };

        Player.prototype.setPlaybackRate = function (value) {
            var newSpeed;

            newSpeed = parseFloat(value);

            if (isFinite(newSpeed)) {
                if (this.video.playbackRate !== value) {
                    this.video.playbackRate = value;
                }
            }
        };

        Player.prototype.getAvailablePlaybackRates = function () {
            return [0.75, 1.0, 1.25, 1.5];
        };

        return Player;

        /*
         * Constructor function for HTML5 Video player.
         *
         * @param {String|Object} el A DOM element where the HTML5 player will be inserted (as returned by jQuery(selector) function),
         * or a selector string which will be used to select an element. This is a required parameter.
         *
         * @param config - An object whose properties will be used as configuration options for the HTML5 video
         * player. This is an optional parameter. In the case if this parameter is missing, or some of the config
         * object's properties are missing, defaults will be used. The available options (and their defaults) are as
         * follows:
         *
         *     config = {
         *
         *        videoSources: {},   // An object with properties being video sources. The property name is the
         *                               // video format of the source. Supported video formats are: 'mp4', 'webm', and
         *                               // 'ogg'.
         *
         *          playerVars: {     // Object's properties identify player parameters.
         *              start: 0,     // Possible values: positive integer. Position from which to start playing the
         *                              // video. Measured in seconds. If value is non-numeric, or 'start' property is
         *                              // not specified, the video will start playing from the beginning.
         *
         *              end: null     // Possible values: positive integer. Position when to stop playing the
         *                              // video. Measured in seconds. If value is null, or 'end' property is not
         *                              // specified, the video will end playing at the end.
         *
         *          },
         *
         *          events: {         // Object's properties identify the events that the API fires, and the
         *                              // functions (event listeners) that the API will call when those events occur.
         *                              // If value is null, or property is not specified, then no callback will be
         *                              // called for that event.
         *
         *              onReady: null,
         *              onStateChange: null
         *          }
         *     }
         */
        function Player(el, config) {
            var sourceStr, _this, errorMessage;

            // Initially we assume that el is a DOM element. If jQuery selector fails to select something, we
            // assume that el is an ID of a DOM element. We try to select by ID. If jQuery fails this time,
            // we return. Nothing breaks because the player 'onReady' event will never be fired.

            this.el = $(el);
            if (this.el.length === 0) {
                this.el = $('#' + el);

                if (this.el.length === 0) {
                    errorMessage = 'VideoPlayer: Element corresponding to the given selector does not found.';
                    if (window.console && console.log) {
                        console.log(errorMessage);
                    } else {
                        throw new Error(errorMessage);
                    }
                    return;
                }
            }

            // A simple test to see that the 'config' is a normal object.
            if ($.isPlainObject(config)) {
                this.config = config;
            } else {
                return;
            }

            // We should have at least one video source. Otherwise there is no point to continue.
            if (!config.videoSources) {
                return;
            }

            // From the start, all sources are empty. We will populate this object below.
            sourceStr = {
                mp4: ' ',
                webm: ' ',
                ogg: ' '
            };

            // Will be used in inner functions to point to the current object.
            _this = this;

            // Create HTML markup for individual sources of the HTML5 <video> element.
            $.each(sourceStr, function (videoType, videoSource) {
                if (
                    (_this.config.videoSources[videoType]) &&
                    (_this.config.videoSources[videoType].length)
                ) {
                    sourceStr[videoType] =
                        '<source ' +
                            'src="' + _this.config.videoSources[videoType] + '" ' +
                            'type="video/' + videoType + '" ' +
                        '/> ';
                }
            });

            // We should have at least one video source. Otherwise there is no point to continue.
            if ((sourceStr.mp4 === ' ') && (sourceStr.webm === ' ') && (sourceStr.ogg === ' ')) {
                return;
            }

            // Determine the starting and ending time for the video.
            this.start = 0;
            this.end = null;
            if (config.playerVars) {
                this.start = parseFloat(config.playerVars.start);
                if ((!isFinite(this.start)) || (this.start < 0)) {
                    this.start = 0;
                }

                this.end = parseFloat(config.playerVars.end);
                if ((!isFinite(this.end)) || (this.end < this.start)) {
                    this.end = null;
                }
            }

            // Create HTML markup for the <video> element, populating it with sources from previous step.
            // Because of problems with creating video element via jquery
            // (http://bugs.jquery.com/ticket/9174) we create it using native JS.
            this.video = document.createElement('video');
            this.video.innerHTML = _.values(sourceStr).join('');

            // Get the jQuery object, and set the player state to UNSTARTED.
            // The player state is used by other parts of the VideoPlayer to detrermine what the video is
            // currently doing.
            this.videoEl = $(this.video);

            this.videoEl.css({
                'width': '100%'
            });

            this.playerState = HTML5Video.PlayerState.UNSTARTED;
            // this.callStateChangeCallback();

            // Attach a 'click' event on the <video> element. It will cause the video to pause/play.
            this.videoEl.on('click', function (event) {
                if (_this.playerState === HTML5Video.PlayerState.PAUSED) {
                    _this.video.play();
                    _this.playerState = HTML5Video.PlayerState.PLAYING;
                    _this.callStateChangeCallback();
                } else if (_this.playerState === HTML5Video.PlayerState.PLAYING) {
                    _this.video.pause();
                    _this.playerState = HTML5Video.PlayerState.PAUSED;
                    _this.callStateChangeCallback();
                }
            });

            // When the <video> tag has been processed by the browser, and it is ready for playback,
            // notify other parts of the VideoPlayer, and initially pause the video.
            //
            // Also, at this time we can get the real duration of the video. Update the starting end ending
            // points of the video. Note that first time, the video will start playing at the specified start time,
            // and end playing at the specified end time. After it was paused, or when a seek operation happeded,
            // the starting time and ending time will reset to the beginning and the end of the video respectively.
            this.video.addEventListener('canplay', function () {
                // Because firefox triggers 'canplay' event every time when 'currentTime' property
                // changes, we must make sure that this block of code runs only once. Otherwise,
                // this will be an endless loop ('currentTime' property is changed below).
                //
                // Chrome is immune to this behavior.
                if (_this.playerState !== HTML5Video.PlayerState.UNSTARTED) {
                    return;
                }

                _this.playerState = HTML5Video.PlayerState.PAUSED;

                if (_this.start > _this.video.duration) {
                    _this.start = 0;
                }
                if ((_this.end === null) || (_this.end > _this.video.duration)) {
                    _this.end = _this.video.duration;
                }
                _this.video.currentTime = _this.start;

                if ($.isFunction(_this.config.events.onReady)) {
                    _this.config.events.onReady(null);
                }
            }, false);

            // Register the 'play' event.
            this.video.addEventListener('play', function () {
                _this.playerState = HTML5Video.PlayerState.PLAYING;
                _this.callStateChangeCallback();
            }, false);

            // Register the 'pause' event.
            this.video.addEventListener('pause', function () {
                _this.playerState = HTML5Video.PlayerState.PAUSED;
                _this.callStateChangeCallback();
            }, false);

            // Register the 'ended' event.
            this.video.addEventListener('ended', function () {
                _this.playerState = HTML5Video.PlayerState.ENDED;
                _this.callStateChangeCallback();
            }, false);

            // Register the 'timeupdate' event. This is the place where we control when the video ends.
            // If an ending time was specified, then after the video plays through to this spot, pauses, we
            // must make sure to update the ending time to the end of the video. This way, the user can watch
            // any parts of it afterwards.
            this.video.addEventListener('timeupdate', function (data) {
                if (_this.end < _this.video.currentTime) {
                    // When we call video.pause(), a 'pause' event will be formed, and we will catch it
                    // in another handler (see above).
                    _this.video.pause();
                    _this.end = _this.video.duration;
                }
            }, false);

            // Place the <video> element on the page.
            this.videoEl.appendTo(this.el.find('.video-player div'));
        }
    }());

    // The YouTube API presents several constants which describe the player's state at a given moment.
    // HTML5Video API will copy these constats so that code which uses both the YouTube API and this API
    // doesn't have to change.
    HTML5Video.PlayerState = {
        UNSTARTED: -1,
        ENDED: 0,
        PLAYING: 1,
        PAUSED: 2,
        BUFFERING: 3,
        CUED: 5
    };

    // HTML5Video object - what this module exports.
    return HTML5Video;
})

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.PeerGrading = (function() {
    PeerGrading.prototype.peer_grading_sel = '.peer-grading';

    PeerGrading.prototype.peer_grading_container_sel = '.peer-grading-container';

    PeerGrading.prototype.error_container_sel = '.error-container';

    PeerGrading.prototype.message_container_sel = '.message-container';

    PeerGrading.prototype.problem_button_sel = '.problem-button';

    PeerGrading.prototype.problem_list_sel = '.problem-list';

    PeerGrading.prototype.progress_bar_sel = '.progress-bar';

    function PeerGrading(element) {
      this.activate_problem = __bind(this.activate_problem, this);
      this.show_results = __bind(this.show_results, this);
      this.construct_progress_bar = __bind(this.construct_progress_bar, this);
      this.el = element;
      this.peer_grading_container = this.$(this.peer_grading_sel);
      this.use_single_location = this.peer_grading_container.data('use-single-location');
      this.peer_grading_outer_container = this.$(this.peer_grading_container_sel);
      this.ajax_url = this.peer_grading_container.data('ajax-url');
      if (this.use_single_location.toLowerCase() === "true") {
        this.activate_problem();
      } else {
        this.error_container = this.$(this.error_container_sel);
        this.error_container.toggle(!this.error_container.is(':empty'));
        this.message_container = this.$(this.message_container_sel);
        this.message_container.toggle(!this.message_container.is(':empty'));
        this.problem_button = this.$(this.problem_button_sel);
        this.problem_button.click(this.show_results);
        this.problem_list = this.$(this.problem_list_sel);
        this.construct_progress_bar();
      }
    }

    PeerGrading.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    PeerGrading.prototype.construct_progress_bar = function() {
      var problems,
        _this = this;
      problems = this.problem_list.find('tr').next();
      return problems.each(function(index, element) {
        var bar_max, bar_value, problem, progress_bar;
        problem = $(element);
        progress_bar = problem.find(_this.progress_bar_sel);
        bar_value = parseInt(problem.data('graded'));
        bar_max = parseInt(problem.data('required')) + bar_value;
        return progress_bar.progressbar({
          value: bar_value,
          max: bar_max
        });
      });
    };

    PeerGrading.prototype.show_results = function(event) {
      var data, location_to_fetch,
        _this = this;
      location_to_fetch = $(event.target).data('location');
      data = {
        'location': location_to_fetch
      };
      return $.postWithPrefix("" + this.ajax_url + "problem", data, function(response) {
        var backend;
        if (response.success) {
          _this.peer_grading_outer_container.after(response.html).remove();
          backend = new PeerGradingProblemBackend(_this.ajax_url, false);
          return new PeerGradingProblem(backend, _this.el);
        } else {
          return _this.gentle_alert(response.error);
        }
      });
    };

    PeerGrading.prototype.activate_problem = function() {
      var backend;
      backend = new PeerGradingProblemBackend(this.ajax_url, false);
      return new PeerGradingProblem(backend, this.el);
    };

    return PeerGrading;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  this.JavascriptLoader = (function() {
    function JavascriptLoader() {}

    JavascriptLoader.executeModuleScripts = function(el, callback) {
      var callbackCalled, completed, completionHandlerGenerator, completionHandlerGeneratorIE, i, loaded, placeholders,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      placeholders = el.find(".script_placeholder");
      if (placeholders.length === 0) {
        if (callback != null) {
          callback();
        }
        return;
      }
      completed = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = placeholders.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(false);
        }
        return _results;
      })();
      callbackCalled = false;
      completionHandlerGeneratorIE = function(index) {
        return function() {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            return completionHandlerGenerator(index)();
          }
        };
      };
      completionHandlerGenerator = function(index) {
        return function() {
          var allComplete, flag, _i, _len;
          allComplete = true;
          completed[index] = true;
          for (_i = 0, _len = completed.length; _i < _len; _i++) {
            flag = completed[_i];
            if (!flag) {
              allComplete = false;
              break;
            }
          }
          if (allComplete && !callbackCalled) {
            callbackCalled = true;
            if (callback != null) {
              return callback();
            }
          }
        };
      };
      loaded = {};
      return placeholders.each(function(index, placeholder) {
        var s, src;
        src = $(placeholder).attr("data-src");
        if (!(src in loaded)) {
          loaded[src] = true;
          s = document.createElement('script');
          s.setAttribute('src', src);
          s.setAttribute('type', "text/javascript");
          s.onload = completionHandlerGenerator(index);
          s.onreadystatechange = completionHandlerGeneratorIE(index);
          $('head')[0].appendChild(s);
        } else {
          completionHandlerGenerator(index)();
        }
        return $(placeholder).remove();
      });
    };

    return JavascriptLoader;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.Problem = (function() {
    var _this = this;

    function Problem(element) {
      this.refreshAnswers = __bind(this.refreshAnswers, this);
      this.updateMathML = __bind(this.updateMathML, this);
      this.refreshMath = __bind(this.refreshMath, this);
      this.save = __bind(this.save, this);
      this.gentle_alert = __bind(this.gentle_alert, this);
      this.show = __bind(this.show, this);
      this.reset = __bind(this.reset, this);
      this.check = __bind(this.check, this);
      this.check_fd = __bind(this.check_fd, this);
      this.check_waitfor = __bind(this.check_waitfor, this);
      this.setupInputTypes = __bind(this.setupInputTypes, this);
      this.poll = __bind(this.poll, this);
      this.get_queuelen = __bind(this.get_queuelen, this);
      this.queueing = __bind(this.queueing, this);
      this.forceUpdate = __bind(this.forceUpdate, this);
      this.updateProgress = __bind(this.updateProgress, this);
      this.renderProgressState = __bind(this.renderProgressState, this);
      this.bind = __bind(this.bind, this);
      this.el = $(element).find('.problems-wrapper');
      this.id = this.el.data('problem-id');
      this.element_id = this.el.attr('id');
      this.url = this.el.data('url');
      this.render();
    }

    Problem.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Problem.prototype.bind = function() {
      var problem_prefix,
        _this = this;
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        this.el.find('.problem > div').each(function(index, element) {
          return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
        });
      }
      window.update_schematics();
      problem_prefix = this.element_id.replace(/problem_/, '');
      this.inputs = this.$("[id^=input_" + problem_prefix + "_]");
      this.$('section.action input:button').click(this.refreshAnswers);
      this.$('section.action input.check').click(this.check_fd);
      this.$('section.action input.reset').click(this.reset);
      this.$('section.action button.show').click(this.show);
      this.$('section.action input.save').click(this.save);
      this.bindResetCorrectness();
      Collapsible.setCollapsibles(this.el);
      this.$('input.math').keyup(this.refreshMath);
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        return this.$('input.math').each(function(index, element) {
          return MathJax.Hub.Queue([_this.refreshMath, null, element]);
        });
      }
    };

    Problem.prototype.renderProgressState = function() {
      var a, detail, possible, progress, status;
      detail = this.el.data('progress_detail');
      status = this.el.data('progress_status');
      progress = "(" + detail + " points)";
      if (status === 'none' && (detail != null) && detail.indexOf('/') > 0) {
        a = detail.split('/');
        possible = parseFloat(a[1]);
        if (possible === 1) {
          progress = "(" + possible + " point possible)";
        } else {
          progress = "(" + possible + " points possible)";
        }
      }
      return this.$('.problem-progress').html(progress);
    };

    Problem.prototype.updateProgress = function(response) {
      if (response.progress_changed) {
        this.el.data('progress_status', response.progress_status);
        this.el.data('progress_detail', response.progress_detail);
        this.el.trigger('progressChanged');
      }
      return this.renderProgressState();
    };

    Problem.prototype.forceUpdate = function(response) {
      this.el.data('progress_status', response.progress_status);
      this.el.data('progress_detail', response.progress_detail);
      this.el.trigger('progressChanged');
      return this.renderProgressState();
    };

    Problem.prototype.queueing = function() {
      var queuelen;
      this.queued_items = this.$(".xqueue");
      this.num_queued_items = this.queued_items.length;
      if (this.num_queued_items > 0) {
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
        }
        queuelen = this.get_queuelen();
        return window.queuePollerID = window.setTimeout(this.poll, queuelen * 10);
      }
    };

    Problem.prototype.get_queuelen = function() {
      var minlen;
      minlen = Infinity;
      this.queued_items.each(function(index, qitem) {
        var len;
        len = parseInt($.text(qitem));
        if (len < minlen) {
          return minlen = len;
        }
      });
      return minlen;
    };

    Problem.prototype.poll = function() {
      var _this = this;
      return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
        _this.new_queued_items = $(response.html).find(".xqueue");
        if (_this.new_queued_items.length !== _this.num_queued_items) {
          _this.el.html(response.html);
          JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            return _this.bind();
          });
        }
        _this.num_queued_items = _this.new_queued_items.length;
        if (_this.num_queued_items === 0) {
          _this.forceUpdate(response);
          return delete window.queuePollerID;
        } else {
          return window.queuePollerID = window.setTimeout(_this.poll, 1000);
        }
      });
    };

    Problem.inputAjax = function(url, input_id, dispatch, data, callback) {
      data['dispatch'] = dispatch;
      data['input_id'] = input_id;
      return $.postWithPrefix("" + url + "/input_ajax", data, callback);
    };

    Problem.prototype.render = function(content) {
      var _this = this;
      if (content) {
        this.el.html(content);
        return JavascriptLoader.executeModuleScripts(this.el, function() {
          _this.setupInputTypes();
          _this.bind();
          return _this.queueing();
        });
      } else {
        return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
          _this.el.html(response.html);
          return JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            _this.bind();
            _this.queueing();
            return _this.forceUpdate(response);
          });
        });
      }
    };

    Problem.prototype.setupInputTypes = function() {
      var _this = this;
      this.inputtypeDisplays = {};
      return this.el.find(".capa_inputtype").each(function(index, inputtype) {
        var classes, cls, id, setupMethod, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        id = $(inputtype).attr('id');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          setupMethod = _this.inputtypeSetupMethods[cls];
          if (setupMethod != null) {
            _results.push(_this.inputtypeDisplays[id] = setupMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Problem.prototype.check_waitfor = function() {
      var e, inp, _i, _len, _ref, _results;
      _ref = this.inputs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inp = _ref[_i];
        if ($(inp).is("input[waitfor]")) {
          try {
            $(inp).data("waitfor")();
            _results.push(this.refreshAnswers());
          } catch (_error) {
            e = _error;
            if (e.name === "Waitfor Exception") {
              alert(e.message);
            } else {
              alert("Could not grade your answer. The submission was aborted.");
            }
            throw e;
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    /*
    # 'check_fd' uses FormData to allow file submissions in the 'problem_check' dispatch,
    #      in addition to simple querystring-based answers
    #
    # NOTE: The dispatch 'problem_check' is being singled out for the use of FormData;
    #       maybe preferable to consolidate all dispatches to use FormData
    */


    Problem.prototype.check_fd = function() {
      var abort_submission, error, error_html, errors, fd, file_not_selected, file_too_large, max_filesize, required_files_not_submitted, settings, unallowed_file_submitted, _i, _len,
        _this = this;
      if ($('input:file').length === 0) {
        this.check();
        return;
      }
      if (!window.FormData) {
        alert("Submission aborted! Sorry, your browser does not support file uploads. If you can, please use Chrome or Safari which have been verified to support file uploads.");
        return;
      }
      fd = new FormData();
      max_filesize = 4 * 1000 * 1000;
      file_too_large = false;
      file_not_selected = false;
      required_files_not_submitted = false;
      unallowed_file_submitted = false;
      errors = [];
      this.inputs.each(function(index, element) {
        var allowed_files, file, required_files, _i, _len, _ref, _ref1, _ref2;
        if (element.type === 'file') {
          required_files = $(element).data("required_files");
          allowed_files = $(element).data("allowed_files");
          _ref = element.files;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            if (allowed_files.length !== 0 && (_ref1 = file.name, __indexOf.call(allowed_files, _ref1) < 0)) {
              unallowed_file_submitted = true;
              errors.push("You submitted " + file.name + "; only " + allowed_files + " are allowed.");
            }
            if (_ref2 = file.name, __indexOf.call(required_files, _ref2) >= 0) {
              required_files.splice(required_files.indexOf(file.name), 1);
            }
            if (file.size > max_filesize) {
              file_too_large = true;
              errors.push('Your file "' + file.name('" is too large (max size: ' + max_filesize / (1000 * 1000) + ' MB)'));
            }
            fd.append(element.id, file);
          }
          if (element.files.length === 0) {
            file_not_selected = true;
            fd.append(element.id, '');
          }
          if (required_files.length !== 0) {
            required_files_not_submitted = true;
            return errors.push("You did not submit the required files: " + required_files + ".");
          }
        } else {
          return fd.append(element.id, element.value);
        }
      });
      if (file_not_selected) {
        errors.push('You did not select any files to submit');
      }
      error_html = '<ul>\n';
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        error = errors[_i];
        error_html += '<li>' + error + '</li>\n';
      }
      error_html += '</ul>';
      this.gentle_alert(error_html);
      abort_submission = file_too_large || file_not_selected || unallowed_file_submitted || required_files_not_submitted;
      settings = {
        type: "POST",
        data: fd,
        processData: false,
        contentType: false,
        success: function(response) {
          switch (response.success) {
            case 'incorrect':
            case 'correct':
              _this.render(response.contents);
              _this.updateProgress(response);
              break;
            default:
              _this.gentle_alert(response.success);
          }
          return Logger.log('problem_graded', [_this.answers, response.contents], _this.url);
        }
      };
      if (!abort_submission) {
        return $.ajaxWithPrefix("" + this.url + "/problem_check", settings);
      }
    };

    Problem.prototype.check = function() {
      var _this = this;
      this.check_waitfor();
      Logger.log('problem_check', this.answers);
      analytics.track("Problem Checked", {
        problem_id: this.id,
        answers: this.answers
      });
      return $.postWithPrefix("" + this.url + "/problem_check", this.answers, function(response) {
        switch (response.success) {
          case 'incorrect':
          case 'correct':
            _this.render(response.contents);
            _this.updateProgress(response);
            if (_this.el.hasClass('showed')) {
              _this.el.removeClass('showed');
            }
            break;
          default:
            _this.gentle_alert(response.success);
        }
        return Logger.log('problem_graded', [_this.answers, response.contents], _this.url);
      });
    };

    Problem.prototype.reset = function() {
      var _this = this;
      Logger.log('problem_reset', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_reset", {
        id: this.id
      }, function(response) {
        _this.render(response.html);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.show = function() {
      var _this = this;
      if (!this.el.hasClass('showed')) {
        Logger.log('problem_show', {
          problem: this.id
        });
        return $.postWithPrefix("" + this.url + "/problem_show", function(response) {
          var answers;
          answers = response.answers;
          $.each(answers, function(key, value) {
            var answer, choice, _i, _len, _results;
            if ($.isArray(value)) {
              _results = [];
              for (_i = 0, _len = value.length; _i < _len; _i++) {
                choice = value[_i];
                _results.push(_this.$("label[for='input_" + key + "_" + choice + "']").attr({
                  correct_answer: 'true'
                }));
              }
              return _results;
            } else {
              answer = _this.$("#answer_" + key + ", #solution_" + key);
              answer.html(value);
              return Collapsible.setCollapsibles(answer);
            }
          });
          _this.el.find(".capa_inputtype").each(function(index, inputtype) {
            var classes, cls, display, showMethod, _i, _len, _results;
            classes = $(inputtype).attr('class').split(' ');
            _results = [];
            for (_i = 0, _len = classes.length; _i < _len; _i++) {
              cls = classes[_i];
              display = _this.inputtypeDisplays[$(inputtype).attr('id')];
              showMethod = _this.inputtypeShowAnswerMethods[cls];
              if (showMethod != null) {
                _results.push(showMethod(inputtype, display, answers));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
          if (typeof MathJax !== "undefined" && MathJax !== null) {
            _this.el.find('.problem > div').each(function(index, element) {
              return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
            });
          }
          _this.$('.show-label').text('Hide Answer(s)');
          _this.el.addClass('showed');
          return _this.updateProgress(response);
        });
      } else {
        this.$('[id^=answer_], [id^=solution_]').text('');
        this.$('[correct_answer]').attr({
          correct_answer: null
        });
        this.el.removeClass('showed');
        this.$('.show-label').text('Show Answer(s)');
        return this.el.find(".capa_inputtype").each(function(index, inputtype) {
          var classes, cls, display, hideMethod, _i, _len, _results;
          display = _this.inputtypeDisplays[$(inputtype).attr('id')];
          classes = $(inputtype).attr('class').split(' ');
          _results = [];
          for (_i = 0, _len = classes.length; _i < _len; _i++) {
            cls = classes[_i];
            hideMethod = _this.inputtypeHideAnswerMethods[cls];
            if (hideMethod != null) {
              _results.push(hideMethod(inputtype, display));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      }
    };

    Problem.prototype.gentle_alert = function(msg) {
      var alert_elem;
      if (this.el.find('.capa_alert').length) {
        this.el.find('.capa_alert').remove();
      }
      alert_elem = "<div class='capa_alert'>" + msg + "</div>";
      this.el.find('.action').after(alert_elem);
      return this.el.find('.capa_alert').css({
        opacity: 0
      }).animate({
        opacity: 1
      }, 700);
    };

    Problem.prototype.save = function() {
      var _this = this;
      Logger.log('problem_save', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_save", this.answers, function(response) {
        var saveMessage;
        saveMessage = response.msg;
        _this.gentle_alert(saveMessage);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.refreshMath = function(event, element) {
      var elid, eqn, jax, mathjax_preprocessor, preprocessor_tag, target;
      if (!element) {
        element = event.target;
      }
      elid = element.id.replace(/^input_/, '');
      target = "display_" + elid;
      preprocessor_tag = "inputtype_" + elid;
      mathjax_preprocessor = this.inputtypeDisplays[preprocessor_tag];
      if ((typeof MathJax !== "undefined" && MathJax !== null) && (jax = MathJax.Hub.getAllJax(target)[0])) {
        eqn = $(element).val();
        if (mathjax_preprocessor) {
          eqn = mathjax_preprocessor(eqn);
        }
        MathJax.Hub.Queue(['Text', jax, eqn], [this.updateMathML, jax, element]);
      }
    };

    Problem.prototype.updateMathML = function(jax, element) {
      var exception;
      try {
        return $("#" + element.id + "_dynamath").val(jax.root.toMathML(''));
      } catch (_error) {
        exception = _error;
        if (!exception.restart) {
          throw exception;
        }
        if (typeof MathJax !== "undefined" && MathJax !== null) {
          return MathJax.Callback.After([this.refreshMath, jax], exception.restart);
        }
      }
    };

    Problem.prototype.refreshAnswers = function() {
      this.$('input.schematic').each(function(index, element) {
        return element.schematic.update_value();
      });
      this.$(".CodeMirror").each(function(index, element) {
        if (element.CodeMirror.save) {
          return element.CodeMirror.save();
        }
      });
      return this.answers = this.inputs.serialize();
    };

    Problem.prototype.bindResetCorrectness = function() {
      var $inputtypes,
        _this = this;
      $inputtypes = this.el.find(".capa_inputtype").add(this.el.find(".inputtype"));
      return $inputtypes.each(function(index, inputtype) {
        var bindMethod, classes, cls, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          bindMethod = _this.bindResetCorrectnessByInputtype[cls];
          if (bindMethod != null) {
            _results.push(bindMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    Problem.prototype.bindResetCorrectnessByInputtype = {
      formulaequationinput: function(element) {
        return $(element).find('input').on('input', function() {
          var $p;
          $p = $(element).find('p.status');
          $p.text(gettext("unanswered"));
          return $p.parent().removeClass().addClass("unanswered");
        });
      },
      choicegroup: function(element) {
        var $element, id;
        $element = $(element);
        id = ($element.attr('id').match(/^inputtype_(.*)$/))[1];
        return $element.find('input').on('change', function() {
          var $status;
          $status = $("#status_" + id);
          if ($status[0]) {
            $status.removeClass().addClass("unanswered");
            $status.empty().css('display', 'inline-block');
          } else {
            $("<span>", {
              "class": "unanswered",
              "style": "display: inline-block;",
              "id": "status_" + id
            });
          }
          return $element.find("label").removeClass();
        });
      },
      'option-input': function(element) {
        var $select, id;
        $select = $(element).find('select');
        id = ($select.attr('id').match(/^input_(.*)$/))[1];
        return $select.on('change', function() {
          var $status;
          return $status = $("#status_" + id).removeClass().addClass("unanswered").find('span').text(gettext('Status: unsubmitted'));
        });
      },
      textline: function(element) {
        return $(element).find('input').on('input', function() {
          var $p;
          $p = $(element).find('p.status');
          $p.text("unanswered");
          return $p.parent().removeClass().addClass("unanswered");
        });
      }
    };

    Problem.prototype.inputtypeSetupMethods = {
      'text-input-dynamath': function(element) {
        /*
        Return: function (eqn) -> eqn that preprocesses the user formula input before
                  it is fed into MathJax. Return 'false' if no preprocessor specified
        */

        var data, preprocessor, preprocessorClass, preprocessorClassName;
        data = $(element).find('.text-input-dynamath_data');
        preprocessorClassName = data.data('preprocessor');
        preprocessorClass = window[preprocessorClassName];
        if (preprocessorClass == null) {
          return false;
        } else {
          preprocessor = new preprocessorClass();
          return preprocessor.fn;
        }
      },
      javascriptinput: function(element) {
        var container, data, display, displayClass, evaluation, params, problemState, submission, submissionField;
        data = $(element).find(".javascriptinput_data");
        params = data.data("params");
        submission = data.data("submission");
        evaluation = data.data("evaluation");
        problemState = data.data("problem_state");
        displayClass = window[data.data('display_class')];
        if (evaluation === '') {
          evaluation = null;
        }
        container = $(element).find(".javascriptinput_container");
        submissionField = $(element).find(".javascriptinput_input");
        display = new displayClass(problemState, submission, evaluation, container, submissionField, params);
        display.render();
        return display;
      }
    };

    Problem.prototype.inputtypeShowAnswerMethods = {
      choicegroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("label[for='input_" + input_id + "_" + choice + "']").addClass('choicegroup_correct'));
        }
        return _results;
      },
      javascriptinput: function(element, display, answers) {
        var answer, answer_id;
        answer_id = $(element).attr('id').split("_").slice(1).join("_");
        answer = JSON.parse(answers[answer_id]);
        return display.showAnswer(answer);
      },
      choicetextgroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("section#forinput" + choice).addClass('choicetextgroup_show_correct'));
        }
        return _results;
      }
    };

    Problem.prototype.inputtypeHideAnswerMethods = {
      choicegroup: function(element, display) {
        element = $(element);
        return element.find('label').removeClass('choicegroup_correct');
      },
      javascriptinput: function(element, display) {
        return display.hideAnswer();
      },
      choicetextgroup: function(element, display) {
        element = $(element);
        return element.find("section[id^='forinput']").removeClass('choicetextgroup_show_correct');
      }
    };

    return Problem;

  }).call(this);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Sequence = (function() {
    function Sequence(element) {
      this.previous = __bind(this.previous, this);
      this.next = __bind(this.next, this);
      this.goto = __bind(this.goto, this);
      this.toggleArrows = __bind(this.toggleArrows, this);
      this.updateProgress = __bind(this.updateProgress, this);
      this.el = $(element).find('.sequence');
      this.contents = this.$('.seq_contents');
      this.num_contents = this.contents.length;
      this.id = this.el.data('id');
      this.modx_url = this.el.data('course_modx_root');
      this.initProgress();
      this.bind();
      this.render(parseInt(this.el.data('position')));
    }

    Sequence.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Sequence.prototype.bind = function() {
      return this.$('#sequence-list a').click(this.goto);
    };

    Sequence.prototype.initProgress = function() {
      return this.progressTable = {};
    };

    Sequence.prototype.hookUpProgressEvent = function() {
      return $('.problems-wrapper').bind('progressChanged', this.updateProgress);
    };

    Sequence.prototype.mergeProgress = function(p1, p2) {
      var w1, w2;
      if (p1 === "NA") {
        return p2;
      }
      if (p2 === "NA") {
        return p1;
      }
      if (p1 === "done" && p2 === "done") {
        return "done";
      }
      w1 = p1 === "done" || p1 === "in_progress";
      w2 = p2 === "done" || p2 === "in_progress";
      if (w1 || w2) {
        return "in_progress";
      }
      return "none";
    };

    Sequence.prototype.updateProgress = function() {
      var new_progress, _this;
      new_progress = "NA";
      _this = this;
      $('.problems-wrapper').each(function(index) {
        var progress;
        progress = $(this).data('progress_status');
        return new_progress = _this.mergeProgress(progress, new_progress);
      });
      this.progressTable[this.position] = new_progress;
      return this.setProgress(new_progress, this.link_for(this.position));
    };

    Sequence.prototype.setProgress = function(progress, element) {
      element.removeClass('progress-none').removeClass('progress-some').removeClass('progress-done');
      switch (progress) {
        case 'none':
          return element.addClass('progress-none');
        case 'in_progress':
          return element.addClass('progress-some');
        case 'done':
          return element.addClass('progress-done');
      }
    };

    Sequence.prototype.toggleArrows = function() {
      this.$('.sequence-nav-buttons a').unbind('click');
      if (this.contents.length === 0) {
        this.$('.sequence-nav-buttons .prev a').addClass('disabled');
        this.$('.sequence-nav-buttons .next a').addClass('disabled');
        return;
      }
      if (this.position === 1) {
        this.$('.sequence-nav-buttons .prev a').addClass('disabled');
      } else {
        this.$('.sequence-nav-buttons .prev a').removeClass('disabled').click(this.previous);
      }
      if (this.position === this.contents.length) {
        return this.$('.sequence-nav-buttons .next a').addClass('disabled');
      } else {
        return this.$('.sequence-nav-buttons .next a').removeClass('disabled').click(this.next);
      }
    };

    Sequence.prototype.render = function(new_position) {
      var modx_full_url, sequence_links;
      if (this.position !== new_position) {
        if (this.position !== void 0) {
          this.mark_visited(this.position);
          modx_full_url = this.modx_url + '/' + this.id + '/goto_position';
          $.postWithPrefix(modx_full_url, {
            position: new_position
          });
        }
        this.el.trigger("sequence:change");
        this.mark_active(new_position);
        this.$('#seq_content').html(this.contents.eq(new_position - 1).text());
        XModule.loadModules(this.$('#seq_content'));
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, "seq_content"]);
        window.update_schematics();
        this.position = new_position;
        this.toggleArrows();
        this.hookUpProgressEvent();
        sequence_links = this.$('#seq_content a.seqnav');
        return sequence_links.click(this.goto);
      }
    };

    Sequence.prototype.goto = function(event) {
      var new_position;
      event.preventDefault();
      if ($(event.target).hasClass('seqnav')) {
        new_position = $(event.target).attr('href');
      } else {
        new_position = $(event.target).data('element');
      }
      if ((1 <= new_position) && (new_position <= this.num_contents)) {
        Logger.log("seq_goto", {
          old: this.position,
          "new": new_position,
          id: this.id
        });
        analytics.pageview(this.id);
        analytics.track("Accessed Sequential Directly", {
          sequence_id: this.id,
          current_sequential: this.position,
          target_sequential: new_position
        });
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
          delete window.queuePollerID;
        }
        return this.render(new_position);
      } else {
        return alert('Sequence error! Cannot navigate to tab ' + new_position + 'in the current SequenceModule. Please contact the course staff.');
      }
    };

    Sequence.prototype.next = function(event) {
      var new_position;
      event.preventDefault();
      new_position = this.position + 1;
      Logger.log("seq_next", {
        old: this.position,
        "new": new_position,
        id: this.id
      });
      analytics.pageview(this.id);
      analytics.track("Accessed Next Sequential", {
        sequence_id: this.id,
        current_sequential: this.position,
        target_sequential: new_position
      });
      return this.render(new_position);
    };

    Sequence.prototype.previous = function(event) {
      var new_position;
      event.preventDefault();
      new_position = this.position - 1;
      Logger.log("seq_prev", {
        old: this.position,
        "new": new_position,
        id: this.id
      });
      analytics.pageview(this.id);
      analytics.track("Accessed Previous Sequential", {
        sequence_id: this.id,
        current_sequential: this.position,
        target_sequential: new_position
      });
      return this.render(new_position);
    };

    Sequence.prototype.link_for = function(position) {
      return this.$("#sequence-list a[data-element=" + position + "]");
    };

    Sequence.prototype.mark_visited = function(position) {
      var element;
      element = this.link_for(position);
      return element.removeClass("inactive").removeClass("active").addClass("visited");
    };

    Sequence.prototype.mark_active = function(position) {
      var element;
      element = this.link_for(position);
      return element.removeClass("inactive").removeClass("visited").addClass("active");
    };

    return Sequence;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Rubric = (function() {
    Rubric.prototype.rubric_category_sel = '.rubric-category';

    Rubric.prototype.rubric_sel = '.rubric';

    function Rubric(el) {
      this.check_complete = __bind(this.check_complete, this);
      this.get_total_score = __bind(this.get_total_score, this);
      this.get_score_list = __bind(this.get_score_list, this);
      this.tracking_callback = __bind(this.tracking_callback, this);
      this.keypress_callback = __bind(this.keypress_callback, this);
      this.initialize = __bind(this.initialize, this);
      this.el = el;
    }

    Rubric.prototype.initialize = function(location) {
      this.$(this.rubric_sel).data("location", location);
      this.$('input[class="score-selection"]').change(this.tracking_callback);
      $(window).unbind('keydown', this.keypress_callback);
      $(window).keydown(this.keypress_callback);
      this.categories = this.$(this.rubric_category_sel);
      this.category = this.$(this.categories.first());
      return this.category_index = 0;
    };

    Rubric.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Rubric.prototype.keypress_callback = function(event) {
      var inputs, max_score, selected;
      if (this.$(event.target).is('input, textarea')) {
        return;
      }
      if (event.which >= 48 && event.which <= 57) {
        selected = event.which - 48;
      } else if (event.which >= 96 && event.which <= 105) {
        selected = event.which - 96;
      } else {
        return;
      }
      if (this.category_index <= this.categories.length) {
        inputs = this.$("input[name='score-selection-" + this.category_index + "']");
        max_score = inputs.length - 1;
        if (selected > max_score || selected < 0) {
          return;
        }
        inputs.filter("input[value=" + selected + "]").click();
        this.category_index++;
        return this.category = this.$(this.categories[this.category_index]);
      }
    };

    Rubric.prototype.tracking_callback = function(event) {
      var category, data, location, target_selection;
      target_selection = this.$(event.target).val();
      category = this.$(event.target).data("category");
      location = this.$(this.rubric_sel).data('location');
      data = {
        location: location,
        selection: target_selection,
        category: category
      };
      return Logger.log('rubric_select', data);
    };

    Rubric.prototype.get_score_list = function() {
      var i, num_categories, score, score_lst, _i, _ref;
      num_categories = this.$(this.rubric_category_sel).length;
      score_lst = [];
      for (i = _i = 0, _ref = num_categories - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        score = this.$("input[name='score-selection-" + i + "']:checked").val();
        score_lst.push(score);
      }
      return score_lst;
    };

    Rubric.prototype.get_total_score = function() {
      var score, score_lst, tot, _i, _len;
      score_lst = this.get_score_list();
      tot = 0;
      for (_i = 0, _len = score_lst.length; _i < _len; _i++) {
        score = score_lst[_i];
        tot += parseInt(score);
      }
      return tot;
    };

    Rubric.prototype.check_complete = function() {
      var i, num_categories, score, _i, _ref;
      num_categories = this.$(this.rubric_category_sel).length;
      for (i = _i = 0, _ref = num_categories - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        score = this.$("input[name='score-selection-" + i + "']:checked").val();
        if (score === void 0) {
          return false;
        }
      }
      return true;
    };

    return Rubric;

  })();

  this.CombinedOpenEnded = (function() {
    CombinedOpenEnded.prototype.wrapper_sel = 'section.xmodule_CombinedOpenEndedModule';

    CombinedOpenEnded.prototype.coe_sel = 'section.combined-open-ended';

    CombinedOpenEnded.prototype.reset_button_sel = '.reset-button';

    CombinedOpenEnded.prototype.next_step_sel = '.next-step-button';

    CombinedOpenEnded.prototype.question_header_sel = '.question-header';

    CombinedOpenEnded.prototype.submit_evaluation_sel = '.submit-evaluation-button';

    CombinedOpenEnded.prototype.result_container_sel = 'div.result-container';

    CombinedOpenEnded.prototype.combined_rubric_sel = '.combined-rubric-container';

    CombinedOpenEnded.prototype.open_ended_child_sel = 'section.open-ended-child';

    CombinedOpenEnded.prototype.error_sel = '.error';

    CombinedOpenEnded.prototype.answer_area_sel = 'textarea.answer';

    CombinedOpenEnded.prototype.answer_area_div_sel = 'div.answer';

    CombinedOpenEnded.prototype.prompt_sel = '.prompt';

    CombinedOpenEnded.prototype.rubric_wrapper_sel = '.rubric-wrapper';

    CombinedOpenEnded.prototype.hint_wrapper_sel = '.hint-wrapper';

    CombinedOpenEnded.prototype.message_wrapper_sel = '.message-wrapper';

    CombinedOpenEnded.prototype.submit_button_sel = '.submit-button';

    CombinedOpenEnded.prototype.skip_button_sel = '.skip-button';

    CombinedOpenEnded.prototype.file_upload_sel = '.file-upload';

    CombinedOpenEnded.prototype.file_upload_box_sel = '.file-upload-box';

    CombinedOpenEnded.prototype.file_upload_preview_sel = '.file-upload-preview';

    CombinedOpenEnded.prototype.fof_sel = 'textarea.feedback-on-feedback';

    CombinedOpenEnded.prototype.sub_id_sel = 'input.submission_id';

    CombinedOpenEnded.prototype.grader_id_sel = 'input.grader_id';

    CombinedOpenEnded.prototype.grader_status_sel = '.grader-status';

    CombinedOpenEnded.prototype.info_rubric_elements_sel = '.rubric-info-item';

    CombinedOpenEnded.prototype.rubric_collapse_sel = '.rubric-collapse';

    CombinedOpenEnded.prototype.next_rubric_sel = '.rubric-next-button';

    CombinedOpenEnded.prototype.previous_rubric_sel = '.rubric-previous-button';

    CombinedOpenEnded.prototype.oe_alert_sel = '.open-ended-alert';

    function CombinedOpenEnded(el) {
      this.graded_callback = __bind(this.graded_callback, this);
      this.setup_score_selection = __bind(this.setup_score_selection, this);
      this.toggle_rubric = __bind(this.toggle_rubric, this);
      this.preview_image = __bind(this.preview_image, this);
      this.remove_attribute = __bind(this.remove_attribute, this);
      this.prompt_hide = __bind(this.prompt_hide, this);
      this.prompt_show = __bind(this.prompt_show, this);
      this.shift_rubric = __bind(this.shift_rubric, this);
      this.previous_rubric = __bind(this.previous_rubric, this);
      this.next_rubric = __bind(this.next_rubric, this);
      this.hide_rubrics = __bind(this.hide_rubrics, this);
      this.collapse_question = __bind(this.collapse_question, this);
      this.replace_text_inputs = __bind(this.replace_text_inputs, this);
      this.hide_file_upload = __bind(this.hide_file_upload, this);
      this.setup_file_upload = __bind(this.setup_file_upload, this);
      this.poll = __bind(this.poll, this);
      this.queueing = __bind(this.queueing, this);
      this.gentle_alert = __bind(this.gentle_alert, this);
      this.next_problem = __bind(this.next_problem, this);
      this.reset = __bind(this.reset, this);
      this.skip_post_assessment = __bind(this.skip_post_assessment, this);
      this.save_hint = __bind(this.save_hint, this);
      this.save_assessment = __bind(this.save_assessment, this);
      this.keyup_handler = __bind(this.keyup_handler, this);
      this.keydown_handler = __bind(this.keydown_handler, this);
      this.save_answer = __bind(this.save_answer, this);
      this.replace_answer = __bind(this.replace_answer, this);
      this.rebind = __bind(this.rebind, this);
      this.message_post = __bind(this.message_post, this);
      this.show_combined_rubric_current = __bind(this.show_combined_rubric_current, this);
      this.get_html = __bind(this.get_html, this);
      this.get_html_callback = __bind(this.get_html_callback, this);
      this.el = el;
      this.$el = $(el);
      this.reinitialize(el);
      $(window).keydown(this.keydown_handler);
      $(window).keyup(this.keyup_handler);
    }

    CombinedOpenEnded.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    CombinedOpenEnded.prototype.reinitialize = function() {
      this.has_been_reset = false;
      this.wrapper = this.$(this.wrapper_sel);
      this.coe = this.$(this.coe_sel);
      this.ajax_url = this.coe.data('ajax-url');
      this.get_html();
      this.coe = this.$(this.coe_sel);
      this.allow_reset = this.coe.data('allow_reset');
      this.id = this.coe.data('id');
      this.state = this.coe.data('state');
      this.task_count = this.coe.data('task-count');
      this.task_number = this.coe.data('task-number');
      this.accept_file_upload = this.coe.data('accept-file-upload');
      this.location = this.coe.data('location');
      this.rub = new Rubric(this.coe);
      this.rub.initialize(this.location);
      this.is_ctrl = false;
      this.reset_button = this.$(this.reset_button_sel);
      this.reset_button.click(this.reset);
      this.next_problem_button = this.$(this.next_step_sel);
      this.next_problem_button.click(this.next_problem);
      this.question_header = this.$(this.question_header_sel);
      this.question_header.click(this.collapse_question);
      Collapsible.setCollapsibles(this.$el);
      this.submit_evaluation_button = this.$(this.submit_evaluation_sel);
      this.submit_evaluation_button.click(this.message_post);
      this.results_container = this.$(this.result_container_sel);
      this.combined_rubric_container = this.$(this.combined_rubric_sel);
      this.oe = this.$(this.open_ended_child_sel);
      this.errors_area = this.$(this.oe).find(this.error_sel);
      this.answer_area = this.$(this.oe).find(this.answer_area_sel);
      this.prompt_container = this.$(this.oe).find(this.prompt_sel);
      this.rubric_wrapper = this.$(this.oe).find(this.rubric_wrapper_sel);
      this.hint_wrapper = this.$(this.oe).find(this.hint_wrapper_sel);
      this.message_wrapper = this.$(this.oe).find(this.message_wrapper_sel);
      this.submit_button = this.$(this.oe).find(this.submit_button_sel);
      this.child_state = this.oe.data('state');
      this.child_type = this.oe.data('child-type');
      if (this.child_type === "openended") {
        this.skip_button = this.$(this.oe).find(this.skip_button_sel);
        this.skip_button.click(this.skip_post_assessment);
      }
      this.file_upload_area = this.$(this.oe).find(this.file_upload_sel);
      this.can_upload_files = false;
      this.open_ended_child = this.$(this.oe).find(this.open_ended_child_sel);
      this.out_of_sync_message = 'The problem state got out of sync.  Try reloading the page.';
      if (this.task_number > 1) {
        this.prompt_hide();
      } else if (this.task_number === 1 && this.child_state !== 'initial') {
        this.prompt_hide();
      }
      this.find_assessment_elements();
      this.find_hint_elements();
      return this.rebind();
    };

    CombinedOpenEnded.prototype.get_html_callback = function(response) {
      return this.coe.replaceWith(response.html);
    };

    CombinedOpenEnded.prototype.get_html = function() {
      var url;
      url = "" + this.ajax_url + "/get_html";
      return $.ajaxWithPrefix({
        type: 'POST',
        url: url,
        data: {},
        success: this.get_html_callback,
        async: false
      });
    };

    CombinedOpenEnded.prototype.show_combined_rubric_current = function() {
      var data,
        _this = this;
      data = {};
      return $.postWithPrefix("" + this.ajax_url + "/get_combined_rubric", data, function(response) {
        if (response.success) {
          _this.combined_rubric_container.after(response.html).remove();
          _this.combined_rubric_container = _this.$(_this.combined_rubric_sel);
          _this.toggle_rubric("");
          _this.rubric_collapse = _this.$(_this.rubric_collapse_sel);
          _this.rubric_collapse.click(_this.toggle_rubric);
          _this.hide_rubrics();
          _this.$(_this.previous_rubric_sel).click(_this.previous_rubric);
          _this.$(_this.next_rubric_sel).click(_this.next_rubric);
          if (response.hide_reset) {
            return _this.reset_button.hide();
          }
        }
      });
    };

    CombinedOpenEnded.prototype.message_post = function(event) {
      var evaluation_scoring, external_grader_message, fd, feedback, grader_id, score, settings, submission_id,
        _this = this;
      external_grader_message = $(event.target).parent().parent().parent();
      evaluation_scoring = $(event.target).parent();
      fd = new FormData();
      feedback = this.$(evaluation_scoring).find(this.fof_sel)[0].value;
      submission_id = this.$(external_grader_message).find(this.sub_id_sel)[0].value;
      grader_id = this.$(external_grader_message).find(this.grader_id_sel)[0].value;
      score = this.$(evaluation_scoring).find("input:radio[name='evaluation-score']:checked").val();
      fd.append('feedback', feedback);
      fd.append('submission_id', submission_id);
      fd.append('grader_id', grader_id);
      if (!score) {
        this.gentle_alert("You need to pick a rating before you can submit.");
        return;
      } else {
        fd.append('score', score);
      }
      settings = {
        type: "POST",
        data: fd,
        processData: false,
        contentType: false,
        success: function(response) {
          _this.gentle_alert(response.msg);
          _this.$('section.evaluation').slideToggle();
          return _this.message_wrapper.html(response.message_html);
        }
      };
      return $.ajaxWithPrefix("" + this.ajax_url + "/save_post_assessment", settings);
    };

    CombinedOpenEnded.prototype.rebind = function() {
      this.submit_button.unbind('click');
      this.submit_button.show();
      this.reset_button.hide();
      this.hide_file_upload();
      this.next_problem_button.hide();
      this.hint_area.attr('disabled', false);
      if (this.task_number === 1 && this.child_state === 'assessing') {
        this.prompt_hide();
      }
      if (this.child_state === 'done') {
        this.rubric_wrapper.hide();
      }
      if (this.child_type === "openended") {
        this.skip_button.hide();
      }
      if (this.allow_reset === "True") {
        this.show_combined_rubric_current();
        this.reset_button.show();
        this.submit_button.hide();
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.hint_area.attr('disabled', true);
        if (this.task_number < this.task_count) {
          return this.gentle_alert("Your score did not meet the criteria to move to the next step.");
        }
      } else if (this.child_state === 'initial') {
        this.answer_area.attr("disabled", false);
        this.submit_button.prop('value', 'Submit');
        this.submit_button.click(this.save_answer);
        return this.setup_file_upload();
      } else if (this.child_state === 'assessing') {
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.hide_file_upload();
        this.submit_button.prop('value', 'Submit assessment');
        this.submit_button.click(this.save_assessment);
        this.submit_button.attr("disabled", true);
        if (this.child_type === "openended") {
          this.submit_button.hide();
          this.queueing();
          this.grader_status = this.$(this.grader_status_sel);
          return this.grader_status.html("<span class='grading'>Your response has been submitted.  Please check back later for your grade.</span> ");
        } else if (this.child_type === "selfassessment") {
          return this.setup_score_selection();
        }
      } else if (this.child_state === 'post_assessment') {
        if (this.child_type === "openended") {
          this.skip_button.show();
          this.skip_post_assessment();
        }
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.submit_button.prop('value', 'Submit post-assessment');
        if (this.child_type === "selfassessment") {
          return this.submit_button.click(this.save_hint);
        } else {
          return this.submit_button.click(this.message_post);
        }
      } else if (this.child_state === 'done') {
        this.show_combined_rubric_current();
        this.rubric_wrapper.hide();
        this.answer_area.attr("disabled", true);
        this.replace_text_inputs();
        this.hint_area.attr('disabled', true);
        this.submit_button.hide();
        if (this.child_type === "openended") {
          this.skip_button.hide();
        }
        if (this.task_number < this.task_count) {
          return this.next_problem_button.show();
        } else {
          return this.reset_button.show();
        }
      }
    };

    CombinedOpenEnded.prototype.find_assessment_elements = function() {
      return this.assessment = this.$('input[name="grade-selection"]');
    };

    CombinedOpenEnded.prototype.find_hint_elements = function() {
      return this.hint_area = this.$('textarea.post_assessment');
    };

    CombinedOpenEnded.prototype.replace_answer = function(response) {
      var answer_area_div;
      if (response.success) {
        this.rubric_wrapper.html(response.rubric_html);
        this.rubric_wrapper.show();
        this.rub = new Rubric(this.coe);
        this.rub.initialize(this.location);
        this.child_state = 'assessing';
        this.find_assessment_elements();
        this.rebind();
        answer_area_div = this.$(this.answer_area_div_sel);
        return answer_area_div.html(response.student_response);
      } else {
        this.can_upload_files = pre_can_upload_files;
        return this.gentle_alert(response.error);
      }
    };

    CombinedOpenEnded.prototype.save_answer = function(event) {
      var fd, files, max_filesize, pre_can_upload_files, settings,
        _this = this;
      this.submit_button.attr("disabled", true);
      this.submit_button.hide();
      event.preventDefault();
      this.answer_area.attr("disabled", true);
      max_filesize = 2 * 1000 * 1000;
      pre_can_upload_files = this.can_upload_files;
      if (this.child_state === 'initial') {
        files = "";
        if (this.can_upload_files === true) {
          files = this.$(this.file_upload_box_sel)[0].files[0];
          if (files !== void 0) {
            if (files.size > max_filesize) {
              this.can_upload_files = false;
              files = "";
            }
          } else {
            this.can_upload_files = false;
          }
        }
        fd = new FormData();
        fd.append('student_answer', this.answer_area.val());
        fd.append('student_file', files);
        fd.append('can_upload_files', this.can_upload_files);
        settings = {
          type: "POST",
          data: fd,
          processData: false,
          contentType: false,
          async: false,
          success: function(response) {
            return _this.replace_answer(response);
          }
        };
        return $.ajaxWithPrefix("" + this.ajax_url + "/save_answer", settings);
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.keydown_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === false) {
        return this.is_ctrl = true;
      } else if (this.is_ctrl === true && event.which === 13 && this.child_state === 'assessing' && this.rub.check_complete()) {
        return this.save_assessment(event);
      }
    };

    CombinedOpenEnded.prototype.keyup_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === true) {
        return this.is_ctrl = false;
      }
    };

    CombinedOpenEnded.prototype.save_assessment = function(event) {
      var checked_assessment, data, score_list,
        _this = this;
      this.submit_button.attr("disabled", true);
      this.submit_button.hide();
      event.preventDefault();
      if (this.child_state === 'assessing' && this.rub.check_complete()) {
        checked_assessment = this.rub.get_total_score();
        score_list = this.rub.get_score_list();
        data = {
          'assessment': checked_assessment,
          'score_list': score_list
        };
        return $.postWithPrefix("" + this.ajax_url + "/save_assessment", data, function(response) {
          if (response.success) {
            _this.child_state = response.state;
            if (_this.child_state === 'post_assessment') {
              _this.hint_wrapper.html(response.hint_html);
              _this.find_hint_elements();
            } else if (_this.child_state === 'done') {
              _this.rubric_wrapper.hide();
            }
            return _this.rebind();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.save_hint = function(event) {
      var data,
        _this = this;
      event.preventDefault();
      if (this.child_state === 'post_assessment') {
        data = {
          'hint': this.hint_area.val()
        };
        return $.postWithPrefix("" + this.ajax_url + "/save_post_assessment", data, function(response) {
          if (response.success) {
            _this.message_wrapper.html(response.message_html);
            _this.child_state = 'done';
            return _this.rebind();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.skip_post_assessment = function() {
      var _this = this;
      if (this.child_state === 'post_assessment') {
        return $.postWithPrefix("" + this.ajax_url + "/skip_post_assessment", {}, function(response) {
          if (response.success) {
            _this.child_state = 'done';
            return _this.rebind();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.reset = function(event) {
      var _this = this;
      event.preventDefault();
      if (this.child_state === 'done' || this.allow_reset === "True") {
        return $.postWithPrefix("" + this.ajax_url + "/reset", {}, function(response) {
          if (response.success) {
            _this.answer_area.val('');
            _this.rubric_wrapper.html('');
            _this.hint_wrapper.html('');
            _this.message_wrapper.html('');
            _this.child_state = 'initial';
            _this.coe.after(response.html).remove();
            _this.allow_reset = "False";
            _this.reinitialize(_this.element);
            _this.has_been_reset = true;
            _this.rebind();
            return _this.reset_button.hide();
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.next_problem = function() {
      var _this = this;
      if (this.child_state === 'done') {
        return $.postWithPrefix("" + this.ajax_url + "/next_problem", {}, function(response) {
          if (response.success) {
            _this.answer_area.val('');
            _this.rubric_wrapper.html('');
            _this.hint_wrapper.html('');
            _this.message_wrapper.html('');
            _this.child_state = 'initial';
            _this.coe.after(response.html).remove();
            _this.reinitialize(_this.element);
            _this.rebind();
            _this.next_problem_button.hide();
            if (!response.allow_reset) {
              return _this.gentle_alert("Moved to next step.");
            } else {
              _this.gentle_alert("Your score did not meet the criteria to move to the next step.");
              return _this.show_combined_rubric_current();
            }
          } else {
            return _this.errors_area.html(response.error);
          }
        });
      } else {
        return this.errors_area.html(this.out_of_sync_message);
      }
    };

    CombinedOpenEnded.prototype.gentle_alert = function(msg) {
      var alert_elem;
      if (this.$el.find(this.oe_alert_sel).length) {
        this.$el.find(this.oe_alert_sel).remove();
      }
      alert_elem = "<div class='open-ended-alert'>" + msg + "</div>";
      this.$el.find('.open-ended-action').after(alert_elem);
      return this.$el.find(this.oe_alert_sel).css({
        opacity: 0
      }).animate({
        opacity: 1
      }, 700);
    };

    CombinedOpenEnded.prototype.queueing = function() {
      if (this.child_state === "assessing" && this.child_type === "openended") {
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
        }
        return window.queuePollerID = window.setTimeout(this.poll, 10000);
      }
    };

    CombinedOpenEnded.prototype.poll = function() {
      var _this = this;
      return $.postWithPrefix("" + this.ajax_url + "/check_for_score", function(response) {
        if (response.state === "done" || response.state === "post_assessment") {
          delete window.queuePollerID;
          return _this.reload();
        } else {
          return window.queuePollerID = window.setTimeout(_this.poll, 10000);
        }
      });
    };

    CombinedOpenEnded.prototype.setup_file_upload = function() {
      if (this.accept_file_upload === "True") {
        if (window.File && window.FileReader && window.FileList && window.Blob) {
          this.can_upload_files = true;
          this.file_upload_area.html('<input type="file" class="file-upload-box"><img class="file-upload-preview" src="#" alt="Uploaded image" />');
          this.file_upload_area.show();
          this.$(this.file_upload_preview_sel).hide();
          return this.$(this.file_upload_box_sel).change(this.preview_image);
        } else {
          return this.gentle_alert('File uploads are required for this question, but are not supported in this browser. Try the newest version of google chrome.  Alternatively, if you have uploaded the image to the web, you can paste a link to it into the answer box.');
        }
      }
    };

    CombinedOpenEnded.prototype.hide_file_upload = function() {
      if (this.accept_file_upload === "True") {
        return this.file_upload_area.hide();
      }
    };

    CombinedOpenEnded.prototype.replace_text_inputs = function() {
      var answer_class, answer_id, answer_val, new_text;
      answer_class = this.answer_area.attr('class');
      answer_id = this.answer_area.attr('id');
      answer_val = this.answer_area.val();
      new_text = '';
      new_text = "<div class='" + answer_class + "' id='" + answer_id + "'>" + answer_val + "</div>";
      return this.answer_area.replaceWith(new_text);
    };

    CombinedOpenEnded.prototype.reload = function() {
      return this.reinitialize();
    };

    CombinedOpenEnded.prototype.collapse_question = function(event) {
      var new_text;
      this.prompt_container.slideToggle();
      this.prompt_container.toggleClass('open');
      if (this.question_header.text() === "Hide Prompt") {
        new_text = "Show Prompt";
        Logger.log('oe_hide_question', {
          location: this.location
        });
      } else {
        Logger.log('oe_show_question', {
          location: this.location
        });
        new_text = "Hide Prompt";
      }
      this.question_header.text(new_text);
      return false;
    };

    CombinedOpenEnded.prototype.hide_rubrics = function() {
      var rub, rubrics, _i, _len, _results;
      rubrics = this.$(this.combined_rubric_sel);
      _results = [];
      for (_i = 0, _len = rubrics.length; _i < _len; _i++) {
        rub = rubrics[_i];
        if (this.$(rub).data('status') === "shown") {
          _results.push(this.$(rub).show());
        } else {
          _results.push(this.$(rub).hide());
        }
      }
      return _results;
    };

    CombinedOpenEnded.prototype.next_rubric = function() {
      this.shift_rubric(1);
      return false;
    };

    CombinedOpenEnded.prototype.previous_rubric = function() {
      this.shift_rubric(-1);
      return false;
    };

    CombinedOpenEnded.prototype.shift_rubric = function(i) {
      var number, rub, rubrics, _i, _len;
      rubrics = this.$(this.combined_rubric_sel);
      number = 0;
      for (_i = 0, _len = rubrics.length; _i < _len; _i++) {
        rub = rubrics[_i];
        if (this.$(rub).data('status') === "shown") {
          number = this.$(rub).data('number');
        }
        this.$(rub).data('status', 'hidden');
      }
      if (i === 1 && number < rubrics.length - 1) {
        number = number + i;
      }
      if (i === -1 && number > 0) {
        number = number + i;
      }
      this.$(rubrics[number]).data('status', 'shown');
      return this.hide_rubrics();
    };

    CombinedOpenEnded.prototype.prompt_show = function() {
      if (this.prompt_container.is(":hidden") === true) {
        this.prompt_container.slideToggle();
        this.prompt_container.toggleClass('open');
        return this.question_header.text("Hide Prompt");
      }
    };

    CombinedOpenEnded.prototype.prompt_hide = function() {
      if (this.prompt_container.is(":visible") === true) {
        this.prompt_container.slideToggle();
        this.prompt_container.toggleClass('open');
        return this.question_header.text("Show Prompt");
      }
    };

    CombinedOpenEnded.prototype.log_feedback_click = function(event) {
      var generated_event_type, link_text;
      link_text = this.$(event.target).html();
      if (link_text === 'See full feedback') {
        return Logger.log('oe_show_full_feedback', {});
      } else if (link_text === 'Respond to Feedback') {
        return Logger.log('oe_show_respond_to_feedback', {});
      } else {
        generated_event_type = link_text.toLowerCase().replace(" ", "_");
        return Logger.log("oe_" + generated_event_type, {});
      }
    };

    CombinedOpenEnded.prototype.log_feedback_selection = function(event) {
      var target_selection;
      target_selection = this.$(event.target).val();
      return Logger.log('oe_feedback_response_selected', {
        value: target_selection
      });
    };

    CombinedOpenEnded.prototype.remove_attribute = function(name) {
      if (this.$(this.file_upload_preview_sel).attr(name)) {
        return this.$(this.file_upload_preview_sel)[0].removeAttribute(name);
      }
    };

    CombinedOpenEnded.prototype.preview_image = function() {
      var reader,
        _this = this;
      if (this.$(this.file_upload_box_sel)[0].files && this.$(this.file_upload_box_sel)[0].files[0]) {
        reader = new FileReader();
        reader.onload = function(e) {
          var height_px, max_dim, scale_factor, width_px;
          max_dim = 150;
          _this.remove_attribute('src');
          _this.remove_attribute('height');
          _this.remove_attribute('width');
          _this.$(_this.file_upload_preview_sel).attr('src', e.target.result);
          height_px = _this.$(_this.file_upload_preview_sel)[0].height;
          width_px = _this.$(_this.file_upload_preview_sel)[0].width;
          scale_factor = 0;
          if (height_px > width_px) {
            scale_factor = height_px / max_dim;
          } else {
            scale_factor = width_px / max_dim;
          }
          _this.$(_this.file_upload_preview_sel)[0].width = width_px / scale_factor;
          _this.$(_this.file_upload_preview_sel)[0].height = height_px / scale_factor;
          return _this.$(_this.file_upload_preview_sel).show();
        };
        return reader.readAsDataURL(this.$(this.file_upload_box_sel)[0].files[0]);
      }
    };

    CombinedOpenEnded.prototype.toggle_rubric = function(event) {
      var info_rubric_elements;
      info_rubric_elements = this.$(this.info_rubric_elements_sel);
      info_rubric_elements.slideToggle();
      return false;
    };

    CombinedOpenEnded.prototype.setup_score_selection = function() {
      return this.$("input[class='score-selection']").change(this.graded_callback);
    };

    CombinedOpenEnded.prototype.graded_callback = function() {
      if (this.rub.check_complete()) {
        this.submit_button.attr("disabled", false);
        return this.submit_button.show();
      }
    };

    return CombinedOpenEnded;

  })();

}).call(this);

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('State', ['logme'], function (logme) {
    var stateInst;

    // Since there will be (can be) multiple GST on a page, and each will have
    // a separate state, we will create a factory constructor function. The
    // constructor will expect the ID of the DIV with the GST contents, and the
    // configuration object (parsed from a JSON string). It will return an
    // object containing methods to set and get the private state properties.

    stateInst = 0;

    // This module defines and returns a factory constructor.
    return State;

    function State(gstId, config) {
        var parameters, allParameterNames, allParameterValues,
            plotDiv, dynamicEl, dynamicElByElId;

        dynamicEl = [];
        dynamicElByElId = {};

        stateInst += 1;
        // logme('MESSAGE: Creating state instance # ' + stateInst + '.');

        // Initially, there are no parameters to track. So, we will instantiate
        // an empty object.
        //
        // As we parse the JSON config object, we will add parameters as
        // named properties. For example
        //
        //     parameters.a = {...};
        //
        // will be created for the parameter 'a'.
        parameters = {};

        // Check that the required parameters config object is available.
        if ($.isPlainObject(config.parameters) === false) {
            logme('ERROR: Expected config.parameters to be an object. It is not.');
            logme('config.parameters = ', config.parameters);

            return;
        }

        // If config.parameters.param is an array, pass it to the processor
        // element by element.
        if ($.isArray(config.parameters.param) === true) {
            (function (c1) {
                while (c1 < config.parameters.param.length) {
                    processParameter(config.parameters.param[c1]);
                    c1 += 1;
                }
            }(0));
        }

        // If config.parameters.param is an object, pass this object to the
        // processor directly.
        else if ($.isPlainObject(config.parameters.param) === true) {
            processParameter(config.parameters.param);
        }

        // If config.parameters.param is some other type, report an error and
        // do not continue.
        else {
            logme('ERROR: config.parameters.param is of an unsupported type.');
            logme('config.parameters.param = ', config.parameters.param);

            return;
        }

        // Instead of building these arrays every time when some component
        // requests them, we will create them in the beginning, and then update
        // each element individually when some parameter's value changes.
        //
        // Then we can just return the required array, instead of iterating
        // over all of the properties of the 'parameters' object, and
        // extracting their names/values one by one.
        allParameterNames = [];
        allParameterValues = [];

        // Populate 'allParameterNames', and 'allParameterValues' with data.
        generateHelperArrays();

        // The constructor will return an object with methods to operate on
        // it's private properties.
        return {
            'getParameterValue': getParameterValue,
            'setParameterValue': setParameterValue,

            'getParamObj': getParamObj,

            'getAllParameterNames': getAllParameterNames,
            'getAllParameterValues': getAllParameterValues,

            'bindUpdatePlotEvent': bindUpdatePlotEvent,
            'addDynamicEl': addDynamicEl,

            // plde is an abbreviation for Plot Label Dynamic Elements.
            plde: []
        };

        function getAllParameterNames() {
            return allParameterNames;
        }

        function getAllParameterValues() {
            return allParameterValues;
        }

        function getParamObj(paramName) {
            if (parameters.hasOwnProperty(paramName) === false) {
                logme('ERROR: Object parameters does not have a property named "' + paramName + '".');

                return;
            }

            return parameters[paramName];
        }

        function bindUpdatePlotEvent(newPlotDiv, callback) {
            plotDiv = newPlotDiv;

            plotDiv.bind('update_plot', callback);
        }

        function addDynamicEl(el, func, elId, updateOnEvent) {
            var newLength;

            newLength = dynamicEl.push({
                'el': el,
                'func': func,
                'elId': elId,
                'updateOnEvent': updateOnEvent
            });

            if (typeof dynamicElByElId[elId] !== 'undefined') {
                logme(
                    'ERROR: Duplicate dynamic element ID "' + elId + '" found.'
                );
            } else {
                dynamicElByElId[elId] = dynamicEl[newLength - 1];
            }
        }

        function getParameterValue(paramName) {

            // If the name of the constant is not tracked by state, return an
            // 'undefined' value.
            if (parameters.hasOwnProperty(paramName) === false) {
                logme('ERROR: Object parameters does not have a property named "' + paramName + '".');

                return;
            }

            return parameters[paramname].value;
        }

        // ####################################################################
        //
        // Function: setParameterValue(paramName, paramValue, element)
        // --------------------------------------------------
        //
        //
        // This function can be called from a callback, registered by a slider
        // or a text input, when specific events ('slide' or 'change') are
        // triggered.
        //
        // The 'paramName' is the name of the parameter in 'parameters' object
        // whose value must be updated to the new value of 'paramValue'.
        //
        // Before we update the value, we must check that:
        //
        //     1.) the parameter named as 'paramName' actually exists in the
        //         'parameters' object;
        //     2.) the value 'paramValue' is a valid floating-point number, and
        //         it lies within the range specified by the 'min' and 'max'
        //         properties of the stored parameter object.
        //
        // If 'paramName' and 'paramValue' turn out to be valid, we will update
        // the stored value in the parameter with the new value, and also
        // update all of the text inputs and the slider that correspond to this
        // parameter (if any), so that they reflect the new parameter's value.
        // Finally, the helper array 'allParameterValues' will also be updated
        // to reflect the change.
        //
        // If something went wrong (for example the new value is outside the
        // allowed range), then we will reset the 'element' to display the
        // original value.
        //
        // ####################################################################
        function setParameterValue(paramName, paramValue, element, slider, updateOnEvent) {
            var paramValueNum, c1;

            // If a parameter with the name specified by the 'paramName'
            // parameter is not tracked by state, do not do anything.
            if (parameters.hasOwnProperty(paramName) === false) {
                logme('ERROR: Object parameters does not have a property named "' + paramName + '".');

                return;
            }

            // Try to convert the passed value to a valid floating-point
            // number.
            paramValueNum = parseFloat(paramValue);

            // We are interested only in valid float values. NaN, -INF,
            // +INF we will disregard.
            if (isFinite(paramValueNum) === false) {
                logme('ERROR: New parameter value is not a floating-point number.');
                logme('paramValue = ', paramValue);

                return;
            }

            if (paramValueNum < parameters[paramName].min) {
                paramValueNum = parameters[paramName].min;
            } else if (paramValueNum > parameters[paramName].max) {
                paramValueNum = parameters[paramName].max;
            }

            parameters[paramName].value = paramValueNum;

            // Update all text inputs with the new parameter's value.
            for (c1 = 0; c1 < parameters[paramName].inputDivs.length; c1 += 1) {
                parameters[paramName].inputDivs[c1].val(paramValueNum);
            }

            // Update the single slider with the new parameter's value.
            if ((slider === false) && (parameters[paramName].sliderDiv !== null)) {
                parameters[paramName].sliderDiv.slider('value', paramValueNum);
            }

            // Update the helper array with the new parameter's value.
            allParameterValues[parameters[paramName].helperArrayIndex] = paramValueNum;

            for (c1 = 0; c1 < dynamicEl.length; c1++) {
                if (
                    ((updateOnEvent !== undefined) && (dynamicEl[c1].updateOnEvent === updateOnEvent)) ||
                    (updateOnEvent === undefined)
                ) {
                    // If we have a DOM element, call the function "paste" the answer into the DIV.
                    if (dynamicEl[c1].el !== null) {
                        dynamicEl[c1].el.html(dynamicEl[c1].func.apply(window, allParameterValues));
                    }
                    // If we DO NOT have an element, simply call the function. The function can then
                    // manipulate all the DOM elements it wants, without the fear of them being overwritten
                    // by us afterwards.
                    else {
                        dynamicEl[c1].func.apply(window, allParameterValues);
                    }
                }
            }

            // If we have a plot DIV to work with, tell to update.
            if (plotDiv !== undefined) {
                plotDiv.trigger('update_plot');
            }

            return true;
        } // End-of: function setParameterValue

        // ####################################################################
        //
        // Function: processParameter(obj)
        // -------------------------------
        //
        //
        // This function will be run once for each instance of a GST when
        // parsing the JSON config object.
        //
        // 'newParamObj' must be empty from the start for each invocation of
        // this function, that's why we will declare it locally.
        //
        // We will parse the passed object 'obj' and populate the 'newParamObj'
        // object with required properties.
        //
        // Since there will be many properties that are of type floating-point
        // number, we will have a separate function for parsing them.
        //
        // processParameter() will fail right away if 'obj' does not have a
        // '@var' property which represents the name of the parameter we want
        // to process.
        //
        // If, after all of the properties have been processed, we reached the
        // end of the function successfully, the 'newParamObj' will be added to
        // the 'parameters' object (that is defined in the scope of State()
        // function) as a property named as the name of the parameter.
        //
        // If at least one of the properties from 'obj' does not get correctly
        // parsed, then the parameter represented by 'obj' will be disregarded.
        // It will not be available to user-defined plotting functions, and
        // things will most likely break. We will notify the user about this.
        //
        // ####################################################################
        function processParameter(obj) {
            var paramName, newParamObj;

            if (typeof obj['@var'] !== 'string') {
                logme('ERROR: Expected obj["@var"] to be a string. It is not.');
                logme('obj["@var"] = ', obj['@var']);

                return;
            }

            paramName = obj['@var'];
            newParamObj = {};

            if (
                (processFloat('@min', 'min') === false) ||
                (processFloat('@max', 'max') === false) ||
                (processFloat('@step', 'step') === false) ||
                (processFloat('@initial', 'value') === false)
            ) {
                logme('ERROR: A required property is missing. Not creating parameter "' + paramName + '"');

                return;
            }

            // Pointers to text input and slider DIV elements that this
            // parameter will be attached to. Initially there are none. When we
            // will create text inputs and sliders, we will update these
            // properties.
            newParamObj.inputDivs = [];
            newParamObj.sliderDiv = null;

            // Everything went well, so save the new parameter object.
            parameters[paramName] = newParamObj;

            return;

            function processFloat(attrName, newAttrName) {
                var attrValue;

                if (typeof obj[attrName] !== 'string') {
                    logme('ERROR: Expected obj["' + attrName + '"] to be a string. It is not.');
                    logme('obj["' + attrName + '"] = ', obj[attrName]);

                    return false;
                } else {
                    attrValue = parseFloat(obj[attrName]);

                    if (isFinite(attrValue) === false) {
                        logme('ERROR: Expected obj["' + attrName + '"] to be a valid floating-point number. It is not.');
                        logme('obj["' + attrName + '"] = ', obj[attrName]);

                        return false;
                    }
                }

                newParamObj[newAttrName] = attrValue;

                return true;
            } // End-of: function processFloat
        } // End-of: function processParameter

        // ####################################################################
        //
        // Function: generateHelperArrays()
        // -------------------------------
        //
        //
        // Populate 'allParameterNames' and 'allParameterValues' with data.
        // Link each parameter object with the corresponding helper array via
        // an index 'helperArrayIndex'. It will be the same for both of the
        // arrays.
        //
        // NOTE: It is important to remember to update these helper arrays
        // whenever a new parameter is added (or one is removed), or when a
        // parameter's value changes.
        //
        // ####################################################################
        function generateHelperArrays() {
            var paramName, c1;

            c1 = 0;
            for (paramName in parameters) {
                allParameterNames.push(paramName);
                allParameterValues.push(parameters[paramName].value);

                parameters[paramName].helperArrayIndex = c1;

                c1 += 1;
            }
        }
    } // End-of: function State
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

/*
 * d3 - Data-Driven Documents
 * https://github.com/mbostock/d3
 * 
 * 
 * Copyright (c) 2013, Michael Bostock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * The name Michael Bostock may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
d3=function(){function n(n){return null!=n&&!isNaN(n)}function t(n){return n.length}function e(n){for(var t=1;n*t%1;)t*=10;return t}function r(n,t){try{for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}catch(r){n.prototype=t}}function u(){}function i(){}function a(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function o(){}function c(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new u;return t.on=function(t,u){var i,a=r.get(t);return arguments.length<2?a&&a.on:(a&&(a.on=null,e=e.slice(0,i=e.indexOf(a)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function l(){oa.event.stopPropagation(),oa.event.preventDefault()}function f(){for(var n,t=oa.event;n=t.sourceEvent;)t=n;return t}function s(n){for(var t=new o,e=0,r=arguments.length;++e<r;)t[arguments[e]]=c(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=oa.event;u.target=n,oa.event=u,t[u.type].apply(e,r)}finally{oa.event=i}}},t}function h(n,t){var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>ma&&(la.scrollX||la.scrollY)){e=oa.select(ca.body).append("svg").style("position","absolute").style("top",0).style("left",0);var u=e[0][0].getScreenCTM();ma=!(u.f||u.e),e.remove()}return ma?(r.x=t.pageX,r.y=t.pageY):(r.x=t.clientX,r.y=t.clientY),r=r.matrixTransform(n.getScreenCTM().inverse()),[r.x,r.y]}var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}function g(n){for(var t=-1,e=n.length,r=[];++t<e;)r.push(n[t]);return r}function p(n){return Array.prototype.slice.call(n)}function d(n){return Ma(n,Ea),n}function m(n){return function(){return xa(n,this)}}function v(n){return function(){return ba(n,this)}}function y(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=oa.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?o:a:n.local?i:u}function M(n){return n.trim().replace(/\s+/g," ")}function x(n){return RegExp("(?:^|\\s+)"+oa.requote(n)+"(?:\\s+|$)","g")}function _(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=n.trim().split(/\s+/).map(w);var u=n.length;return"function"==typeof t?r:e}function w(n){var t=x(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",M(u+" "+n))):e.setAttribute("class",M(u.replace(t," ")))}}function S(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function E(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function k(n){return{__data__:n}}function A(n){return function(){return Sa(this,n)}}function q(n){return arguments.length||(n=oa.ascending),function(t,e){return!t-!e||n(t.__data__,e.__data__)}}function N(){}function T(n,t,e){function r(){var t=this[a];t&&(this.removeEventListener(n,t,t.$),delete this[a])}function u(){var u=c(t,va(arguments));r.call(this),this.addEventListener(n,this[a]=u,u.$=e),u._=t}function i(){var t,e=RegExp("^__on([^.]+)"+oa.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var a="__on"+n,o=n.indexOf("."),c=C;o>0&&(n=n.substring(0,o));var l=qa.get(n);return l&&(n=l,c=z),o?t?u:r:t?N:i}function C(n,t){return function(e){var r=oa.event;oa.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{oa.event=r}}}function z(n,t){var e=C(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||r.compareDocumentPosition(t)&8)||e.call(t,n)}}function D(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],a=0,o=i.length;o>a;a++)(u=i[a])&&t(u,a,e);return n}function j(n){return Ma(n,Na),n}function L(){}function F(n,t,e){return new H(n,t,e)}function H(n,t,e){this.h=n,this.s=t,this.l=e}function P(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(a-i)*n/60:180>n?a:240>n?i+(a-i)*(240-n)/60:i}function u(n){return Math.round(r(n)*255)}var i,a;return n%=360,0>n&&(n+=360),t=0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,a=.5>=e?e*(1+t):e+t-e*t,i=2*e-a,tt(u(n+120),u(n),u(n-120))}function R(n){return n>0?1:0>n?-1:0}function O(n){return Math.acos(Math.max(-1,Math.min(1,n)))}function Y(n){return n>1?La/2:-1>n?-La/2:Math.asin(n)}function U(n){return(Math.exp(n)-Math.exp(-n))/2}function I(n){return(Math.exp(n)+Math.exp(-n))/2}function V(n){return(n=Math.sin(n/2))*n}function X(n,t,e){return new Z(n,t,e)}function Z(n,t,e){this.h=n,this.c=t,this.l=e}function B(n,t,e){return $(e,Math.cos(n*=Ha)*t,Math.sin(n)*t)}function $(n,t,e){return new J(n,t,e)}function J(n,t,e){this.l=n,this.a=t,this.b=e}function G(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=W(u)*Ya,r=W(r)*Ua,i=W(i)*Ia,tt(nt(3.2404542*u-1.5371385*r-.4985314*i),nt(-.969266*u+1.8760108*r+.041556*i),nt(.0556434*u-.2040259*r+1.0572252*i))}function K(n,t,e){return X(Math.atan2(e,t)*Pa,Math.sqrt(t*t+e*e),n)}function W(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function Q(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function nt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function tt(n,t,e){return new et(n,t,e)}function et(n,t,e){this.r=n,this.g=t,this.b=e}function rt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function ut(n,t,e){var r,u,i,a=0,o=0,c=0;if(r=/([a-z]+)\((.*)\)/i.exec(n))switch(u=r[2].split(","),r[1]){case"hsl":return e(parseFloat(u[0]),parseFloat(u[1])/100,parseFloat(u[2])/100);case"rgb":return t(ct(u[0]),ct(u[1]),ct(u[2]))}return(i=Za.get(n))?t(i.r,i.g,i.b):(null!=n&&n.charAt(0)==="#"&&(n.length===4?(a=n.charAt(1),a+=a,o=n.charAt(2),o+=o,c=n.charAt(3),c+=c):n.length===7&&(a=n.substring(1,3),o=n.substring(3,5),c=n.substring(5,7)),a=parseInt(a,16),o=parseInt(o,16),c=parseInt(c,16)),t(a,o,c))}function it(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),a=Math.max(n,t,e),o=a-i,c=(a+i)/2;return o?(u=.5>c?o/(a+i):o/(2-a-i),r=n==a?(t-e)/o+(e>t?6:0):t==a?(e-n)/o+2:(n-t)/o+4,r*=60):u=r=0,F(r,u,c)}function at(n,t,e){n=ot(n),t=ot(t),e=ot(e);var r=Q((.4124564*n+.3575761*t+.1804375*e)/Ya),u=Q((.2126729*n+.7151522*t+.072175*e)/Ua),i=Q((.0193339*n+.119192*t+.9503041*e)/Ia);return $(116*u-16,500*(r-u),200*(u-i))}function ot(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function ct(n){var t=parseFloat(n);return n.charAt(n.length-1)==="%"?Math.round(2.55*t):t}function lt(n){return"function"==typeof n?n:function(){return n}}function ft(n){return n}function st(n){return n.length===1?function(t,e){n(null==t?e:null)}:n}function ht(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var a=oa.xhr(n,t,i);return a.row=function(n){return arguments.length?a.response((e=n)==null?r:u(n)):e},a.row(e)}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function a(t){return t.map(o).join(n)}function o(n){return c.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var c=RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(f>=c)return a;if(u)return u=!1,i;var t=f;if(n.charCodeAt(t)===34){for(var e=t;e++<c;)if(n.charCodeAt(e)===34){if(n.charCodeAt(e+1)!==34)break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,n.charCodeAt(e+2)===10&&++f):10===r&&(u=!0),n.substring(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),o=1;if(10===r)u=!0;else if(13===r)u=!0,n.charCodeAt(f)===10&&(++f,++o);else if(r!==l)continue;return n.substring(t,f-o)}return n.substring(t)}for(var r,u,i={},a={},o=[],c=n.length,f=0,s=0;(r=e())!==a;){for(var h=[];r!==i&&r!==a;)h.push(r),r=e();(!t||(h=t(h,s++)))&&o.push(h)}return o},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new i,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(a).join("\n")},e}function gt(){for(var n,t=Date.now(),e=Ka;e;)n=t-e.then,n>=e.delay&&(e.flush=e.callback(n)),e=e.next;var r=pt()-t;r>24?(isFinite(r)&&(clearTimeout($a),$a=setTimeout(gt,r)),Ba=0):(Ba=1,Wa(gt))}function pt(){for(var n=null,t=Ka,e=1/0;t;)t.flush?(delete Ga[t.callback.id],t=n?n.next=t.next:Ka=t.next):(e=Math.min(e,t.then+t.delay),t=(n=t).next);return e}function dt(n,t){var e=Math.pow(10,Math.abs(8-t)*3);return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function mt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function vt(n){return n+""}function yt(n,t){co.hasOwnProperty(n.type)&&co[n.type](n,t)}function Mt(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1]);t.lineEnd()}function xt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)Mt(n[e],t,1);t.polygonEnd()}function bt(){function n(n,t){n*=Ha,t=t*Ha/2+La/4;var e=n-r,a=Math.cos(t),o=Math.sin(t),c=i*o,l=fo,f=so,s=u*a+c*Math.cos(e),h=c*Math.sin(e);fo=l*s-f*h,so=f*s+l*h,r=n,u=a,i=o}var t,e,r,u,i;ho.point=function(a,o){ho.point=n,r=(t=a)*Ha,u=Math.cos(o=(e=o)*Ha/2+La/4),i=Math.sin(o)},ho.lineEnd=function(){n(t,e)}}function _t(n){function t(n,t){r>n&&(r=n),n>i&&(i=n),u>t&&(u=t),t>a&&(a=t)}function e(){o.point=o.lineEnd=N}var r,u,i,a,o={point:t,lineStart:N,lineEnd:N,polygonStart:function(){o.lineEnd=e},polygonEnd:function(){o.point=t}};return function(t){return a=i=-(r=u=1/0),oa.geo.stream(t,n(o)),[[r,u],[i,a]]}}function wt(n,t){if(!go){++po,n*=Ha;var e=Math.cos(t*=Ha);mo+=(e*Math.cos(n)-mo)/po,vo+=(e*Math.sin(n)-vo)/po,yo+=(Math.sin(t)-yo)/po}}function St(){var n,t;go=1,Et(),go=2;var e=Mo.point;Mo.point=function(r,u){e(n=r,t=u)},Mo.lineEnd=function(){Mo.point(n,t),kt(),Mo.lineEnd=kt}}function Et(){function n(n,u){n*=Ha;var i=Math.cos(u*=Ha),a=i*Math.cos(n),o=i*Math.sin(n),c=Math.sin(u),l=Math.atan2(Math.sqrt((l=e*c-r*o)*l+(l=r*a-t*c)*l+(l=t*o-e*a)*l),t*a+e*o+r*c);po+=l,mo+=l*(t+(t=a)),vo+=l*(e+(e=o)),yo+=l*(r+(r=c))}var t,e,r;go>1||(1>go&&(go=1,po=mo=vo=yo=0),Mo.point=function(u,i){u*=Ha;var a=Math.cos(i*=Ha);t=a*Math.cos(u),e=a*Math.sin(u),r=Math.sin(i),Mo.point=n})}function kt(){Mo.point=wt}function At(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function qt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function Nt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Tt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function Ct(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function zt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function Dt(){return!0}function jt(n){return[Math.atan2(n[1],n[0]),Math.asin(Math.max(-1,Math.min(1,n[2])))]}function Lt(n,t){return Math.abs(n[0]-t[0])<Fa&&Math.abs(n[1]-t[1])<Fa}function Ft(n,t,e,r,u){var i=[],a=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(Lt(e,r)){u.lineStart();for(var o=0;t>o;++o)u.point((e=n[o])[0],e[1]);return u.lineEnd(),void 0}var c={point:e,points:n,other:null,visited:!1,entry:!0,subject:!0},l={point:e,points:[e],other:c,visited:!1,entry:!1,subject:!1};c.other=l,i.push(c),a.push(l),c={point:r,points:[r],other:null,visited:!1,entry:!1,subject:!0},l={point:r,points:[r],other:c,visited:!1,entry:!0,subject:!1},c.other=l,i.push(c),a.push(l)}}),a.sort(t),Ht(i),Ht(a),i.length){if(e)for(var o=1,c=!e(a[0].point),l=a.length;l>o;++o)a[o].entry=c=!c;for(var f,s,h,g=i[0];;){for(f=g;f.visited;)if((f=f.next)===g)return;s=f.points,u.lineStart();do{if(f.visited=f.other.visited=!0,f.entry){if(f.subject)for(var o=0;o<s.length;o++)u.point((h=s[o])[0],h[1]);else r(f.point,f.next.point,1,u);f=f.next}else{if(f.subject){s=f.prev.points;for(var o=s.length;--o>=0;)u.point((h=s[o])[0],h[1])}else r(f.point,f.prev.point,-1,u);f=f.prev}f=f.other,s=f.points}while(!f.visited);u.lineEnd()}}}function Ht(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.next=e=n[r],e.prev=u,u=e;u.next=e=n[0],e.prev=u}}function Pt(n,t,e){return function(r){function u(t,e){n(t,e)&&r.point(t,e)}function i(n,t){m.point(n,t)}function a(){v.point=i,m.lineStart()}function o(){v.point=u,m.lineEnd()}function c(n,t){M.point(n,t),d.push([n,t])}function l(){M.lineStart(),d=[]}function f(){c(d[0][0],d[0][1]),M.lineEnd();var n,t=M.clean(),e=y.buffer(),u=e.length;if(!u)return p=!0,g+=Yt(d,-1),d=null,void 0;if(d=null,1&t){n=e[0],h+=Yt(n,1);var i,u=n.length-1,a=-1;for(r.lineStart();++a<u;)r.point((i=n[a])[0],i[1]);return r.lineEnd(),void 0}u>1&&2&t&&e.push(e.pop().concat(e.shift())),s.push(e.filter(Rt))}var s,h,g,p,d,m=t(r),v={point:u,lineStart:a,lineEnd:o,polygonStart:function(){v.point=c,v.lineStart=l,v.lineEnd=f,p=!1,g=h=0,s=[],r.polygonStart()},polygonEnd:function(){v.point=u,v.lineStart=a,v.lineEnd=o,s=oa.merge(s),s.length?Ft(s,Ut,null,e,r):(-Fa>h||p&&-Fa>g)&&(r.lineStart(),e(null,null,1,r),r.lineEnd()),r.polygonEnd(),s=null},sphere:function(){r.polygonStart(),r.lineStart(),e(null,null,1,r),r.lineEnd(),r.polygonEnd()}},y=Ot(),M=t(y);return v}}function Rt(n){return n.length>1}function Ot(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:N,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Yt(n,t){if(!(e=n.length))return 0;for(var e,r,u,i=0,a=0,o=n[0],c=o[0],l=o[1],f=Math.cos(l),s=Math.atan2(t*Math.sin(c)*f,Math.sin(l)),h=1-t*Math.cos(c)*f,g=s;++i<e;)o=n[i],f=Math.cos(l=o[1]),r=Math.atan2(t*Math.sin(c=o[0])*f,Math.sin(l)),u=1-t*Math.cos(c)*f,Math.abs(h-2)<Fa&&Math.abs(u-2)<Fa||(Math.abs(u)<Fa||Math.abs(h)<Fa||(Math.abs(Math.abs(r-s)-La)<Fa?u+h>2&&(a+=4*(r-s)):a+=Math.abs(h-2)<Fa?4*(r-g):((3*La+r-s)%(2*La)-La)*(h+u)),g=s,s=r,h=u);return a}function Ut(n,t){return((n=n.point)[0]<0?n[1]-La/2-Fa:La/2-n[1])-((t=t.point)[0]<0?t[1]-La/2-Fa:La/2-t[1])}function It(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,a){var o=i>0?La:-La,c=Math.abs(i-e);Math.abs(c-La)<Fa?(n.point(e,r=(r+a)/2>0?La/2:-La/2),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(o,r),n.point(i,r),t=0):u!==o&&c>=La&&(Math.abs(e-u)<Fa&&(e-=u*Fa),Math.abs(i-o)<Fa&&(i-=o*Fa),r=Vt(e,r,i,a),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(o,r),t=0),n.point(e=i,r=a),u=o},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function Vt(n,t,e,r){var u,i,a=Math.sin(n-e);return Math.abs(a)>Fa?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*a)):(t+r)/2}function Xt(n,t,e,r){var u;if(null==n)u=e*La/2,r.point(-La,u),r.point(0,u),r.point(La,u),r.point(La,0),r.point(La,-u),r.point(0,-u),r.point(-La,-u),r.point(-La,0),r.point(-La,u);else if(Math.abs(n[0]-t[0])>Fa){var i=(n[0]<t[0]?1:-1)*La;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Zt(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,l,f;return{lineStart:function(){l=c=!1,f=1},point:function(s,h){var g,p=[s,h],d=t(s,h),m=a?d?0:u(s,h):d?u(s+(0>s?La:-La),h):0;if(!e&&(l=c=d)&&n.lineStart(),d!==c&&(g=r(e,p),(Lt(e,g)||Lt(p,g))&&(p[0]+=Fa,p[1]+=Fa,d=t(p[0],p[1]))),d!==c)f=0,d?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(o&&e&&a^d){var v;m&i||!(v=r(p,e,!0))||(f=0,a?(n.lineStart(),n.point(v[0][0],v[0][1]),n.point(v[1][0],v[1][1]),n.lineEnd()):(n.point(v[1][0],v[1][1]),n.lineEnd(),n.lineStart(),n.point(v[0][0],v[0][1])))}!d||e&&Lt(e,p)||n.point(p[0],p[1]),e=p,c=d,i=m},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return f|(l&&c)<<1}}}function r(n,t,e){var r=At(n),u=At(t),a=[1,0,0],o=Nt(r,u),c=qt(o,o),l=o[0],f=c-l*l;if(!f)return!e&&n;var s=i*c/f,h=-i*l/f,g=Nt(a,o),p=Ct(a,s),d=Ct(o,h);Tt(p,d);var m=g,v=qt(p,m),y=qt(m,m),M=v*v-y*(qt(p,p)-1);if(!(0>M)){var x=Math.sqrt(M),b=Ct(m,(-v-x)/y);if(Tt(b,p),b=jt(b),!e)return b;var _,w=n[0],S=t[0],E=n[1],k=t[1];w>S&&(_=w,w=S,S=_);var A=S-w,q=Math.abs(A-La)<Fa,N=q||Fa>A;if(!q&&E>k&&(_=E,E=k,k=_),N?q?E+k>0^b[1]<(Math.abs(b[0]-w)<Fa?E:k):E<=b[1]&&b[1]<=k:A>La^(w<=b[0]&&b[0]<=S)){var T=Ct(m,(-v+x)/y);return Tt(T,p),[b,jt(T)]}}}function u(t,e){var r=a?n:La-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),a=i>0,o=Math.abs(i)>Fa,c=ie(n,6*Ha);return Pt(t,e,c)}function Bt(n,t,e,r){function u(r,u){return Math.abs(r[0]-n)<Fa?u>0?0:3:Math.abs(r[0]-e)<Fa?u>0?2:1:Math.abs(r[1]-t)<Fa?u>0?1:0:u>0?3:2}function i(n,t){return a(n.point,t.point)}function a(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}function o(u,i){var a=i[0]-u[0],o=i[1]-u[1],c=[0,1];return Math.abs(a)<Fa&&Math.abs(o)<Fa?n<=u[0]&&u[0]<=e&&t<=u[1]&&u[1]<=r:$t(n-u[0],a,c)&&$t(u[0]-e,-a,c)&&$t(t-u[1],o,c)&&$t(u[1]-r,-o,c)?(c[1]<1&&(i[0]=u[0]+c[1]*a,i[1]=u[1]+c[1]*o),c[0]>0&&(u[0]+=c[0]*a,u[1]+=c[0]*o),!0):!1}return function(c){function l(i){var a=u(i,-1),o=f([0===a||3===a?n:e,a>1?r:t]);return o}function f(n){for(var t=0,e=M.length,r=n[1],u=0;e>u;++u)for(var i=1,a=M[u],o=a.length,c=a[0];o>i;++i)b=a[i],c[1]<=r?b[1]>r&&s(c,b,n)>0&&++t:b[1]<=r&&s(c,b,n)<0&&--t,c=b;return 0!==t}function s(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(e[0]-n[0])*(t[1]-n[1])}function h(i,o,c,l){var f=0,s=0;if(null==i||(f=u(i,c))!==(s=u(o,c))||a(i,o)<0^c>0){do l.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+c+4)%4)!==s)}else l.point(o[0],o[1])}function g(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function p(n,t){g(n,t)&&c.point(n,t)}function d(){C.point=v,M&&M.push(x=[]),q=!0,A=!1,E=k=0/0}function m(){y&&(v(_,w),S&&A&&T.rejoin(),y.push(T.buffer())),C.point=p,A&&c.lineEnd()}function v(n,t){n=Math.max(-bo,Math.min(bo,n)),t=Math.max(-bo,Math.min(bo,t));var e=g(n,t);if(M&&x.push([n,t]),q)_=n,w=t,S=e,q=!1,e&&(c.lineStart(),c.point(n,t));else if(e&&A)c.point(n,t);else{var r=[E,k],u=[n,t];o(r,u)?(A||(c.lineStart(),c.point(r[0],r[1])),c.point(u[0],u[1]),e||c.lineEnd()):(c.lineStart(),c.point(n,t))}E=n,k=t,A=e}var y,M,x,_,w,S,E,k,A,q,N=c,T=Ot(),C={point:p,lineStart:d,lineEnd:m,polygonStart:function(){c=T,y=[],M=[]},polygonEnd:function(){c=N,(y=oa.merge(y)).length?(c.polygonStart(),Ft(y,i,l,h,c),c.polygonEnd()):f([n,t])&&(c.polygonStart(),c.lineStart(),h(null,null,1,c),c.lineEnd(),c.polygonEnd()),y=M=x=null}};return C}}function $t(n,t,e){if(Math.abs(t)<Fa)return 0>=n;var r=n/t;if(t>0){if(r>e[1])return!1;r>e[0]&&(e[0]=r)}else{if(r<e[0])return!1;r<e[1]&&(e[1]=r)}return!0}function Jt(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function Gt(n){function t(t){function r(e,r){e=n(e,r),t.point(e[0],e[1])}function i(){f=0/0,d.point=a,t.lineStart()}function a(r,i){var a=At([r,i]),o=n(r,i);e(f,s,l,h,g,p,f=o[0],s=o[1],l=r,h=a[0],g=a[1],p=a[2],u,t),t.point(f,s)}function o(){d.point=r,t.lineEnd()}function c(){var n,r,c,m,v,y,M;i(),d.point=function(t,e){a(n=t,r=e),c=f,m=s,v=h,y=g,M=p,d.point=a},d.lineEnd=function(){e(f,s,l,h,g,p,c,m,n,v,y,M,u,t),d.lineEnd=o,o()}}var l,f,s,h,g,p,d={point:r,lineStart:i,lineEnd:o,polygonStart:function(){t.polygonStart(),d.lineStart=c},polygonEnd:function(){t.polygonEnd(),d.lineStart=i}};return d}function e(t,u,i,a,o,c,l,f,s,h,g,p,d,m){var v=l-t,y=f-u,M=v*v+y*y;if(M>4*r&&d--){var x=a+h,b=o+g,_=c+p,w=Math.sqrt(x*x+b*b+_*_),S=Math.asin(_/=w),E=Math.abs(Math.abs(_)-1)<Fa?(i+s)/2:Math.atan2(b,x),k=n(E,S),A=k[0],q=k[1],N=A-t,T=q-u,C=y*N-v*T;(C*C/M>r||Math.abs((v*N+y*T)/M-.5)>.3)&&(e(t,u,i,a,o,c,A,q,E,x/=w,b/=w,_,d,m),m.point(A,q),e(A,q,E,x,b,_,l,f,s,h,g,p,d,m))}}var r=.5,u=16;return t.precision=function(n){return arguments.length?(u=(r=n*n)>0&&16,t):Math.sqrt(r)},t}function Kt(n){return Wt(function(){return n})()}function Wt(n){function t(n){return n=a(n[0]*Ha,n[1]*Ha),[n[0]*f+o,c-n[1]*f]}function e(n){return n=a.invert((n[0]-o)/f,(c-n[1])/f),n&&[n[0]*Pa,n[1]*Pa]}function r(){a=Jt(i=te(d,m,v),u);var n=u(g,p);return o=s-n[0]*f,c=h+n[1]*f,t}var u,i,a,o,c,l=Gt(function(n,t){return n=u(n,t),[n[0]*f+o,c-n[1]*f]}),f=150,s=480,h=250,g=0,p=0,d=0,m=0,v=0,y=xo,M=ft,x=null,b=null;return t.stream=function(n){return Qt(i,y(l(M(n))))},t.clipAngle=function(n){return arguments.length?(y=null==n?(x=n,xo):Zt((x=+n)*Ha),t):x},t.clipExtent=function(n){return arguments.length?(b=n,M=null==n?ft:Bt(n[0][0],n[0][1],n[1][0],n[1][1]),t):b},t.scale=function(n){return arguments.length?(f=+n,r()):f},t.translate=function(n){return arguments.length?(s=+n[0],h=+n[1],r()):[s,h]},t.center=function(n){return arguments.length?(g=n[0]%360*Ha,p=n[1]%360*Ha,r()):[g*Pa,p*Pa]},t.rotate=function(n){return arguments.length?(d=n[0]%360*Ha,m=n[1]%360*Ha,v=n.length>2?n[2]%360*Ha:0,r()):[d*Pa,m*Pa,v*Pa]},oa.rebind(t,l,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function Qt(n,t){return{point:function(e,r){r=n(e*Ha,r*Ha),e=r[0],t.point(e>La?e-2*La:-La>e?e+2*La:e,r[1])},sphere:function(){t.sphere()},lineStart:function(){t.lineStart()},lineEnd:function(){t.lineEnd()},polygonStart:function(){t.polygonStart()},polygonEnd:function(){t.polygonEnd()}}}function ne(n,t){return[n,t]}function te(n,t,e){return n?t||e?Jt(re(n),ue(t,e)):re(n):t||e?ue(t,e):ne}function ee(n){return function(t,e){return t+=n,[t>La?t-2*La:-La>t?t+2*La:t,e]}}function re(n){var t=ee(n);return t.invert=ee(-n),t}function ue(n,t){function e(n,t){var e=Math.cos(t),o=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),f=l*r+o*u;return[Math.atan2(c*i-f*a,o*r-l*u),Math.asin(Math.max(-1,Math.min(1,f*i+c*a)))]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),a=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),o=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),f=l*i-c*a;return[Math.atan2(c*i+l*a,o*r+f*u),Math.asin(Math.max(-1,Math.min(1,f*r-o*u)))]},e}function ie(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,a,o){null!=u?(u=ae(e,u),i=ae(e,i),(a>0?i>u:u>i)&&(u+=2*a*La)):(u=n+2*a*La,i=n);for(var c,l=a*t,f=u;a>0?f>i:i>f;f-=l)o.point((c=jt([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function ae(n,t){var e=At(t);e[0]-=n,zt(e);var r=O(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Fa)%(2*Math.PI)}function oe(n,t,e){var r=oa.range(n,t-Fa,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function ce(n,t,e){var r=oa.range(n,t-Fa,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function le(n){return n.source}function fe(n){return n.target}function se(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),a=Math.cos(r),o=Math.sin(r),c=u*Math.cos(n),l=u*Math.sin(n),f=a*Math.cos(e),s=a*Math.sin(e),h=2*Math.asin(Math.sqrt(V(r-t)+u*a*V(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*f,u=e*l+t*s,a=e*i+t*o;return[Math.atan2(u,r)*Pa,Math.atan2(a,Math.sqrt(r*r+u*u))*Pa]}:function(){return[n*Pa,t*Pa]};return p.distance=h,p}function he(){function n(n,u){var i=Math.sin(u*=Ha),a=Math.cos(u),o=Math.abs((n*=Ha)-t),c=Math.cos(o);_o+=Math.atan2(Math.sqrt((o=a*Math.sin(o))*o+(o=r*i-e*a*c)*o),e*i+r*a*c),t=n,e=i,r=a}var t,e,r;wo.point=function(u,i){t=u*Ha,e=Math.sin(i*=Ha),r=Math.cos(i),wo.point=n},wo.lineEnd=function(){wo.point=wo.lineEnd=N}}function ge(n){var t=0,e=La/3,r=Wt(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*La/180,e=n[1]*La/180):[180*(t/La),180*(e/La)]},u}function pe(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),a-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),a=Math.sqrt(i)/u;return e.invert=function(n,t){var e=a-t;return[Math.atan2(n,e)/u,Math.asin((i-(n*n+e*e)*u*u)/(2*u))]},e}function de(n,t){var e=n(t[0]),r=n([.5*(t[0][0]+t[1][0]),t[0][1]]),u=n([t[1][0],t[0][1]]),i=n(t[1]),a=r[1]-e[1],o=r[0]-e[0],c=u[1]-r[1],l=u[0]-r[0],f=a/o,s=c/l,h=.5*(f*s*(e[1]-u[1])+s*(e[0]+r[0])-f*(r[0]+u[0]))/(s-f),g=(.5*(e[0]+r[0])-h)/f+.5*(e[1]+r[1]),p=i[0]-h,d=i[1]-g,m=e[0]-h,v=e[1]-g,y=p*p+d*d,M=m*m+v*v,x=Math.atan2(d,p),b=Math.atan2(v,m);return function(t){var e=t[0]-h,r=t[1]-g,u=e*e+r*r,i=Math.atan2(r,e);return u>y&&M>u&&i>x&&b>i?n.invert(t):void 0}}function me(){function n(n,t){Eo+=u*n-r*t,r=n,u=t}var t,e,r,u;ko.point=function(i,a){ko.point=n,t=r=i,e=u=a},ko.lineEnd=function(){n(t,e)}}function ve(){function n(n,t){a.push("M",n,",",t,i)}function t(n,t){a.push("M",n,",",t),o.point=e}function e(n,t){a.push("L",n,",",t)}function r(){o.point=n}function u(){a.push("Z")}var i=we(4.5),a=[],o={point:n,lineStart:function(){o.point=t},lineEnd:r,polygonStart:function(){o.lineEnd=u},polygonEnd:function(){o.lineEnd=r,o.point=n},pointRadius:function(n){return i=we(n),o},result:function(){if(a.length){var n=a.join("");return a=[],n}}};return o}function ye(n,t){go||(mo+=n,vo+=t,++yo)}function Me(){function n(n,r){var u=n-t,i=r-e,a=Math.sqrt(u*u+i*i);mo+=a*(t+n)/2,vo+=a*(e+r)/2,yo+=a,t=n,e=r}var t,e;if(1!==go){if(!(1>go))return;go=1,mo=vo=yo=0}Ao.point=function(r,u){Ao.point=n,t=r,e=u}}function xe(){Ao.point=ye}function be(){function n(n,t){var e=u*n-r*t;mo+=e*(r+n),vo+=e*(u+t),yo+=3*e,r=n,u=t}var t,e,r,u;2>go&&(go=2,mo=vo=yo=0),Ao.point=function(i,a){Ao.point=n,t=r=i,e=u=a},Ao.lineEnd=function(){n(t,e)}}function _e(n){function t(t,e){n.moveTo(t,e),n.arc(t,e,a,0,2*La)}function e(t,e){n.moveTo(t,e),o.point=r}function r(t,e){n.lineTo(t,e)}function u(){o.point=t}function i(){n.closePath()}var a=4.5,o={point:t,lineStart:function(){o.point=e},lineEnd:u,polygonStart:function(){o.lineEnd=i},polygonEnd:function(){o.lineEnd=u,o.point=t},pointRadius:function(n){return a=n,o},result:N};return o}function we(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Se(n){var t=Gt(function(t,e){return n([t*Pa,e*Pa])});return function(n){return n=t(n),{point:function(t,e){n.point(t*Ha,e*Ha)},sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}}function Ee(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),a=Math.cos(u);return[Math.atan2(n*i,r*a),Math.asin(r&&e*i/r)]},e}function ke(n,t){function e(n,t){var e=Math.abs(Math.abs(t)-La/2)<Fa?0:a/Math.pow(u(t),i);return[e*Math.sin(i*n),a-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(La/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),a=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=a-t,r=R(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(a/r,1/i))-La/2]},e):qe}function Ae(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return Math.abs(u)<Fa?ne:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-R(u)*Math.sqrt(n*n+e*e)]},e)}function qe(n,t){return[n,Math.log(Math.tan(La/4+t/2))]}function Ne(n){var t,e=Kt(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var a=i.apply(e,arguments);if(a===e){if(t=null==n){var o=La*r(),c=u();i([[c[0]-o,c[1]-o],[c[0]+o,c[1]+o]])}}else t&&(a=null);return a},e.clipExtent(null)}function Te(n,t){var e=Math.cos(t)*Math.sin(n);return[Math.log((1+e)/(1-e))/2,Math.atan2(Math.tan(t),Math.cos(n))]}function Ce(n){function t(t){function a(){l.push("M",i(n(f),o))}for(var c,l=[],f=[],s=-1,h=t.length,g=lt(e),p=lt(r);++s<h;)u.call(this,c=t[s],s)?f.push([+g.call(this,c,s),+p.call(this,c,s)]):f.length&&(a(),f=[]);return f.length&&a(),l.length?l.join(""):null}var e=ze,r=De,u=Dt,i=je,a=i.key,o=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(a="function"==typeof n?i=n:(i=Do.get(n)||je).key,t):a},t.tension=function(n){return arguments.length?(o=n,t):o},t}function ze(n){return n[0]}function De(n){return n[1]}function je(n){return n.join("L")}function Le(n){return je(n)+"Z"}function Fe(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function He(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function Pe(n,t){return n.length<4?je(n):n[1]+Ye(n.slice(1,n.length-1),Ue(n,t))}function Re(n,t){return n.length<3?je(n):n[0]+Ye((n.push(n[0]),n),Ue([n[n.length-2]].concat(n,[n[1]]),t))}function Oe(n,t){return n.length<3?je(n):n[0]+Ye(n,Ue(n,t))}function Ye(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return je(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],a=t[0],o=a,c=1;if(e&&(r+="Q"+(i[0]-a[0]*2/3)+","+(i[1]-a[1]*2/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){o=t[1],i=n[c],c++,r+="C"+(u[0]+a[0])+","+(u[1]+a[1])+","+(i[0]-o[0])+","+(i[1]-o[1])+","+i[0]+","+i[1];for(var l=2;l<t.length;l++,c++)i=n[c],o=t[l],r+="S"+(i[0]-o[0])+","+(i[1]-o[1])+","+i[0]+","+i[1]}if(e){var f=n[c];r+="Q"+(i[0]+o[0]*2/3)+","+(i[1]+o[1]*2/3)+","+f[0]+","+f[1]}return r}function Ue(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],a=n[1],o=1,c=n.length;++o<c;)e=i,i=a,a=n[o],r.push([u*(a[0]-e[0]),u*(a[1]-e[1])]);return r}function Ie(n){if(n.length<3)return je(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],a=[u,u,u,(r=n[1])[0]],o=[i,i,i,r[1]],c=[u,",",i];for($e(c,a,o);++t<e;)r=n[t],a.shift(),a.push(r[0]),o.shift(),o.push(r[1]),$e(c,a,o);for(t=-1;++t<2;)a.shift(),a.push(r[0]),o.shift(),o.push(r[1]),$e(c,a,o);return c.join("")}function Ve(n){if(n.length<4)return je(n);for(var t,e=[],r=-1,u=n.length,i=[0],a=[0];++r<3;)t=n[r],i.push(t[0]),a.push(t[1]);for(e.push(Be(Fo,i)+","+Be(Fo,a)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),a.shift(),a.push(t[1]),$e(e,i,a);return e.join("")}function Xe(n){for(var t,e,r=-1,u=n.length,i=u+4,a=[],o=[];++r<4;)e=n[r%u],a.push(e[0]),o.push(e[1]);for(t=[Be(Fo,a),",",Be(Fo,o)],--r;++r<i;)e=n[r%u],a.shift(),a.push(e[0]),o.shift(),o.push(e[1]),$e(t,a,o);return t.join("")}function Ze(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],a=n[0][1],o=n[e][0]-i,c=n[e][1]-a,l=-1;++l<=e;)r=n[l],u=l/e,r[0]=t*r[0]+(1-t)*(i+u*o),r[1]=t*r[1]+(1-t)*(a+u*c);return Ie(n)}function Be(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function $e(n,t,e){n.push("C",Be(jo,t),",",Be(jo,e),",",Be(Lo,t),",",Be(Lo,e),",",Be(Fo,t),",",Be(Fo,e))}function Je(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Ge(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],a=r[0]=Je(u,i);++t<e;)r[t]=(a+(a=Je(u=i,i=n[t+1])))/2;return r[t]=a,r}function Ke(n){for(var t,e,r,u,i=[],a=Ge(n),o=-1,c=n.length-1;++o<c;)t=Je(n[o],n[o+1]),Math.abs(t)<1e-6?a[o]=a[o+1]=0:(e=a[o]/t,r=a[o+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),a[o]=u*e,a[o+1]=u*r));for(o=-1;++o<=c;)u=(n[Math.min(c,o+1)][0]-n[Math.max(0,o-1)][0])/(6*(1+a[o]*a[o])),i.push([u||0,a[o]*u||0]);return i}function We(n){return n.length<3?je(n):n[0]+Ye(n,Ke(n))}function Qe(n,t,e,r){var u,i,a,o,c,l,f;return u=r[n],i=u[0],a=u[1],u=r[t],o=u[0],c=u[1],u=r[e],l=u[0],f=u[1],(f-a)*(o-i)-(c-a)*(l-i)>0}function nr(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function tr(n,t,e,r){var u=n[0],i=e[0],a=t[0]-u,o=r[0]-i,c=n[1],l=e[1],f=t[1]-c,s=r[1]-l,h=(o*(c-l)-s*(u-i))/(s*a-o*f);
return[u+h*a,c+h*f]}function er(n,t){var e={list:n.map(function(n,t){return{index:t,x:n[0],y:n[1]}}).sort(function(n,t){return n.y<t.y?-1:n.y>t.y?1:n.x<t.x?-1:n.x>t.x?1:0}),bottomSite:null},r={list:[],leftEnd:null,rightEnd:null,init:function(){r.leftEnd=r.createHalfEdge(null,"l"),r.rightEnd=r.createHalfEdge(null,"l"),r.leftEnd.r=r.rightEnd,r.rightEnd.l=r.leftEnd,r.list.unshift(r.leftEnd,r.rightEnd)},createHalfEdge:function(n,t){return{edge:n,side:t,vertex:null,l:null,r:null}},insert:function(n,t){t.l=n,t.r=n.r,n.r.l=t,n.r=t},leftBound:function(n){var t=r.leftEnd;do t=t.r;while(t!=r.rightEnd&&u.rightOf(t,n));return t=t.l},del:function(n){n.l.r=n.r,n.r.l=n.l,n.edge=null},right:function(n){return n.r},left:function(n){return n.l},leftRegion:function(n){return n.edge==null?e.bottomSite:n.edge.region[n.side]},rightRegion:function(n){return n.edge==null?e.bottomSite:n.edge.region[Ho[n.side]]}},u={bisect:function(n,t){var e={region:{l:n,r:t},ep:{l:null,r:null}},r=t.x-n.x,u=t.y-n.y,i=r>0?r:-r,a=u>0?u:-u;return e.c=n.x*r+n.y*u+.5*(r*r+u*u),i>a?(e.a=1,e.b=u/r,e.c/=r):(e.b=1,e.a=r/u,e.c/=u),e},intersect:function(n,t){var e=n.edge,r=t.edge;if(!e||!r||e.region.r==r.region.r)return null;var u=e.a*r.b-e.b*r.a;if(Math.abs(u)<1e-10)return null;var i,a,o=(e.c*r.b-r.c*e.b)/u,c=(r.c*e.a-e.c*r.a)/u,l=e.region.r,f=r.region.r;l.y<f.y||l.y==f.y&&l.x<f.x?(i=n,a=e):(i=t,a=r);var s=o>=a.region.r.x;return s&&i.side==="l"||!s&&i.side==="r"?null:{x:o,y:c}},rightOf:function(n,t){var e=n.edge,r=e.region.r,u=t.x>r.x;if(u&&n.side==="l")return 1;if(!u&&n.side==="r")return 0;if(e.a===1){var i=t.y-r.y,a=t.x-r.x,o=0,c=0;if(!u&&e.b<0||u&&e.b>=0?c=o=i>=e.b*a:(c=t.x+t.y*e.b>e.c,e.b<0&&(c=!c),c||(o=1)),!o){var l=r.x-e.region.l.x;c=e.b*(a*a-i*i)<l*i*(1+2*a/l+e.b*e.b),e.b<0&&(c=!c)}}else{var f=e.c-e.a*t.x,s=t.y-f,h=t.x-r.x,g=f-r.y;c=s*s>h*h+g*g}return n.side==="l"?c:!c},endPoint:function(n,e,r){n.ep[e]=r,n.ep[Ho[e]]&&t(n)},distance:function(n,t){var e=n.x-t.x,r=n.y-t.y;return Math.sqrt(e*e+r*r)}},i={list:[],insert:function(n,t,e){n.vertex=t,n.ystar=t.y+e;for(var r=0,u=i.list,a=u.length;a>r;r++){var o=u[r];if(!(n.ystar>o.ystar||n.ystar==o.ystar&&t.x>o.vertex.x))break}u.splice(r,0,n)},del:function(n){for(var t=0,e=i.list,r=e.length;r>t&&e[t]!=n;++t);e.splice(t,1)},empty:function(){return i.list.length===0},nextEvent:function(n){for(var t=0,e=i.list,r=e.length;r>t;++t)if(e[t]==n)return e[t+1];return null},min:function(){var n=i.list[0];return{x:n.vertex.x,y:n.ystar}},extractMin:function(){return i.list.shift()}};r.init(),e.bottomSite=e.list.shift();for(var a,o,c,l,f,s,h,g,p,d,m,v,y,M=e.list.shift();;)if(i.empty()||(a=i.min()),M&&(i.empty()||M.y<a.y||M.y==a.y&&M.x<a.x))o=r.leftBound(M),c=r.right(o),h=r.rightRegion(o),v=u.bisect(h,M),s=r.createHalfEdge(v,"l"),r.insert(o,s),d=u.intersect(o,s),d&&(i.del(o),i.insert(o,d,u.distance(d,M))),o=s,s=r.createHalfEdge(v,"r"),r.insert(o,s),d=u.intersect(s,c),d&&i.insert(s,d,u.distance(d,M)),M=e.list.shift();else{if(i.empty())break;o=i.extractMin(),l=r.left(o),c=r.right(o),f=r.right(c),h=r.leftRegion(o),g=r.rightRegion(c),m=o.vertex,u.endPoint(o.edge,o.side,m),u.endPoint(c.edge,c.side,m),r.del(o),i.del(c),r.del(c),y="l",h.y>g.y&&(p=h,h=g,g=p,y="r"),v=u.bisect(h,g),s=r.createHalfEdge(v,y),r.insert(l,s),u.endPoint(v,Ho[y],m),d=u.intersect(l,s),d&&(i.del(l),i.insert(l,d,u.distance(d,h))),d=u.intersect(s,f),d&&i.insert(s,d,u.distance(d,h))}for(o=r.right(r.leftEnd);o!=r.rightEnd;o=r.right(o))t(o.edge)}function rr(n){return n.x}function ur(n){return n.y}function ir(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function ar(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var a=.5*(e+u),o=.5*(r+i),c=t.nodes;c[0]&&ar(n,c[0],e,r,a,o),c[1]&&ar(n,c[1],a,r,u,o),c[2]&&ar(n,c[2],e,o,a,i),c[3]&&ar(n,c[3],a,o,u,i)}}function or(n,t){n=oa.rgb(n),t=oa.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,a=t.g-r,o=t.b-u;return function(n){return"#"+rt(Math.round(e+i*n))+rt(Math.round(r+a*n))+rt(Math.round(u+o*n))}}function cr(n){var t=[n.a,n.b],e=[n.c,n.d],r=fr(t),u=lr(t,e),i=fr(sr(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Pa,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*Pa:0}function lr(n,t){return n[0]*t[0]+n[1]*t[1]}function fr(n){var t=Math.sqrt(lr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function sr(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function hr(n,t){return t-=n,function(e){return n+t*e}}function gr(n,t){var e,r=[],u=[],i=oa.transform(n),a=oa.transform(t),o=i.translate,c=a.translate,l=i.rotate,f=a.rotate,s=i.skew,h=a.skew,g=i.scale,p=a.scale;return o[0]!=c[0]||o[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:hr(o[0],c[0])},{i:3,x:hr(o[1],c[1])})):c[0]||c[1]?r.push("translate("+c+")"):r.push(""),l!=f?(l-f>180?f+=360:f-l>180&&(l+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:hr(l,f)})):f&&r.push(r.pop()+"rotate("+f+")"),s!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:hr(s,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:hr(g[0],p[0])},{i:e-2,x:hr(g[1],p[1])})):(p[0]!=1||p[1]!=1)&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function pr(n,t){var e,r={},u={};for(e in n)e in t?r[e]=vr(e)(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function dr(n,t){var e,r,u,i,a,o=0,c=0,l=[],f=[];for(Ro.lastIndex=0,r=0;e=Ro.exec(t);++r)e.index&&l.push(t.substring(o,c=e.index)),f.push({i:l.length,x:e[0]}),l.push(null),o=Ro.lastIndex;for(o<t.length&&l.push(t.substring(o)),r=0,i=f.length;(e=Ro.exec(n))&&i>r;++r)if(a=f[r],a.x==e[0]){if(a.i)if(l[a.i+1]==null)for(l[a.i-1]+=a.x,l.splice(a.i,1),u=r+1;i>u;++u)f[u].i--;else for(l[a.i-1]+=a.x+l[a.i+1],l.splice(a.i,2),u=r+1;i>u;++u)f[u].i-=2;else if(l[a.i+1]==null)l[a.i]=a.x;else for(l[a.i]=a.x+l[a.i+1],l.splice(a.i+1,1),u=r+1;i>u;++u)f[u].i--;f.splice(r,1),i--,r--}else a.x=hr(parseFloat(e[0]),parseFloat(a.x));for(;i>r;)a=f.pop(),l[a.i+1]==null?l[a.i]=a.x:(l[a.i]=a.x+l[a.i+1],l.splice(a.i+1,1)),i--;return l.length===1?l[0]==null?f[0].x:function(){return t}:function(n){for(r=0;i>r;++r)l[(a=f[r]).i]=a.x(n);return l.join("")}}function mr(n,t){for(var e,r=oa.interpolators.length;--r>=0&&!(e=oa.interpolators[r](n,t)););return e}function vr(n){return"transform"==n?gr:mr}function yr(n,t){var e,r=[],u=[],i=n.length,a=t.length,o=Math.min(n.length,t.length);for(e=0;o>e;++e)r.push(mr(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;a>e;++e)u[e]=t[e];return function(n){for(e=0;o>e;++e)u[e]=r[e](n);return u}}function Mr(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function xr(n){return function(t){return 1-n(1-t)}}function br(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function _r(n){return n*n}function wr(n){return n*n*n}function Sr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function kr(n){return 1-Math.cos(n*La/2)}function Ar(n){return Math.pow(2,10*(n-1))}function qr(n){return 1-Math.sqrt(1-n*n)}function Nr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/(2*La)*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,10*-r)*Math.sin(2*(r-e)*La/t)}}function Tr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Cr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function zr(n,t){n=oa.hcl(n),t=oa.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,a=t.c-r,o=t.l-u;return i>180?i-=360:-180>i&&(i+=360),function(n){return B(e+i*n,r+a*n,u+o*n)+""}}function Dr(n,t){n=oa.hsl(n),t=oa.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,a=t.s-r,o=t.l-u;return i>180?i-=360:-180>i&&(i+=360),function(n){return P(e+i*n,r+a*n,u+o*n)+""}}function jr(n,t){n=oa.lab(n),t=oa.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,a=t.a-r,o=t.b-u;return function(n){return G(e+i*n,r+a*n,u+o*n)+""}}function Lr(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Fr(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return(e-n)*t}}function Hr(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return Math.max(0,Math.min(1,(e-n)*t))}}function Pr(n){for(var t=n.source,e=n.target,r=Or(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function Rr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Or(n,t){if(n===t)return n;for(var e=Rr(n),r=Rr(t),u=e.pop(),i=r.pop(),a=null;u===i;)a=u,u=e.pop(),i=r.pop();return a}function Yr(n){n.fixed|=2}function Ur(n){n.fixed&=-7}function Ir(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Vr(n){n.fixed&=-5}function Xr(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,a=n.nodes,o=a.length,c=-1;++c<o;)i=a[c],null!=i&&(Xr(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var l=t*e[n.point.index];n.charge+=n.pointCharge=l,r+=l*n.point.x,u+=l*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Zr(n,t){return oa.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=Gr,n}function Br(n){return n.children}function $r(n){return n.value}function Jr(n,t){return t.value-n.value}function Gr(n){return oa.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function Kr(n){return n.x}function Wr(n){return n.y}function Qr(n,t,e){n.y0=t,n.y=e}function nu(n){return oa.range(n.length)}function tu(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function eu(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function ru(n){return n.reduce(uu,0)}function uu(n,t){return n+t[1]}function iu(n,t){return au(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function au(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function ou(n){return[oa.min(n),oa.max(n)]}function cu(n,t){return n.parent==t.parent?1:2}function lu(n){var t=n.children;return t&&t.length?t[0]:n._tree.thread}function fu(n){var t,e=n.children;return e&&(t=e.length)?e[t-1]:n._tree.thread}function su(n,t){var e=n.children;if(e&&(u=e.length))for(var r,u,i=-1;++i<u;)t(r=su(e[i],t),n)>0&&(n=r);return n}function hu(n,t){return n.x-t.x}function gu(n,t){return t.x-n.x}function pu(n,t){return n.depth-t.depth}function du(n,t){function e(n,r){var u=n.children;if(u&&(a=u.length))for(var i,a,o=null,c=-1;++c<a;)i=u[c],e(i,o),o=i;t(n,r)}e(n,null)}function mu(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i]._tree,t.prelim+=e,t.mod+=e,e+=t.shift+(r+=t.change)}function vu(n,t,e){n=n._tree,t=t._tree;var r=e/(t.number-n.number);n.change+=r,t.change-=r,t.shift+=e,t.prelim+=e,t.mod+=e}function yu(n,t,e){return n._tree.ancestor.parent==t.parent?n._tree.ancestor:e}function Mu(n,t){return n.value-t.value}function xu(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function bu(n,t){n._pack_next=t,t._pack_prev=n}function _u(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return u*u-e*e-r*r>.001}function wu(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(l=e.length)){var e,r,u,i,a,o,c,l,f=1/0,s=-1/0,h=1/0,g=-1/0;if(e.forEach(Su),r=e[0],r.x=-r.r,r.y=0,t(r),l>1&&(u=e[1],u.x=u.r,u.y=0,t(u),l>2))for(i=e[2],Au(r,u,i),t(i),xu(r,i),r._pack_prev=i,xu(i,u),u=r._pack_next,a=3;l>a;a++){Au(r,u,i=e[a]);var p=0,d=1,m=1;for(o=u._pack_next;o!==u;o=o._pack_next,d++)if(_u(o,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==o._pack_prev&&!_u(c,i);c=c._pack_prev,m++);p?(m>d||d==m&&u.r<r.r?bu(r,u=o):bu(r=c,u),a--):(xu(r,i),u=i,t(i))}var v=(f+s)/2,y=(h+g)/2,M=0;for(a=0;l>a;a++)i=e[a],i.x-=v,i.y-=y,M=Math.max(M,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=M,e.forEach(Eu)}}function Su(n){n._pack_next=n._pack_prev=n}function Eu(n){delete n._pack_next,delete n._pack_prev}function ku(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,a=u.length;++i<a;)ku(u[i],t,e,r)}function Au(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var a=t.r+e.r,o=u*u+i*i;a*=a,r*=r;var c=.5+(r-a)/(2*o),l=Math.sqrt(Math.max(0,2*a*(r+o)-(r-=o)*r-a*a))/(2*o);e.x=n.x+c*u+l*i,e.y=n.y+c*i-l*u}else e.x=n.x+r,e.y=n.y}function qu(n){return 1+oa.max(n,function(n){return n.y})}function Nu(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Tu(n){var t=n.children;return t&&t.length?Tu(t[0]):n}function Cu(n){var t,e=n.children;return e&&(t=e.length)?Cu(e[t-1]):n}function zu(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Du(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function ju(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Lu(n){return n.rangeExtent?n.rangeExtent():ju(n.range())}function Fu(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Hu(n,t){var e,r=0,u=n.length-1,i=n[r],a=n[u];return i>a&&(e=r,r=u,u=e,e=i,i=a,a=e),(t=t(a-i))&&(n[r]=t.floor(i),n[u]=t.ceil(a)),n}function Pu(n,t,e,r){var u=[],i=[],a=0,o=Math.min(n.length,t.length)-1;for(n[o]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++a<=o;)u.push(e(n[a-1],n[a])),i.push(r(t[a-1],t[a]));return function(t){var e=oa.bisect(n,t,1,o)-1;return i[e](u[e](t))}}function Ru(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?Pu:Fu,c=r?Hr:Fr;return a=u(n,t,c,e),o=u(t,n,c,mr),i}function i(n){return a(n)}var a,o;return i.invert=function(n){return o(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Lr)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Iu(n,t)},i.tickFormat=function(t,e){return Vu(n,t,e)},i.nice=function(){return Hu(n,Yu),u()},i.copy=function(){return Ru(n,t,e,r)},u()}function Ou(n,t){return oa.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Yu(n){return n=Math.pow(10,Math.round(Math.log(n)/Math.LN10)-1),n&&{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}}function Uu(n,t){var e=ju(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Iu(n,t){return oa.range.apply(oa,Uu(n,t))}function Vu(n,t,e){var r=-Math.floor(Math.log(Uu(n,t)[2])/Math.LN10+.01);return oa.format(e?e.replace(ro,function(n,t,e,u,i,a,o,c,l,f){return[t,e,u,i,a,o,c,l||"."+(r-2*("%"===f)),f].join("")}):",."+r+"f")}function Xu(n,t,e,r){function u(t){return n(e(t))}return u.invert=function(t){return r(n.invert(t))},u.domain=function(t){return arguments.length?(t[0]<0?(e=$u,r=Ju):(e=Zu,r=Bu),n.domain(t.map(e)),u):n.domain().map(r)},u.base=function(n){return arguments.length?(t=+n,u):t},u.nice=function(){return n.domain(Hu(n.domain(),Gu(t))),u},u.ticks=function(){var u=ju(n.domain()),i=[];if(u.every(isFinite)){var a=Math.log(t),o=Math.floor(u[0]/a),c=Math.ceil(u[1]/a),l=r(u[0]),f=r(u[1]),s=t%1?2:t;if(e===$u)for(i.push(-Math.pow(t,-o));o++<c;)for(var h=s-1;h>0;h--)i.push(-Math.pow(t,-o)*h);else{for(;c>o;o++)for(var h=1;s>h;h++)i.push(Math.pow(t,o)*h);i.push(Math.pow(t,o))}for(o=0;i[o]<l;o++);for(c=i.length;i[c-1]>f;c--);i=i.slice(o,c)}return i},u.tickFormat=function(n,i){if(arguments.length<2&&(i=$o),!arguments.length)return i;var a,o=Math.log(t),c=Math.max(.1,n/u.ticks().length),l=e===$u?(a=-1e-12,Math.floor):(a=1e-12,Math.ceil);return function(n){return n/r(o*l(e(n)/o+a))<=c?i(n):""}},u.copy=function(){return Xu(n.copy(),t,e,r)},Ou(u,n)}function Zu(n){return Math.log(0>n?0:n)}function Bu(n){return Math.exp(n)}function $u(n){return-Math.log(n>0?0:-n)}function Ju(n){return-Math.exp(-n)}function Gu(n){n=Math.log(n);var t={floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}};return function(){return t}}function Ku(n,t){function e(t){return n(r(t))}var r=Wu(t),u=Wu(1/t);return e.invert=function(t){return u(n.invert(t))},e.domain=function(t){return arguments.length?(n.domain(t.map(r)),e):n.domain().map(u)},e.ticks=function(n){return Iu(e.domain(),n)},e.tickFormat=function(n,t){return Vu(e.domain(),n,t)},e.nice=function(){return e.domain(Hu(e.domain(),Yu))},e.exponent=function(n){if(!arguments.length)return t;var i=e.domain();return r=Wu(t=n),u=Wu(1/t),e.domain(i)},e.copy=function(){return Ku(n.copy(),t)},Ou(e,n)}function Wu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Qu(n,t){function e(t){return a[((i.get(t)||i.set(t,n.push(t)))-1)%a.length]}function r(t,e){return oa.range(n.length).map(function(n){return t+e*n})}var i,a,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new u;for(var a,o=-1,c=r.length;++o<c;)i.has(a=r[o])||i.set(a,n.push(a));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(a=n,o=0,t={t:"range",a:arguments},e):a},e.rangePoints=function(u,i){arguments.length<2&&(i=0);var c=u[0],l=u[1],f=(l-c)/(Math.max(1,n.length-1)+i);return a=r(n.length<2?(c+l)/2:c+f*i/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var l=u[1]<u[0],f=u[l-0],s=u[1-l],h=(s-f)/(n.length-i+2*c);return a=r(f+h*c,h),l&&a.reverse(),o=h*(1-i),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var l=u[1]<u[0],f=u[l-0],s=u[1-l],h=Math.floor((s-f)/(n.length-i+2*c)),g=s-f-(n.length-i)*h;return a=r(f+Math.round(g/2),h),l&&a.reverse(),o=Math.round(h*(1-i)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return ju(t.a[0])},e.copy=function(){return Qu(n,t)},e.domain(n)}function ni(n,t){function e(){var e=0,i=t.length;for(u=[];++e<i;)u[e-1]=oa.quantile(n,e/i);return r}function r(n){return isNaN(n=+n)?0/0:t[oa.bisect(u,n)]}var u;return r.domain=function(t){return arguments.length?(n=t.filter(function(n){return!isNaN(n)}).sort(oa.ascending),e()):n},r.range=function(n){return arguments.length?(t=n,e()):t},r.quantiles=function(){return u},r.copy=function(){return ni(n,t)},e()}function ti(n,t,e){function r(t){return e[Math.max(0,Math.min(a,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),a=e.length-1,r}var i,a;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.copy=function(){return ti(n,t,e)},u()}function ei(n,t){function e(e){return t[oa.bisect(n,e)]}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.copy=function(){return ei(n,t)},e}function ri(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Iu(n,t)},t.tickFormat=function(t,e){return Vu(n,t,e)},t.copy=function(){return ri(n)},t}function ui(n){return n.innerRadius}function ii(n){return n.outerRadius}function ai(n){return n.startAngle}function oi(n){return n.endAngle}function ci(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]+Qo,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function li(n){function t(t){function c(){d.push("M",o(n(v),s),f,l(n(m.reverse()),s),"Z")}for(var h,g,p,d=[],m=[],v=[],y=-1,M=t.length,x=lt(e),b=lt(u),_=e===r?function(){return g}:lt(r),w=u===i?function(){return p}:lt(i);++y<M;)a.call(this,h=t[y],y)?(m.push([g=+x.call(this,h,y),p=+b.call(this,h,y)]),v.push([+_.call(this,h,y),+w.call(this,h,y)])):m.length&&(c(),m=[],v=[]);return m.length&&c(),d.length?d.join(""):null}var e=ze,r=ze,u=0,i=De,a=Dt,o=je,c=o.key,l=o,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(a=n,t):a},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?o=n:(o=Do.get(n)||je).key,l=o.reverse||o,f=o.closed?"M":"L",t):c},t.tension=function(n){return arguments.length?(s=n,t):s},t}function fi(n){return n.radius}function si(n){return[n.x,n.y]}function hi(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]+Qo;return[e*Math.cos(r),e*Math.sin(r)]}}function gi(){return 64}function pi(){return"circle"}function di(n){var t=Math.sqrt(n/La);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function mi(n,t){return Ma(n,ic),n.id=t,n}function vi(n,t,e,r){var u=n.id;return D(n,"function"==typeof e?function(n,i,a){n.__transition__[u].tween.set(t,r(e.call(n,n.__data__,i,a)))}:(e=r(e),function(n){n.__transition__[u].tween.set(t,e)}))}function yi(n){return null==n&&(n=""),function(){this.textContent=n}}function Mi(n,t,e,r){var i=n.__transition__||(n.__transition__={active:0,count:0}),a=i[e];if(!a){var o=r.time;return a=i[e]={tween:new u,event:oa.dispatch("start","end"),time:o,ease:r.ease,delay:r.delay,duration:r.duration},++i.count,oa.timer(function(r){function u(r){return i.active>e?l():(i.active=e,h.start.call(n,f,t),a.tween.forEach(function(e,r){(r=r.call(n,f,t))&&d.push(r)}),c(r)||oa.timer(c,0,o),1)}function c(r){if(i.active!==e)return l();for(var u=(r-g)/p,a=s(u),o=d.length;o>0;)d[--o].call(n,a);return u>=1?(l(),h.end.call(n,f,t),1):void 0}function l(){return--i.count?delete i[e]:delete n.__transition__,1}var f=n.__data__,s=a.ease,h=a.event,g=a.delay,p=a.duration,d=[];return r>=g?u(r):oa.timer(u,g,o),1},0,o),a}}function xi(n,t){n.attr("transform",function(n){return"translate("+t(n)+",0)"})}function bi(n,t){n.attr("transform",function(n){return"translate(0,"+t(n)+")"})}function _i(n,t,e){if(r=[],e&&t.length>1){for(var r,u,i,a=ju(n.domain()),o=-1,c=t.length,l=(t[1]-t[0])/++e;++o<c;)for(u=e;--u>0;)(i=+t[o]-u*l)>=a[0]&&r.push(i);for(--o,u=0;++u<e&&(i=+t[o]+u*l)<a[1];)r.push(i)}return r}function wi(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Si(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new hc(e-1)),1),e}function i(n,e){return t(n=new hc(+n),e),n}function a(n,r,i){var a=u(n),o=[];if(i>1)for(;r>a;)e(a)%i||o.push(new Date(+a)),t(a,1);else for(;r>a;)o.push(new Date(+a)),t(a,1);return o}function o(n,t,e){try{hc=wi;var r=new wi;return r._=n,a(r,t,e)}finally{hc=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=a;var c=n.utc=Ei(n);return c.floor=c,c.round=Ei(r),c.ceil=Ei(u),c.offset=Ei(i),c.range=o,n}function Ei(n){return function(t,e){try{hc=wi;var r=new wi;return r._=t,n(r,e)._}finally{hc=Date}}}function ki(n,t,e,r){for(var u,i,a=0,o=t.length,c=e.length;o>a;){if(r>=c)return-1;if(u=t.charCodeAt(a++),37===u){if(i=Tc[t.charAt(a++)],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function Ai(n){return RegExp("^(?:"+n.map(oa.requote).join("|")+")","i")}function qi(n){for(var t=new u,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Ni(n,t,e){n+="";var r=n.length;return e>r?Array(e-r+1).join(t)+n:n}function Ti(n,t,e){wc.lastIndex=0;var r=wc.exec(t.substring(e));return r?e+=r[0].length:-1}function Ci(n,t,e){_c.lastIndex=0;var r=_c.exec(t.substring(e));return r?e+=r[0].length:-1}function zi(n,t,e){kc.lastIndex=0;var r=kc.exec(t.substring(e));return r?(n.m=Ac.get(r[0].toLowerCase()),e+=r[0].length):-1}function Di(n,t,e){Sc.lastIndex=0;var r=Sc.exec(t.substring(e));return r?(n.m=Ec.get(r[0].toLowerCase()),e+=r[0].length):-1}function ji(n,t,e){return ki(n,""+Nc.c,t,e)}function Li(n,t,e){return ki(n,""+Nc.x,t,e)}function Fi(n,t,e){return ki(n,""+Nc.X,t,e)}function Hi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+4));return r?(n.y=+r[0],e+=r[0].length):-1}function Pi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.y=Ri(+r[0]),e+=r[0].length):-1}function Ri(n){return n+(n>68?1900:2e3)}function Oi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.m=r[0]-1,e+=r[0].length):-1}function Yi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.d=+r[0],e+=r[0].length):-1}function Ui(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.H=+r[0],e+=r[0].length):-1}function Ii(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.M=+r[0],e+=r[0].length):-1}function Vi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+2));return r?(n.S=+r[0],e+=r[0].length):-1}function Xi(n,t,e){Cc.lastIndex=0;var r=Cc.exec(t.substring(e,e+3));return r?(n.L=+r[0],e+=r[0].length):-1}function Zi(n,t,e){var r=zc.get(t.substring(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}function Bi(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=~~(Math.abs(t)/60),u=Math.abs(t)%60;return e+Ni(r,"0",2)+Ni(u,"0",2)}function $i(n){return n.toISOString()}function Ji(n,t,e){function r(t){return n(t)}return r.invert=function(t){return Ki(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Ki)},r.nice=function(n){return r.domain(Hu(r.domain(),function(){return n}))},r.ticks=function(e,u){var i=Gi(r.domain());if("function"!=typeof e){var a=i[1]-i[0],o=a/e,c=oa.bisect(jc,o);if(c==jc.length)return t.year(i,e);if(!c)return n.ticks(e).map(Ki);Math.log(o/jc[c-1])<Math.log(jc[c]/o)&&--c,e=t[c],u=e[1],e=e[0].range}return e(i[0],new Date(+i[1]+1),u)},r.tickFormat=function(){return e},r.copy=function(){return Ji(n.copy(),t,e)},oa.rebind(r,n,"range","rangeRound","interpolate","clamp")}function Gi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ki(n){return new Date(n)}function Wi(n){return function(t){for(var e=n.length-1,r=n[e];!r[1](t);)r=n[--e];return r[0](t)}}function Qi(n){var t=new Date(n,0,1);return t.setFullYear(n),t}function na(n){var t=n.getFullYear(),e=Qi(t),r=Qi(t+1);return t+(n-e)/(r-e)}function ta(n){var t=new Date(Date.UTC(n,0,1));return t.setUTCFullYear(n),t}function ea(n){var t=n.getUTCFullYear(),e=ta(t),r=ta(t+1);return t+(n-e)/(r-e)}function ra(n){return n.responseText}function ua(n){return JSON.parse(n.responseText)}function ia(n){var t=ca.createRange();return t.selectNode(ca.body),t.createContextualFragment(n.responseText)}function aa(n){return n.responseXML}var oa={version:"3.1.4"};Date.now||(Date.now=function(){return+new Date});var ca=document,la=window;try{ca.createElement("div").style.setProperty("opacity",0,"")}catch(fa){var sa=la.CSSStyleDeclaration.prototype,ha=sa.setProperty;sa.setProperty=function(n,t,e){ha.call(this,n,t+"",e)}}oa.ascending=function(n,t){return t>n?-1:n>t?1:n>=t?0:0/0},oa.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},oa.min=function(n,t){var e,r,u=-1,i=n.length;if(arguments.length===1){for(;++u<i&&((e=n[u])==null||e!=e);)e=void 0;for(;++u<i;)(r=n[u])!=null&&e>r&&(e=r)}else{for(;++u<i&&((e=t.call(n,n[u],u))==null||e!=e);)e=void 0;for(;++u<i;)(r=t.call(n,n[u],u))!=null&&e>r&&(e=r)}return e},oa.max=function(n,t){var e,r,u=-1,i=n.length;if(arguments.length===1){for(;++u<i&&((e=n[u])==null||e!=e);)e=void 0;for(;++u<i;)(r=n[u])!=null&&r>e&&(e=r)}else{for(;++u<i&&((e=t.call(n,n[u],u))==null||e!=e);)e=void 0;for(;++u<i;)(r=t.call(n,n[u],u))!=null&&r>e&&(e=r)}return e},oa.extent=function(n,t){var e,r,u,i=-1,a=n.length;if(arguments.length===1){for(;++i<a&&((e=u=n[i])==null||e!=e);)e=u=void 0;for(;++i<a;)(r=n[i])!=null&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<a&&((e=u=t.call(n,n[i],i))==null||e!=e);)e=void 0;for(;++i<a;)(r=t.call(n,n[i],i))!=null&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},oa.sum=function(n,t){var e,r=0,u=n.length,i=-1;if(arguments.length===1)for(;++i<u;)isNaN(e=+n[i])||(r+=e);else for(;++i<u;)isNaN(e=+t.call(n,n[i],i))||(r+=e);return r},oa.mean=function(t,e){var r,u=t.length,i=0,a=-1,o=0;if(arguments.length===1)for(;++a<u;)n(r=t[a])&&(i+=(r-i)/++o);else for(;++a<u;)n(r=e.call(t,t[a],a))&&(i+=(r-i)/++o);return o?i:void 0},oa.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},oa.median=function(t,e){return arguments.length>1&&(t=t.map(e)),t=t.filter(n),t.length?oa.quantile(t.sort(oa.ascending),.5):void 0},oa.bisector=function(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n.call(t,t[i],i)<e?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;e<n.call(t,t[i],i)?u=i:r=i+1}return r}}};var ga=oa.bisector(function(n){return n});oa.bisectLeft=ga.left,oa.bisect=oa.bisectRight=ga.right,oa.shuffle=function(n){for(var t,e,r=n.length;r;)e=Math.random()*r--|0,t=n[r],n[r]=n[e],n[e]=t;return n},oa.permute=function(n,t){for(var e=[],r=-1,u=t.length;++r<u;)e[r]=n[t[r]];return e},oa.zip=function(){if(!(u=arguments.length))return[];for(var n=-1,e=oa.min(arguments,t),r=Array(e);++n<e;)for(var u,i=-1,a=r[n]=Array(u);++i<u;)a[i]=arguments[i][n];return r},oa.transpose=function(n){return oa.zip.apply(oa,n)},oa.keys=function(n){var t=[];for(var e in n)t.push(e);return t},oa.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},oa.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},oa.merge=function(n){return Array.prototype.concat.apply([],n)},oa.range=function(n,t,r){if(arguments.length<3&&(r=1,arguments.length<2&&(t=n,n=0)),1/0===(t-n)/r)throw Error("infinite range");var u,i=[],a=e(Math.abs(r)),o=-1;if(n*=a,t*=a,r*=a,0>r)for(;(u=n+r*++o)>t;)i.push(u/a);else for(;(u=n+r*++o)<t;)i.push(u/a);return i},oa.map=function(n){var t=new u;for(var e in n)t.set(e,n[e]);return t},r(u,{has:function(n){return pa+n in this},get:function(n){return this[pa+n]},set:function(n,t){return this[pa+n]=t},remove:function(n){return n=pa+n,n in this&&delete this[n]},keys:function(){var n=[];return this.forEach(function(t){n.push(t)}),n},values:function(){var n=[];return this.forEach(function(t,e){n.push(e)}),n},entries:function(){var n=[];return this.forEach(function(t,e){n.push({key:t,value:e})}),n},forEach:function(n){for(var t in this)t.charCodeAt(0)===da&&n.call(this,t.substring(1),this[t])}});var pa="\0",da=pa.charCodeAt(0);oa.nest=function(){function n(t,o,c){if(c>=a.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,g=-1,p=o.length,d=a[c++],m=new u;++g<p;)(h=m.get(l=d(f=o[g])))?h.push(f):m.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,c))}):(f={},s=function(e,r){f[e]=n(t,r,c)}),m.forEach(s),f}function t(n,e){if(e>=a.length)return n;var r=[],u=o[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,i={},a=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(oa.map,e,0),0)},i.key=function(n){return a.push(n),i},i.sortKeys=function(n){return o[a.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},oa.set=function(n){var t=new i;if(n)for(var e=0;e<n.length;e++)t.add(n[e]);return t},r(i,{has:function(n){return pa+n in this},add:function(n){return this[pa+n]=!0,n},remove:function(n){return n=pa+n,n in this&&delete this[n]},values:function(){var n=[];return this.forEach(function(t){n.push(t)}),n},forEach:function(n){for(var t in this)t.charCodeAt(0)===da&&n.call(this,t.substring(1))}}),oa.behavior={},oa.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=a(n,t,t[e]);return n},oa.dispatch=function(){for(var n=new o,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=c(n);return n},o.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.substring(e+1),n=n.substring(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(arguments.length===2){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},oa.event=null,oa.mouse=function(n){return h(n,f())};var ma=/WebKit/.test(la.navigator.userAgent)?-1:0,va=p;
try{va(ca.documentElement.childNodes)[0].nodeType}catch(ya){va=g}var Ma=[].__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]};oa.touches=function(n,t){return arguments.length<2&&(t=f().touches),t?va(t).map(function(t){var e=h(n,t);return e.identifier=t.identifier,e}):[]},oa.behavior.drag=function(){function n(){this.on("mousedown.drag",t).on("touchstart.drag",t)}function t(){function n(){var n=o.parentNode;return null!=s?oa.touches(n).filter(function(n){return n.identifier===s})[0]:oa.mouse(n)}function t(){if(!o.parentNode)return u();var t=n(),e=t[0]-h[0],r=t[1]-h[1];g|=e|r,h=t,l(),c({type:"drag",x:t[0]+a[0],y:t[1]+a[1],dx:e,dy:r})}function u(){c({type:"dragend"}),g&&(l(),oa.event.target===f&&p.on("click.drag",i,!0)),p.on(null!=s?"touchmove.drag-"+s:"mousemove.drag",null).on(null!=s?"touchend.drag-"+s:"mouseup.drag",null)}function i(){l(),p.on("click.drag",null)}var a,o=this,c=e.of(o,arguments),f=oa.event.target,s=oa.event.touches?oa.event.changedTouches[0].identifier:null,h=n(),g=0,p=oa.select(la).on(null!=s?"touchmove.drag-"+s:"mousemove.drag",t).on(null!=s?"touchend.drag-"+s:"mouseup.drag",u,!0);r?(a=r.apply(o,arguments),a=[a.x-h[0],a.y-h[1]]):a=[0,0],null==s&&l(),c({type:"dragstart"})}var e=s(n,"drag","dragstart","dragend"),r=null;return n.origin=function(t){return arguments.length?(r=t,n):r},oa.rebind(n,e,"on")};var xa=function(n,t){return t.querySelector(n)},ba=function(n,t){return t.querySelectorAll(n)},_a=ca.documentElement,wa=_a.matchesSelector||_a.webkitMatchesSelector||_a.mozMatchesSelector||_a.msMatchesSelector||_a.oMatchesSelector,Sa=function(n,t){return wa.call(n,t)};"function"==typeof Sizzle&&(xa=function(n,t){return Sizzle(n,t)[0]||null},ba=function(n,t){return Sizzle.uniqueSort(Sizzle(n,t))},Sa=Sizzle.matchesSelector);var Ea=[];oa.selection=function(){return Ta},oa.selection.prototype=Ea,Ea.select=function(n){var t,e,r,u,i=[];"function"!=typeof n&&(n=m(n));for(var a=-1,o=this.length;++a<o;){i.push(t=[]),t.parentNode=(r=this[a]).parentNode;for(var c=-1,l=r.length;++c<l;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return d(i)},Ea.selectAll=function(n){var t,e,r=[];"function"!=typeof n&&(n=v(n));for(var u=-1,i=this.length;++u<i;)for(var a=this[u],o=-1,c=a.length;++o<c;)(e=a[o])&&(r.push(t=va(n.call(e,e.__data__,o))),t.parentNode=e);return d(r)};var ka={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};oa.ns={prefix:ka,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.substring(0,t),n=n.substring(t+1)),ka.hasOwnProperty(e)?{space:ka[e],local:n}:n}},Ea.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=oa.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(y(t,n[t]));return this}return this.each(y(n,t))},oa.requote=function(n){return n.replace(Aa,"\\$&")};var Aa=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;Ea.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=n.trim().split(/^|\s+/g)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!x(n[u]).test(t))return!1;return!0}for(t in n)this.each(_(t,n[t]));return this}return this.each(_(n,t))},Ea.style=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t="");for(e in n)this.each(S(e,n[e],t));return this}if(2>r)return la.getComputedStyle(this.node(),null).getPropertyValue(n);e=""}return this.each(S(n,t,e))},Ea.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(E(t,n[t]));return this}return this.each(E(n,t))},Ea.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Ea.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Ea.append=function(n){function t(){return this.appendChild(ca.createElementNS(this.namespaceURI,n))}function e(){return this.appendChild(ca.createElementNS(n.space,n.local))}return n=oa.ns.qualify(n),this.select(n.local?e:t)},Ea.insert=function(n,t){function e(e,r){return this.insertBefore(ca.createElementNS(this.namespaceURI,n),t.call(this,e,r))}function r(e,r){return this.insertBefore(ca.createElementNS(n.space,n.local),t.call(this,e,r))}return n=oa.ns.qualify(n),"function"!=typeof t&&(t=m(t)),this.select(n.local?r:e)},Ea.remove=function(){return this.each(function(){var n=this.parentNode;n&&n.removeChild(this)})},Ea.data=function(n,t){function e(n,e){var r,i,a,o=n.length,s=e.length,h=Math.min(o,s),g=Array(s),p=Array(s),d=Array(o);if(t){var m,v=new u,y=new u,M=[];for(r=-1;++r<o;)m=t.call(i=n[r],i.__data__,r),v.has(m)?d[r]=i:v.set(m,i),M.push(m);for(r=-1;++r<s;)m=t.call(e,a=e[r],r),(i=v.get(m))?(g[r]=i,i.__data__=a):y.has(m)||(p[r]=k(a)),y.set(m,a),v.remove(m);for(r=-1;++r<o;)v.has(M[r])&&(d[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],a=e[r],i?(i.__data__=a,g[r]=i):p[r]=k(a);for(;s>r;++r)p[r]=k(e[r]);for(;o>r;++r)d[r]=n[r]}p.update=g,p.parentNode=g.parentNode=d.parentNode=n.parentNode,c.push(p),l.push(g),f.push(d)}var r,i,a=-1,o=this.length;if(!arguments.length){for(n=Array(o=(r=this[0]).length);++a<o;)(i=r[a])&&(n[a]=i.__data__);return n}var c=j([]),l=d([]),f=d([]);if("function"==typeof n)for(;++a<o;)e(r=this[a],n.call(r,r.parentNode.__data__,a));else for(;++a<o;)e(r=this[a],n);return l.enter=function(){return c},l.exit=function(){return f},l},Ea.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Ea.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=A(n));for(var i=0,a=this.length;a>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var o=0,c=e.length;c>o;o++)(r=e[o])&&n.call(r,r.__data__,o)&&t.push(r)}return d(u)},Ea.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},Ea.sort=function(n){n=q.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Ea.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(T(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(T(n,t,e))};var qa=oa.map({mouseenter:"mouseover",mouseleave:"mouseout"});qa.forEach(function(n){"on"+n in ca&&qa.remove(n)}),Ea.each=function(n){return D(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Ea.call=function(n){var t=va(arguments);return n.apply(t[0]=this,t),this},Ea.empty=function(){return!this.node()},Ea.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null};var Na=[];oa.selection.enter=j,oa.selection.enter.prototype=Na,Na.append=Ea.append,Na.insert=Ea.insert,Na.empty=Ea.empty,Na.node=Ea.node,Na.select=function(n){for(var t,e,r,u,i,a=[],o=-1,c=this.length;++o<c;){r=(u=this[o]).update,a.push(t=[]),t.parentNode=u.parentNode;for(var l=-1,f=u.length;++l<f;)(i=u[l])?(t.push(r[l]=e=n.call(u.parentNode,i.__data__,l)),e.__data__=i.__data__):t.push(null)}return d(a)},Ea.transition=function(){var n,t,e=ec||++ac,r=[],u=Object.create(oc);u.time=Date.now();for(var i=-1,a=this.length;++i<a;){r.push(n=[]);for(var o=this[i],c=-1,l=o.length;++c<l;)(t=o[c])&&Mi(t,c,e,u),n.push(t)}return mi(r,e)};var Ta=d([[ca]]);Ta[0].parentNode=_a,oa.select=function(n){return"string"==typeof n?Ta.select(n):d([[n]])},oa.selectAll=function(n){return"string"==typeof n?Ta.selectAll(n):d([va(n)])},oa.behavior.zoom=function(){function n(){this.on("mousedown.zoom",o).on("mousemove.zoom",f).on(Da+".zoom",c).on("dblclick.zoom",h).on("touchstart.zoom",g).on("touchmove.zoom",p).on("touchend.zoom",g)}function t(n){return[(n[0]-_[0])/w,(n[1]-_[1])/w]}function e(n){return[n[0]*w+_[0],n[1]*w+_[1]]}function r(n){w=Math.max(S[0],Math.min(S[1],n))}function u(n,t){t=e(t),_[0]+=n[0]-t[0],_[1]+=n[1]-t[1]}function i(){y&&y.domain(v.range().map(function(n){return(n-_[0])/w}).map(v.invert)),x&&x.domain(M.range().map(function(n){return(n-_[1])/w}).map(M.invert))}function a(n){i(),oa.event.preventDefault(),n({type:"zoom",scale:w,translate:_})}function o(){function n(){f=1,u(oa.mouse(i),h),a(o)}function e(){f&&l(),s.on("mousemove.zoom",null).on("mouseup.zoom",null),f&&oa.event.target===c&&s.on("click.zoom",r,!0)}function r(){l(),s.on("click.zoom",null)}var i=this,o=E.of(i,arguments),c=oa.event.target,f=0,s=oa.select(la).on("mousemove.zoom",n).on("mouseup.zoom",e),h=t(oa.mouse(i));la.focus(),l()}function c(){d||(d=t(oa.mouse(this))),r(Math.pow(2,Ca()*.002)*w),u(oa.mouse(this),d),a(E.of(this,arguments))}function f(){d=null}function h(){var n=oa.mouse(this),e=t(n),i=Math.log(w)/Math.LN2;r(Math.pow(2,oa.event.shiftKey?Math.ceil(i)-1:Math.floor(i)+1)),u(n,e),a(E.of(this,arguments))}function g(){var n=oa.touches(this),e=Date.now();if(m=w,d={},n.forEach(function(n){d[n.identifier]=t(n)}),l(),n.length===1){if(500>e-b){var i=n[0],o=t(n[0]);r(2*w),u(i,o),a(E.of(this,arguments))}b=e}}function p(){var n=oa.touches(this),t=n[0],e=d[t.identifier];if(i=n[1]){var i,o=d[i.identifier];t=[(t[0]+i[0])/2,(t[1]+i[1])/2],e=[(e[0]+o[0])/2,(e[1]+o[1])/2],r(oa.event.scale*m)}u(t,e),b=null,a(E.of(this,arguments))}var d,m,v,y,M,x,b,_=[0,0],w=1,S=za,E=s(n,"zoom");return n.translate=function(t){return arguments.length?(_=t.map(Number),i(),n):_},n.scale=function(t){return arguments.length?(w=+t,i(),n):w},n.scaleExtent=function(t){return arguments.length?(S=null==t?za:t.map(Number),n):S},n.x=function(t){return arguments.length?(y=t,v=t.copy(),_=[0,0],w=1,n):y},n.y=function(t){return arguments.length?(x=t,M=t.copy(),_=[0,0],w=1,n):x},oa.rebind(n,E,"on")};var Ca,za=[0,1/0],Da="onwheel"in ca?(Ca=function(){return-oa.event.deltaY*(oa.event.deltaMode?120:1)},"wheel"):"onmousewheel"in ca?(Ca=function(){return oa.event.wheelDelta},"mousewheel"):(Ca=function(){return-oa.event.detail},"MozMousePixelScroll");L.prototype.toString=function(){return this.rgb()+""},oa.hsl=function(n,t,e){return arguments.length===1?n instanceof H?F(n.h,n.s,n.l):ut(""+n,it,F):F(+n,+t,+e)};var ja=H.prototype=new L;ja.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),F(this.h,this.s,this.l/n)},ja.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),F(this.h,this.s,n*this.l)},ja.rgb=function(){return P(this.h,this.s,this.l)};var La=Math.PI,Fa=1e-6,Ha=La/180,Pa=180/La;oa.hcl=function(n,t,e){return arguments.length===1?n instanceof Z?X(n.h,n.c,n.l):n instanceof J?K(n.l,n.a,n.b):K((n=at((n=oa.rgb(n)).r,n.g,n.b)).l,n.a,n.b):X(+n,+t,+e)};var Ra=Z.prototype=new L;Ra.brighter=function(n){return X(this.h,this.c,Math.min(100,this.l+Oa*(arguments.length?n:1)))},Ra.darker=function(n){return X(this.h,this.c,Math.max(0,this.l-Oa*(arguments.length?n:1)))},Ra.rgb=function(){return B(this.h,this.c,this.l).rgb()},oa.lab=function(n,t,e){return arguments.length===1?n instanceof J?$(n.l,n.a,n.b):n instanceof Z?B(n.l,n.c,n.h):at((n=oa.rgb(n)).r,n.g,n.b):$(+n,+t,+e)};var Oa=18,Ya=.95047,Ua=1,Ia=1.08883,Va=J.prototype=new L;Va.brighter=function(n){return $(Math.min(100,this.l+Oa*(arguments.length?n:1)),this.a,this.b)},Va.darker=function(n){return $(Math.max(0,this.l-Oa*(arguments.length?n:1)),this.a,this.b)},Va.rgb=function(){return G(this.l,this.a,this.b)},oa.rgb=function(n,t,e){return arguments.length===1?n instanceof et?tt(n.r,n.g,n.b):ut(""+n,tt,P):tt(~~n,~~t,~~e)};var Xa=et.prototype=new L;Xa.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),tt(Math.min(255,Math.floor(t/n)),Math.min(255,Math.floor(e/n)),Math.min(255,Math.floor(r/n)))):tt(u,u,u)},Xa.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),tt(Math.floor(n*this.r),Math.floor(n*this.g),Math.floor(n*this.b))},Xa.hsl=function(){return it(this.r,this.g,this.b)},Xa.toString=function(){return"#"+rt(this.r)+rt(this.g)+rt(this.b)};var Za=oa.map({aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"});Za.forEach(function(n,t){Za.set(n,ut(t,tt,P))}),oa.functor=lt,oa.xhr=function(n,t,e){function r(){var n=c.status;!n&&c.responseText||n>=200&&300>n||304===n?i.load.call(u,o.call(u,c)):i.error.call(u,c)}var u={},i=oa.dispatch("progress","load","error"),a={},o=ft,c=new(la.XDomainRequest&&/^(http(s)?:)?\/\//.test(n)?XDomainRequest:XMLHttpRequest);return"onload"in c?c.onload=c.onerror=r:c.onreadystatechange=function(){c.readyState>3&&r()},c.onprogress=function(n){var t=oa.event;oa.event=n;try{i.progress.call(u,c)}finally{oa.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.response=function(n){return o=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(va(arguments)))}}),u.send=function(e,r,i){if(arguments.length===2&&"function"==typeof r&&(i=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var o in a)c.setRequestHeader(o,a[o]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),c.send(null==r?null:r),u},u.abort=function(){return c.abort(),u},oa.rebind(u,i,"on"),arguments.length===2&&"function"==typeof t&&(e=t,t=null),null==e?u:u.get(st(e))},oa.csv=ht(",","text/csv"),oa.tsv=ht("	","text/tab-separated-values");var Ba,$a,Ja=0,Ga={},Ka=null;oa.timer=function(n,t,e){if(arguments.length<3){if(arguments.length<2)t=0;else if(!isFinite(t))return;e=Date.now()}var r=Ga[n.id];r&&r.callback===n?(r.then=e,r.delay=t):Ga[n.id=++Ja]=Ka={callback:n,then:e,delay:t,next:Ka},Ba||($a=clearTimeout($a),Ba=1,Wa(gt))},oa.timer.flush=function(){for(var n,t=Date.now(),e=Ka;e;)n=t-e.then,e.delay||(e.flush=e.callback(n)),e=e.next;pt()};var Wa=la.requestAnimationFrame||la.webkitRequestAnimationFrame||la.mozRequestAnimationFrame||la.oRequestAnimationFrame||la.msRequestAnimationFrame||function(n){setTimeout(n,17)},Qa=".",no=",",to=[3,3],eo=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"].map(dt);oa.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=oa.round(n,mt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,Math.floor((0>=e?e+1:e-1)/3)*3))),eo[8+e/3]},oa.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)},oa.format=function(n){var t=ro.exec(n),e=t[1]||" ",r=t[2]||">",u=t[3]||"",i=t[4]||"",a=t[5],o=+t[6],c=t[7],l=t[8],f=t[9],s=1,h="",g=!1;switch(l&&(l=+l.substring(1)),(a||"0"===e&&"="===r)&&(a=e="0",r="=",c&&(o-=Math.floor((o-1)/4))),f){case"n":c=!0,f="g";break;case"%":s=100,h="%",f="f";break;case"p":s=100,h="%",f="r";break;case"b":case"o":case"x":case"X":i&&(i="0"+f.toLowerCase());case"c":case"d":g=!0,l=0;break;case"s":s=-1,f="r"}"#"===i&&(i=""),"r"!=f||l||(f="g"),null!=l&&("g"==f?l=Math.max(1,Math.min(21,l)):("e"==f||"f"==f)&&(l=Math.max(0,Math.min(20,l)))),f=uo.get(f)||vt;var p=a&&c;return function(n){if(g&&n%1)return"";var t=0>n||0===n&&0>1/n?(n=-n,"-"):u;if(0>s){var d=oa.formatPrefix(n,l);n=d.scale(n),h=d.symbol}else n*=s;n=f(n,l),!a&&c&&(n=io(n));var m=i.length+n.length+(p?0:t.length),v=o>m?Array(m=o-m+1).join(e):"";return p&&(n=io(v+n)),Qa&&n.replace(".",Qa),t+=i,("<"===r?t+n+v:">"===r?v+t+n:"^"===r?v.substring(0,m>>=1)+t+n+v.substring(m):t+(p?n:v+n))+h}};var ro=/(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,uo=oa.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=oa.round(n,mt(n,t))).toFixed(Math.max(0,Math.min(20,mt(n*(1+1e-15),t))))}}),io=ft;if(to){var ao=to.length;io=function(n){for(var t=n.lastIndexOf("."),e=t>=0?"."+n.substring(t+1):(t=n.length,""),r=[],u=0,i=to[0];t>0&&i>0;)r.push(n.substring(t-=i,t+i)),i=to[u=(u+1)%ao];return r.reverse().join(no||"")+e}}oa.geo={},oa.geo.stream=function(n,t){oo.hasOwnProperty(n.type)?oo[n.type](n,t):yt(n,t)};var oo={Feature:function(n,t){yt(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)yt(e[r].geometry,t)}},co={Sphere:function(n,t){t.sphere()},Point:function(n,t){var e=n.coordinates;t.point(e[0],e[1])},MultiPoint:function(n,t){for(var e,r=n.coordinates,u=-1,i=r.length;++u<i;)e=r[u],t.point(e[0],e[1])},LineString:function(n,t){Mt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)Mt(e[r],t,0)},Polygon:function(n,t){xt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)xt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)yt(e[r],t)}};oa.geo.area=function(n){return lo=0,oa.geo.stream(n,ho),lo};var lo,fo,so,ho={sphere:function(){lo+=4*La},point:N,lineStart:N,lineEnd:N,polygonStart:function(){fo=1,so=0,ho.lineStart=bt},polygonEnd:function(){var n=2*Math.atan2(so,fo);lo+=0>n?4*La+n:n,ho.lineStart=ho.lineEnd=ho.point=N}};oa.geo.bounds=_t(ft),oa.geo.centroid=function(n){go=po=mo=vo=yo=0,oa.geo.stream(n,Mo);var t;return po&&Math.abs(t=Math.sqrt(mo*mo+vo*vo+yo*yo))>Fa?[Math.atan2(vo,mo)*Pa,Math.asin(Math.max(-1,Math.min(1,yo/t)))*Pa]:void 0};var go,po,mo,vo,yo,Mo={sphere:function(){2>go&&(go=2,po=mo=vo=yo=0)},point:wt,lineStart:Et,lineEnd:kt,polygonStart:function(){2>go&&(go=2,po=mo=vo=yo=0),Mo.lineStart=St},polygonEnd:function(){Mo.lineStart=Et}},xo=Pt(Dt,It,Xt),bo=1e9;oa.geo.projection=Kt,oa.geo.projectionMutator=Wt,(oa.geo.equirectangular=function(){return Kt(ne)}).raw=ne.invert=ne,oa.geo.rotation=function(n){function t(t){return t=n(t[0]*Ha,t[1]*Ha),t[0]*=Pa,t[1]*=Pa,t}return n=te(n[0]%360*Ha,n[1]*Ha,n.length>2?n[2]*Ha:0),t.invert=function(t){return t=n.invert(t[0]*Ha,t[1]*Ha),t[0]*=Pa,t[1]*=Pa,t},t},oa.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=te(-n[0]*Ha,-n[1]*Ha,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=Pa,n[1]*=Pa}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ie((t=+r)*Ha,u*Ha),n):t},n.precision=function(r){return arguments.length?(e=ie(t*Ha,(u=+r)*Ha),n):u},n.angle(90)},oa.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Ha,u=n[1]*Ha,i=t[1]*Ha,a=Math.sin(r),o=Math.cos(r),c=Math.sin(u),l=Math.cos(u),f=Math.sin(i),s=Math.cos(i);return Math.atan2(Math.sqrt((e=s*a)*e+(e=l*f-c*s*o)*e),c*f+l*s*o)},oa.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return oa.range(Math.ceil(i/m)*m,u,m).map(h).concat(oa.range(Math.ceil(l/v)*v,c,v).map(g)).concat(oa.range(Math.ceil(r/p)*p,e,p).filter(function(n){return Math.abs(n%m)>Fa}).map(f)).concat(oa.range(Math.ceil(o/d)*d,a,d).filter(function(n){return Math.abs(n%v)>Fa}).map(s))}var e,r,u,i,a,o,c,l,f,s,h,g,p=10,d=p,m=90,v=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(l).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],l=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),l>c&&(t=l,l=c,c=t),n.precision(y)):[[i,l],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],o=+t[0][1],a=+t[1][1],r>e&&(t=r,r=e,e=t),o>a&&(t=o,o=a,a=t),n.precision(y)):[[r,o],[e,a]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(m=+t[0],v=+t[1],n):[m,v]},n.minorStep=function(t){return arguments.length?(p=+t[0],d=+t[1],n):[p,d]},n.precision=function(t){return arguments.length?(y=+t,f=oe(o,a,90),s=ce(r,e,y),h=oe(l,c,90),g=ce(i,u,y),n):y},n.majorExtent([[-180,-90+Fa],[180,90-Fa]]).minorExtent([[-180,-80-Fa],[180,80+Fa]])},oa.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=le,u=fe;return n.distance=function(){return oa.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},oa.geo.interpolate=function(n,t){return se(n[0]*Ha,n[1]*Ha,t[0]*Ha,t[1]*Ha)},oa.geo.length=function(n){return _o=0,oa.geo.stream(n,wo),_o};var _o,wo={sphere:N,point:N,lineStart:he,lineEnd:N,polygonStart:N,polygonEnd:N};(oa.geo.conicEqualArea=function(){return ge(pe)}).raw=pe,oa.geo.albersUsa=function(){function n(n){return t(n)(n)}function t(n){var t=n[0],e=n[1];return e>50?a:-140>t?o:21>e?c:i}var e,r,u,i=oa.geo.conicEqualArea().rotate([98,0]).center([0,38]).parallels([29.5,45.5]),a=oa.geo.conicEqualArea().rotate([160,0]).center([0,60]).parallels([55,65]),o=oa.geo.conicEqualArea().rotate([160,0]).center([0,20]).parallels([8,18]),c=oa.geo.conicEqualArea().rotate([60,0]).center([0,10]).parallels([8,18]);return n.invert=function(n){return e(n)||r(n)||u(n)||i.invert(n)},n.scale=function(t){return arguments.length?(i.scale(t),a.scale(.6*t),o.scale(t),c.scale(1.5*t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var l=i.scale(),f=t[0],s=t[1];return i.translate(t),a.translate([f-.4*l,s+.17*l]),o.translate([f-.19*l,s+.2*l]),c.translate([f+.58*l,s+.43*l]),e=de(a,[[-180,50],[-130,72]]),r=de(o,[[-164,18],[-154,24]]),u=de(c,[[-67.5,17.5],[-65,19]]),n},n.scale(1e3)};var So,Eo,ko={point:N,lineStart:N,lineEnd:N,polygonStart:function(){Eo=0,ko.lineStart=me},polygonEnd:function(){ko.lineStart=ko.lineEnd=ko.point=N,So+=Math.abs(Eo/2)}},Ao={point:ye,lineStart:Me,lineEnd:xe,polygonStart:function(){Ao.lineStart=be},polygonEnd:function(){Ao.point=ye,Ao.lineStart=Me,Ao.lineEnd=xe}};oa.geo.path=function(){function n(n){return n&&oa.geo.stream(n,r(u.pointRadius("function"==typeof i?+i.apply(this,arguments):i))),u.result()}var t,e,r,u,i=4.5;return n.area=function(n){return So=0,oa.geo.stream(n,r(ko)),So},n.centroid=function(n){return go=mo=vo=yo=0,oa.geo.stream(n,r(Ao)),yo?[mo/yo,vo/yo]:void 0},n.bounds=function(n){return _t(r)(n)},n.projection=function(e){return arguments.length?(r=(t=e)?e.stream||Se(e):ft,n):t},n.context=function(t){return arguments.length?(u=(e=t)==null?new ve:new _e(t),n):e},n.pointRadius=function(t){return arguments.length?(i="function"==typeof t?t:+t,n):i},n.projection(oa.geo.albersUsa()).context(null)},oa.geo.albers=function(){return oa.geo.conicEqualArea().parallels([29.5,45.5]).rotate([98,0]).center([0,38]).scale(1e3)};var qo=Ee(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(oa.geo.azimuthalEqualArea=function(){return Kt(qo)}).raw=qo;var No=Ee(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},ft);(oa.geo.azimuthalEquidistant=function(){return Kt(No)}).raw=No,(oa.geo.conicConformal=function(){return ge(ke)}).raw=ke,(oa.geo.conicEquidistant=function(){return ge(Ae)}).raw=Ae;var To=Ee(function(n){return 1/n},Math.atan);(oa.geo.gnomonic=function(){return Kt(To)}).raw=To,qe.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-La/2]},(oa.geo.mercator=function(){return Ne(qe)}).raw=qe;var Co=Ee(function(){return 1},Math.asin);(oa.geo.orthographic=function(){return Kt(Co)}).raw=Co;var zo=Ee(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(oa.geo.stereographic=function(){return Kt(zo)}).raw=zo,Te.invert=function(n,t){return[Math.atan2(U(n),Math.cos(t)),Y(Math.sin(t)/I(n))]},(oa.geo.transverseMercator=function(){return Ne(Te)}).raw=Te,oa.geom={},oa.svg={},oa.svg.line=function(){return Ce(ft)};var Do=oa.map({linear:je,"linear-closed":Le,"step-before":Fe,"step-after":He,basis:Ie,"basis-open":Ve,"basis-closed":Xe,bundle:Ze,cardinal:Oe,"cardinal-open":Pe,"cardinal-closed":Re,monotone:We});Do.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var jo=[0,2/3,1/3,0],Lo=[0,1/3,2/3,0],Fo=[0,1/6,2/3,1/6];oa.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u,i,a,o,c,l,f,s,h,g,p,d=lt(e),m=lt(r),v=n.length,y=v-1,M=[],x=[],b=0;if(d===ze&&r===De)t=n;else for(i=0,t=[];v>i;++i)t.push([+d.call(this,u=n[i],i),+m.call(this,u,i)]);for(i=1;v>i;++i)t[i][1]<t[b][1]?b=i:t[i][1]==t[b][1]&&(b=t[i][0]<t[b][0]?i:b);for(i=0;v>i;++i)i!==b&&(c=t[i][1]-t[b][1],o=t[i][0]-t[b][0],M.push({angle:Math.atan2(c,o),index:i}));for(M.sort(function(n,t){return n.angle-t.angle}),g=M[0].angle,h=M[0].index,s=0,i=1;y>i;++i)a=M[i].index,g==M[i].angle?(o=t[h][0]-t[b][0],c=t[h][1]-t[b][1],l=t[a][0]-t[b][0],f=t[a][1]-t[b][1],o*o+c*c>=l*l+f*f?M[i].index=-1:(M[s].index=-1,g=M[i].angle,s=i,h=a)):(g=M[i].angle,s=i,h=a);for(x.push(b),i=0,a=0;2>i;++a)M[a].index!==-1&&(x.push(M[a].index),i++);for(p=x.length;y>a;++a)if(M[a].index!==-1){for(;!Qe(x[p-2],x[p-1],M[a].index,t);)--p;x[p++]=M[a].index}var _=[];for(i=0;p>i;++i)_.push(n[x[i]]);return _}var e=ze,r=De;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},oa.geom.polygon=function(n){return n.area=function(){for(var t=0,e=n.length,r=n[e-1][1]*n[0][0]-n[e-1][0]*n[0][1];++t<e;)r+=n[t-1][1]*n[t][0]-n[t-1][0]*n[t][1];return.5*r},n.centroid=function(t){var e,r,u=-1,i=n.length,a=0,o=0,c=n[i-1];for(arguments.length||(t=-1/(6*n.area()));++u<i;)e=c,c=n[u],r=e[0]*c[1]-c[0]*e[1],a+=(e[0]+c[0])*r,o+=(e[1]+c[1])*r;return[a*t,o*t]},n.clip=function(t){for(var e,r,u,i,a,o,c=-1,l=n.length,f=n[l-1];++c<l;){for(e=t.slice(),t.length=0,i=n[c],a=e[(u=e.length)-1],r=-1;++r<u;)o=e[r],nr(o,f,i)?(nr(a,f,i)||t.push(tr(a,o,f,i)),t.push(o)):nr(a,f,i)&&t.push(tr(a,o,f,i)),a=o;f=i}return t},n},oa.geom.delaunay=function(n){var t=n.map(function(){return[]}),e=[];return er(n,function(e){t[e.region.l.index].push(n[e.region.r.index])}),t.forEach(function(t,r){var u=n[r],i=u[0],a=u[1];t.forEach(function(n){n.angle=Math.atan2(n[0]-i,n[1]-a)}),t.sort(function(n,t){return n.angle-t.angle});for(var o=0,c=t.length-1;c>o;o++)e.push([u,t[o],t[o+1]])}),e},oa.geom.voronoi=function(n){function t(n){var t,r,a,o=n.map(function(){return[]}),c=lt(u),l=lt(i),f=n.length,s=1e6;if(c===ze&&l===De)t=n;else for(t=[],a=0;f>a;++a)t.push([+c.call(this,r=n[a],a),+l.call(this,r,a)]);if(er(t,function(n){var t,e,r,u,i,a;n.a===1&&n.b>=0?(t=n.ep.r,e=n.ep.l):(t=n.ep.l,e=n.ep.r),n.a===1?(i=t?t.y:-s,r=n.c-n.b*i,a=e?e.y:s,u=n.c-n.b*a):(r=t?t.x:-s,i=n.c-n.a*r,u=e?e.x:s,a=n.c-n.a*u);var c=[r,i],l=[u,a];o[n.region.l.index].push(c,l),o[n.region.r.index].push(c,l)}),o=o.map(function(n,e){var r=t[e][0],u=t[e][1],i=n.map(function(n){return Math.atan2(n[0]-r,n[1]-u)}),a=oa.range(n.length).sort(function(n,t){return i[n]-i[t]});return a.filter(function(n,t){return!t||i[n]-i[a[t-1]]>Fa}).map(function(t){return n[t]})}),o.forEach(function(n,e){var r=n.length;if(!r)return n.push([-s,-s],[-s,s],[s,s],[s,-s]);if(!(r>2)){var u=t[e],i=n[0],a=n[1],o=u[0],c=u[1],l=i[0],f=i[1],h=a[0],g=a[1],p=Math.abs(h-l),d=g-f;if(Math.abs(d)<Fa){var m=f>c?-s:s;n.push([-s,m],[s,m])}else if(Fa>p){var v=l>o?-s:s;n.push([v,-s],[v,s])}else{var m=(l-o)*(g-f)>(h-l)*(f-c)?s:-s,y=Math.abs(d)-p;Math.abs(y)<Fa?n.push([0>d?m:-m,m]):(y>0&&(m*=-1),n.push([-s,m],[s,m]))}}}),e)for(a=0;f>a;++a)e(o[a]);for(a=0;f>a;++a)o[a].point=n[a];return o}var e,r=null,u=ze,i=De;return arguments.length?t(n):(t.x=function(n){return arguments.length?(u=n,t):u},t.y=function(n){return arguments.length?(i=n,t):i},t.size=function(n){return arguments.length?(null==n?e=null:(r=[+n[0],+n[1]],e=oa.geom.polygon([[0,0],[0,r[1]],r,[r[0],0]]).clip),t):r},t.links=function(n){var t,e,r,a=n.map(function(){return[]}),o=[],c=lt(u),l=lt(i),f=n.length;if(c===ze&&l===De)t=n;else for(r=0;f>r;++r)t.push([+c.call(this,e=n[r],r),+l.call(this,e,r)]);return er(t,function(t){var e=t.region.l.index,r=t.region.r.index;a[e][r]||(a[e][r]=a[r][e]=!0,o.push({source:n[e],target:n[r]}))}),o},t.triangles=function(n){if(u===ze&&i===De)return oa.geom.delaunay(n);var t,e,r,a,o,c=lt(u),l=lt(i);for(a=0,t=[],o=n.length;o>a;++a)e=[+c.call(this,r=n[a],a),+l.call(this,r,a)],e.data=r,t.push(e);return oa.geom.delaunay(t).map(function(n){return n.map(function(n){return n.data})})},t)};var Ho={l:"r",r:"l"};oa.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,a,o){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,f=n.y;
if(null!=c)if(Math.abs(c-e)+Math.abs(f-r)<.01)l(n,t,e,r,u,i,a,o);else{var s=n.point;n.x=n.y=n.point=null,l(n,s,c,f,u,i,a,o),l(n,t,e,r,u,i,a,o)}else n.x=e,n.y=r,n.point=t}else l(n,t,e,r,u,i,a,o)}function l(n,t,e,r,u,a,o,c){var l=.5*(u+o),f=.5*(a+c),s=e>=l,h=r>=f,g=(h<<1)+s;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=ir()),s?u=l:o=l,h?a=f:c=f,i(n,t,e,r,u,a,o,c)}var f,s,h,g,p,d,m,v,y,M=lt(o),x=lt(c);if(null!=t)d=t,m=e,v=r,y=u;else if(v=y=-(d=m=1/0),s=[],h=[],p=n.length,a)for(g=0;p>g;++g)f=n[g],f.x<d&&(d=f.x),f.y<m&&(m=f.y),f.x>v&&(v=f.x),f.y>y&&(y=f.y),s.push(f.x),h.push(f.y);else for(g=0;p>g;++g){var b=+M(f=n[g],g),_=+x(f,g);d>b&&(d=b),m>_&&(m=_),b>v&&(v=b),_>y&&(y=_),s.push(b),h.push(_)}var w=v-d,S=y-m;w>S?y=m+w:v=d+S;var E=ir();if(E.add=function(n){i(E,n,+M(n,++g),+x(n,g),d,m,v,y)},E.visit=function(n){ar(n,E,d,m,v,y)},g=-1,null==t){for(;++g<p;)i(E,n[g],s[g],h[g],d,m,v,y);--g}else n.forEach(E.add);return s=h=n=f=null,E}var a,o=ze,c=De;return(a=arguments.length)?(o=rr,c=ur,3===a&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(o=n,i):o},i.y=function(n){return arguments.length?(c=n,i):c},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r,u]},i)},oa.interpolateRgb=or,oa.transform=function(n){var t=ca.createElementNS(oa.ns.prefix.svg,"g");return(oa.transform=function(n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate();return new cr(e?e.matrix:Po)})(n)},cr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var Po={a:1,b:0,c:0,d:1,e:0,f:0};oa.interpolateNumber=hr,oa.interpolateTransform=gr,oa.interpolateObject=pr,oa.interpolateString=dr;var Ro=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;oa.interpolate=mr,oa.interpolators=[pr,function(n,t){return Array.isArray(t)&&yr(n,t)},function(n,t){return("string"==typeof n||"string"==typeof t)&&dr(n+"",t+"")},function(n,t){return("string"==typeof t?Za.has(t)||/^(#|rgb\(|hsl\()/.test(t):t instanceof L)&&or(n,t)},function(n,t){return!isNaN(n=+n)&&!isNaN(t=+t)&&hr(n,t)}],oa.interpolateArray=yr;var Oo=function(){return ft},Yo=oa.map({linear:Oo,poly:Er,quad:function(){return _r},cubic:function(){return wr},sin:function(){return kr},exp:function(){return Ar},circle:function(){return qr},elastic:Nr,back:Tr,bounce:function(){return Cr}}),Uo=oa.map({"in":ft,out:xr,"in-out":br,"out-in":function(n){return br(xr(n))}});oa.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.substring(0,t):n,r=t>=0?n.substring(t+1):"in";return e=Yo.get(e)||Oo,r=Uo.get(r)||ft,Mr(r(e.apply(null,Array.prototype.slice.call(arguments,1))))},oa.interpolateHcl=zr,oa.interpolateHsl=Dr,oa.interpolateLab=jr,oa.interpolateRound=Lr,oa.layout={},oa.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Pr(n[e]));return t}},oa.layout.chord=function(){function n(){var n,l,s,h,g,p={},d=[],m=oa.range(i),v=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(l=0,g=-1;++g<i;)l+=u[h][g];d.push(l),v.push(oa.range(i)),n+=l}for(a&&m.sort(function(n,t){return a(d[n],d[t])}),o&&v.forEach(function(n,t){n.sort(function(n,e){return o(u[t][n],u[t][e])})}),n=(2*La-f*i)/n,l=0,h=-1;++h<i;){for(s=l,g=-1;++g<i;){var y=m[h],M=v[y][g],x=u[y][M],b=l,_=l+=x*n;p[y+"-"+M]={index:y,subindex:M,startAngle:b,endAngle:_,value:x}}r[y]={index:y,startAngle:s,endAngle:l,value:(l-s)/n},l+=f}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,a,o,c,l={},f=0;return l.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,l):u},l.padding=function(n){return arguments.length?(f=n,e=r=null,l):f},l.sortGroups=function(n){return arguments.length?(a=n,e=r=null,l):a},l.sortSubgroups=function(n){return arguments.length?(o=n,e=null,l):o},l.sortChords=function(n){return arguments.length?(c=n,e&&t(),l):c},l.chords=function(){return e||n(),e},l.groups=function(){return r||n(),r},l},oa.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,a=t.cy-n.y,o=1/Math.sqrt(i*i+a*a);if(d>(u-e)*o){var c=t.charge*o*o;return n.px-=i*c,n.py-=a*c,!0}if(t.point&&isFinite(o)){var c=t.pointCharge*o*o;n.px-=i*c,n.py-=a*c}}return!t.charge}}function t(n){n.px=oa.event.x,n.py=oa.event.y,o.resume()}var e,r,u,i,a,o={},c=oa.dispatch("start","tick","end"),l=[1,1],f=.9,s=Io,h=Vo,g=-30,p=.1,d=.8,m=[],v=[];return o.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,o,s,h,d,y,M,x,b=m.length,_=v.length;for(e=0;_>e;++e)o=v[e],s=o.source,h=o.target,M=h.x-s.x,x=h.y-s.y,(d=M*M+x*x)&&(d=r*i[e]*((d=Math.sqrt(d))-u[e])/d,M*=d,x*=d,h.x-=M*(y=s.weight/(h.weight+s.weight)),h.y-=x*y,s.x+=M*(y=1-y),s.y+=x*y);if((y=r*p)&&(M=l[0]/2,x=l[1]/2,e=-1,y))for(;++e<b;)o=m[e],o.x+=(M-o.x)*y,o.y+=(x-o.y)*y;if(g)for(Xr(t=oa.geom.quadtree(m),r,a),e=-1;++e<b;)(o=m[e]).fixed||t.visit(n(o));for(e=-1;++e<b;)o=m[e],o.fixed?(o.x=o.px,o.y=o.py):(o.x-=(o.px-(o.px=o.x))*f,o.y-=(o.py-(o.py=o.y))*f);c.tick({type:"tick",alpha:r})},o.nodes=function(n){return arguments.length?(m=n,o):m},o.links=function(n){return arguments.length?(v=n,o):v},o.size=function(n){return arguments.length?(l=n,o):l},o.linkDistance=function(n){return arguments.length?(s="function"==typeof n?n:+n,o):s},o.distance=o.linkDistance,o.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,o):h},o.friction=function(n){return arguments.length?(f=+n,o):f},o.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,o):g},o.gravity=function(n){return arguments.length?(p=+n,o):p},o.theta=function(n){return arguments.length?(d=+n,o):d},o.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),oa.timer(o.tick)),o):r},o.start=function(){function n(n,r){for(var u,i=t(e),a=-1,o=i.length;++a<o;)if(!isNaN(u=i[a][n]))return u;return Math.random()*r}function t(){if(!c){for(c=[],r=0;p>r;++r)c[r]=[];for(r=0;d>r;++r){var n=v[r];c[n.source.index].push(n.target),c[n.target.index].push(n.source)}}return c[e]}var e,r,c,f,p=m.length,d=v.length,y=l[0],M=l[1];for(e=0;p>e;++e)(f=m[e]).index=e,f.weight=0;for(e=0;d>e;++e)f=v[e],typeof f.source=="number"&&(f.source=m[f.source]),typeof f.target=="number"&&(f.target=m[f.target]),++f.source.weight,++f.target.weight;for(e=0;p>e;++e)f=m[e],isNaN(f.x)&&(f.x=n("x",y)),isNaN(f.y)&&(f.y=n("y",M)),isNaN(f.px)&&(f.px=f.x),isNaN(f.py)&&(f.py=f.y);if(u=[],"function"==typeof s)for(e=0;d>e;++e)u[e]=+s.call(this,v[e],e);else for(e=0;d>e;++e)u[e]=s;if(i=[],"function"==typeof h)for(e=0;d>e;++e)i[e]=+h.call(this,v[e],e);else for(e=0;d>e;++e)i[e]=h;if(a=[],"function"==typeof g)for(e=0;p>e;++e)a[e]=+g.call(this,m[e],e);else for(e=0;p>e;++e)a[e]=g;return o.resume()},o.resume=function(){return o.alpha(.1)},o.stop=function(){return o.alpha(0)},o.drag=function(){return e||(e=oa.behavior.drag().origin(ft).on("dragstart.force",Yr).on("drag.force",t).on("dragend.force",Ur)),arguments.length?(this.on("mouseover.force",Ir).on("mouseout.force",Vr).call(e),void 0):e},oa.rebind(o,c,"on")};var Io=20,Vo=1;oa.layout.hierarchy=function(){function n(t,a,o){var c=u.call(e,t,a);if(t.depth=a,o.push(t),c&&(l=c.length)){for(var l,f,s=-1,h=t.children=[],g=0,p=a+1;++s<l;)f=n(c[s],p,o),f.parent=t,h.push(f),g+=f.value;r&&h.sort(r),i&&(t.value=g)}else i&&(t.value=+i.call(e,t,a)||0);return t}function t(n,r){var u=n.children,a=0;if(u&&(o=u.length))for(var o,c=-1,l=r+1;++c<o;)a+=t(u[c],l);else i&&(a=+i.call(e,n,r)||0);return i&&(n.value=a),a}function e(t){var e=[];return n(t,0,e),e}var r=Jr,u=Br,i=$r;return e.sort=function(n){return arguments.length?(r=n,e):r},e.children=function(n){return arguments.length?(u=n,e):u},e.value=function(n){return arguments.length?(i=n,e):i},e.revalue=function(n){return t(n,0),n},e},oa.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(a=i.length)){var a,o,c,l=-1;for(r=t.value?r/t.value:0;++l<a;)n(o=i[l],e,c=o.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var a=r.call(this,e,i);return n(a[0],0,u[0],u[1]/t(a[0])),a}var r=oa.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Zr(e,r)},oa.layout.pie=function(){function n(i){var a=i.map(function(e,r){return+t.call(n,e,r)}),o=+("function"==typeof r?r.apply(this,arguments):r),c=(("function"==typeof u?u.apply(this,arguments):u)-o)/oa.sum(a),l=oa.range(i.length);null!=e&&l.sort(e===Xo?function(n,t){return a[t]-a[n]}:function(n,t){return e(i[n],i[t])});var f=[];return l.forEach(function(n){var t;f[n]={data:i[n],value:t=a[n],startAngle:o,endAngle:o+=t*c}}),f}var t=Number,e=Xo,r=0,u=2*La;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n};var Xo={};oa.layout.stack=function(){function n(o,c){var l=o.map(function(e,r){return t.call(n,e,r)}),f=l.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),a.call(n,t,e)]})}),s=e.call(n,f,c);l=oa.permute(l,s),f=oa.permute(f,s);var h,g,p,d=r.call(n,f,c),m=l.length,v=l[0].length;for(g=0;v>g;++g)for(u.call(n,l[0][g],p=d[g],f[0][g][1]),h=1;m>h;++h)u.call(n,l[h][g],p+=f[h-1][g][1],f[h][g][1]);return o}var t=ft,e=nu,r=tu,u=Qr,i=Kr,a=Wr;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:Zo.get(t)||nu,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:Bo.get(t)||tu,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(a=t,n):a},n.out=function(t){return arguments.length?(u=t,n):u},n};var Zo=oa.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(eu),i=n.map(ru),a=oa.range(r).sort(function(n,t){return u[n]-u[t]}),o=0,c=0,l=[],f=[];for(t=0;r>t;++t)e=a[t],c>o?(o+=i[e],l.push(e)):(c+=i[e],f.push(e));return f.reverse().concat(l)},reverse:function(n){return oa.range(n.length).reverse()},"default":nu}),Bo=oa.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,a=[],o=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>o&&(o=r),a.push(r)}for(e=0;i>e;++e)c[e]=(o-a[e])/2;return c},wiggle:function(n){var t,e,r,u,i,a,o,c,l,f=n.length,s=n[0],h=s.length,g=[];for(g[0]=c=l=0,e=1;h>e;++e){for(t=0,u=0;f>t;++t)u+=n[t][e][1];for(t=0,i=0,o=s[e][0]-s[e-1][0];f>t;++t){for(r=0,a=(n[t][e][1]-n[t][e-1][1])/(2*o);t>r;++r)a+=(n[r][e][1]-n[r][e-1][1])/o;i+=a*n[t][e][1]}g[e]=c-=u?i/u*o:0,l>c&&(l=c)}for(e=0;h>e;++e)g[e]-=l;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,a=1/u,o=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=a}for(e=0;i>e;++e)o[e]=0;return o},zero:tu});oa.layout.histogram=function(){function n(n,i){for(var a,o,c=[],l=n.map(e,this),f=r.call(this,l,i),s=u.call(this,f,l,i),i=-1,h=l.length,g=s.length-1,p=t?1:1/h;++i<g;)a=c[i]=[],a.dx=s[i+1]-(a.x=s[i]),a.y=0;if(g>0)for(i=-1;++i<h;)o=l[i],o>=f[0]&&o<=f[1]&&(a=c[oa.bisect(s,o,1,g)-1],a.y+=p,a.push(n[i]));return c}var t=!0,e=Number,r=ou,u=iu;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=lt(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return au(n,t)}:lt(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},oa.layout.tree=function(){function n(n,u){function i(n,t){var r=n.children,u=n._tree;if(r&&(a=r.length)){for(var a,c,l,f=r[0],s=f,h=-1;++h<a;)l=r[h],i(l,c),s=o(l,c,s),c=l;mu(n);var g=.5*(f._tree.prelim+l._tree.prelim);t?(u.prelim=t._tree.prelim+e(n,t),u.mod=u.prelim-g):u.prelim=g}else t&&(u.prelim=t._tree.prelim+e(n,t))}function a(n,t){n.x=n._tree.prelim+t;var e=n.children;if(e&&(r=e.length)){var r,u=-1;for(t+=n._tree.mod;++u<r;)a(e[u],t)}}function o(n,t,r){if(t){for(var u,i=n,a=n,o=t,c=n.parent.children[0],l=i._tree.mod,f=a._tree.mod,s=o._tree.mod,h=c._tree.mod;o=fu(o),i=lu(i),o&&i;)c=lu(c),a=fu(a),a._tree.ancestor=n,u=o._tree.prelim+s-i._tree.prelim-l+e(o,i),u>0&&(vu(yu(o,n,r),n,u),l+=u,f+=u),s+=o._tree.mod,l+=i._tree.mod,h+=c._tree.mod,f+=a._tree.mod;o&&!fu(a)&&(a._tree.thread=o,a._tree.mod+=s-f),i&&!lu(c)&&(c._tree.thread=i,c._tree.mod+=l-h,r=n)}return r}var c=t.call(this,n,u),l=c[0];du(l,function(n,t){n._tree={ancestor:n,prelim:0,mod:0,change:0,shift:0,number:t?t._tree.number+1:0}}),i(l),a(l,-l._tree.prelim);var f=su(l,gu),s=su(l,hu),h=su(l,pu),g=f.x-e(f,s)/2,p=s.x+e(s,f)/2,d=h.depth||1;return du(l,function(n){n.x=(n.x-g)/(p-g)*r[0],n.y=n.depth/d*r[1],delete n._tree}),c}var t=oa.layout.hierarchy().sort(null).value(null),e=cu,r=[1,1];return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(r=t,n):r},Zr(n,t)},oa.layout.pack=function(){function n(n,u){var i=t.call(this,n,u),a=i[0];a.x=0,a.y=0,du(a,function(n){n.r=Math.sqrt(n.value)}),du(a,wu);var o=r[0],c=r[1],l=Math.max(2*a.r/o,2*a.r/c);if(e>0){var f=e*l/2;du(a,function(n){n.r+=f}),du(a,wu),du(a,function(n){n.r-=f}),l=Math.max(2*a.r/o,2*a.r/c)}return ku(a,o/2,c/2,1/l),i}var t=oa.layout.hierarchy().sort(Mu),e=0,r=[1,1];return n.size=function(t){return arguments.length?(r=t,n):r},n.padding=function(t){return arguments.length?(e=+t,n):e},Zr(n,t)},oa.layout.cluster=function(){function n(n,u){var i,a=t.call(this,n,u),o=a[0],c=0;du(o,function(n){var t=n.children;t&&t.length?(n.x=Nu(t),n.y=qu(t)):(n.x=i?c+=e(n,i):0,n.y=0,i=n)});var l=Tu(o),f=Cu(o),s=l.x-e(l,f)/2,h=f.x+e(f,l)/2;return du(o,function(n){n.x=(n.x-s)/(h-s)*r[0],n.y=(1-(o.y?n.y/o.y:1))*r[1]}),a}var t=oa.layout.hierarchy().sort(null).value(null),e=cu,r=[1,1];return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(r=t,n):r},Zr(n,t)},oa.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var a,o,c,l=s(e),f=[],h=i.slice(),p=1/0,d="slice"===g?l.dx:"dice"===g?l.dy:"slice-dice"===g?e.depth&1?l.dy:l.dx:Math.min(l.dx,l.dy);for(n(h,l.dx*l.dy/e.value),f.area=0;(c=h.length)>0;)f.push(a=h[c-1]),f.area+=a.area,"squarify"!==g||(o=r(f,d))<=p?(h.pop(),p=o):(f.area-=f.pop().area,u(f,d,l,!1),d=Math.min(l.dx,l.dy),f.length=f.area=0,p=1/0);f.length&&(u(f,d,l,!0),f.length=f.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,a=s(t),o=r.slice(),c=[];for(n(o,a.dx*a.dy/t.value),c.area=0;i=o.pop();)c.push(i),c.area+=i.area,i.z!=null&&(u(c,i.z?a.dx:a.dy,a,!o.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,a=-1,o=n.length;++a<o;)(e=n[a].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,a=n.length,o=e.x,l=e.y,f=t?c(n.area/t):0;if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++i<a;)u=n[i],u.x=o,u.y=l,u.dy=f,o+=u.dx=Math.min(e.x+e.dx-o,f?c(u.area/f):0);u.z=!0,u.dx+=e.x+e.dx-o,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++i<a;)u=n[i],u.x=o,u.y=l,u.dx=f,l+=u.dy=Math.min(e.y+e.dy-l,f?c(u.area/f):0);u.z=!1,u.dy+=e.y+e.dy-l,e.x+=f,e.dx-=f}}function i(r){var u=a||o(r),i=u[0];return i.x=0,i.y=0,i.dx=l[0],i.dy=l[1],a&&o.revalue(i),n([i],i.dx*i.dy/i.value),(a?e:t)(i),h&&(a=u),u}var a,o=oa.layout.hierarchy(),c=Math.round,l=[1,1],f=null,s=zu,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));return i.size=function(n){return arguments.length?(l=n,i):l},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?zu(t):Du(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Du(t,n)}if(!arguments.length)return f;var r;return s=(f=n)==null?zu:(r=typeof n)=="function"?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,a=null,i):h},i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Zr(i,o)},oa.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=Math.random()*2-1,r=Math.random()*2-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=oa.random.normal.apply(oa,arguments);return function(){return Math.exp(n())}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t/n}}},oa.scale={},oa.scale.linear=function(){return Ru([0,1],[0,1],mr,!1)},oa.scale.log=function(){return Xu(oa.scale.linear().domain([0,Math.LN10]),10,Zu,Bu)};var $o=oa.format(".0e");oa.scale.pow=function(){return Ku(oa.scale.linear(),1)},oa.scale.sqrt=function(){return oa.scale.pow().exponent(.5)},oa.scale.ordinal=function(){return Qu([],{t:"range",a:[[]]})},oa.scale.category10=function(){return oa.scale.ordinal().range(Jo)},oa.scale.category20=function(){return oa.scale.ordinal().range(Go)},oa.scale.category20b=function(){return oa.scale.ordinal().range(Ko)},oa.scale.category20c=function(){return oa.scale.ordinal().range(Wo)};var Jo=["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],Go=["#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf","#9edae5"],Ko=["#393b79","#5254a3","#6b6ecf","#9c9ede","#637939","#8ca252","#b5cf6b","#cedb9c","#8c6d31","#bd9e39","#e7ba52","#e7cb94","#843c39","#ad494a","#d6616b","#e7969c","#7b4173","#a55194","#ce6dbd","#de9ed6"],Wo=["#3182bd","#6baed6","#9ecae1","#c6dbef","#e6550d","#fd8d3c","#fdae6b","#fdd0a2","#31a354","#74c476","#a1d99b","#c7e9c0","#756bb1","#9e9ac8","#bcbddc","#dadaeb","#636363","#969696","#bdbdbd","#d9d9d9"];oa.scale.quantile=function(){return ni([],[])},oa.scale.quantize=function(){return ti(0,1,[0,1])},oa.scale.threshold=function(){return ei([.5],[0,1])},oa.scale.identity=function(){return ri([0,1])},oa.svg.arc=function(){function n(){var n=t.apply(this,arguments),i=e.apply(this,arguments),a=r.apply(this,arguments)+Qo,o=u.apply(this,arguments)+Qo,c=(a>o&&(c=a,a=o,o=c),o-a),l=La>c?"0":"1",f=Math.cos(a),s=Math.sin(a),h=Math.cos(o),g=Math.sin(o);return c>=nc?n?"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"M0,"+n+"A"+n+","+n+" 0 1,0 0,"+-n+"A"+n+","+n+" 0 1,0 0,"+n+"Z":"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"Z":n?"M"+i*f+","+i*s+"A"+i+","+i+" 0 "+l+",1 "+i*h+","+i*g+"L"+n*h+","+n*g+"A"+n+","+n+" 0 "+l+",0 "+n*f+","+n*s+"Z":"M"+i*f+","+i*s+"A"+i+","+i+" 0 "+l+",1 "+i*h+","+i*g+"L0,0"+"Z"}var t=ui,e=ii,r=ai,u=oi;return n.innerRadius=function(e){return arguments.length?(t=lt(e),n):t},n.outerRadius=function(t){return arguments.length?(e=lt(t),n):e},n.startAngle=function(t){return arguments.length?(r=lt(t),n):r},n.endAngle=function(t){return arguments.length?(u=lt(t),n):u},n.centroid=function(){var n=(t.apply(this,arguments)+e.apply(this,arguments))/2,i=(r.apply(this,arguments)+u.apply(this,arguments))/2+Qo;return[Math.cos(i)*n,Math.sin(i)*n]},n};var Qo=-La/2,nc=2*La-1e-6;oa.svg.line.radial=function(){var n=Ce(ci);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},Fe.reverse=He,He.reverse=Fe,oa.svg.area=function(){return li(ft)},oa.svg.area.radial=function(){var n=li(ci);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},oa.svg.chord=function(){function n(n,o){var c=t(this,i,n,o),l=t(this,a,n,o);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,l)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,l.r,l.p0)+r(l.r,l.p1,l.a1-l.a0)+u(l.r,l.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=o.call(n,u,r),a=c.call(n,u,r)+Qo,f=l.call(n,u,r)+Qo;return{r:i,a0:a,a1:f,p0:[i*Math.cos(a),i*Math.sin(a)],p1:[i*Math.cos(f),i*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>La)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=le,a=fe,o=fi,c=ai,l=oi;return n.radius=function(t){return arguments.length?(o=lt(t),n):o},n.source=function(t){return arguments.length?(i=lt(t),n):i},n.target=function(t){return arguments.length?(a=lt(t),n):a},n.startAngle=function(t){return arguments.length?(c=lt(t),n):c},n.endAngle=function(t){return arguments.length?(l=lt(t),n):l},n},oa.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),a=e.call(this,n,u),o=(i.y+a.y)/2,c=[i,{x:i.x,y:o},{x:a.x,y:o},a];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=le,e=fe,r=si;return n.source=function(e){return arguments.length?(t=lt(e),n):t},n.target=function(t){return arguments.length?(e=lt(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},oa.svg.diagonal.radial=function(){var n=oa.svg.diagonal(),t=si,e=n.projection;return n.projection=function(n){return arguments.length?e(hi(t=n)):t},n},oa.svg.symbol=function(){function n(n,r){return(tc.get(t.call(this,n,r))||di)(e.call(this,n,r))}var t=pi,e=gi;return n.type=function(e){return arguments.length?(t=lt(e),n):t},n.size=function(t){return arguments.length?(e=lt(t),n):e},n};var tc=oa.map({circle:di,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*uc)),e=t*uc;return"M0,"+-t+"L"+e+",0"+" 0,"+t+" "+-e+",0"+"Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/rc),e=t*rc/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/rc),e=t*rc/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});oa.svg.symbolTypes=tc.keys();var ec,rc=Math.sqrt(3),uc=Math.tan(30*Ha),ic=[],ac=0,oc={ease:Sr,delay:0,duration:250};ic.call=Ea.call,ic.empty=Ea.empty,ic.node=Ea.node,oa.transition=function(n){return arguments.length?ec?n.transition():n:Ta.transition()},oa.transition.prototype=ic,ic.select=function(n){var t,e,r,u=this.id,i=[];"function"!=typeof n&&(n=m(n));for(var a=-1,o=this.length;++a<o;){i.push(t=[]);for(var c=this[a],l=-1,f=c.length;++l<f;)(r=c[l])&&(e=n.call(r,r.__data__,l))?("__data__"in r&&(e.__data__=r.__data__),Mi(e,l,u,r.__transition__[u]),t.push(e)):t.push(null)}return mi(i,u)},ic.selectAll=function(n){var t,e,r,u,i,a=this.id,o=[];"function"!=typeof n&&(n=v(n));for(var c=-1,l=this.length;++c<l;)for(var f=this[c],s=-1,h=f.length;++s<h;)if(r=f[s]){i=r.__transition__[a],e=n.call(r,r.__data__,s),o.push(t=[]);for(var g=-1,p=e.length;++g<p;)Mi(u=e[g],g,a,i),t.push(u)}return mi(o,a)},ic.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=A(n));for(var i=0,a=this.length;a>i;i++){u.push(t=[]);for(var e=this[i],o=0,c=e.length;c>o;o++)(r=e[o])&&n.call(r,r.__data__,o)&&t.push(r)}return mi(u,this.id,this.time).ease(this.ease())},ic.tween=function(n,t){var e=this.id;return arguments.length<2?this.node().__transition__[e].tween.get(n):D(this,null==t?function(t){t.__transition__[e].tween.remove(n)}:function(r){r.__transition__[e].tween.set(n,t)})},ic.attr=function(n,t){function e(){this.removeAttribute(i)}function r(){this.removeAttributeNS(i.space,i.local)}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var u=vr(n),i=oa.ns.qualify(n);return vi(this,"attr."+n,t,function(n){function t(){var t,e=this.getAttribute(i);return e!==n&&(t=u(e,n),function(n){this.setAttribute(i,t(n))})}function a(){var t,e=this.getAttributeNS(i.space,i.local);return e!==n&&(t=u(e,n),function(n){this.setAttributeNS(i.space,i.local,t(n))})}return null==n?i.local?r:e:(n+="",i.local?a:t)})},ic.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=oa.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},ic.style=function(n,t,e){function r(){this.style.removeProperty(n)}var u=arguments.length;if(3>u){if("string"!=typeof n){2>u&&(t="");for(e in n)this.style(e,n[e],t);return this}e=""}var i=vr(n);return vi(this,"style."+n,t,function(t){function u(){var r,u=la.getComputedStyle(this,null).getPropertyValue(n);return u!==t&&(r=i(u,t),function(t){this.style.setProperty(n,r(t),e)})}return null==t?r:(t+="",u)})},ic.styleTween=function(n,t,e){return arguments.length<3&&(e=""),this.tween("style."+n,function(r,u){var i=t.call(this,r,u,la.getComputedStyle(this,null).getPropertyValue(n));return i&&function(t){this.style.setProperty(n,i(t),e)}})},ic.text=function(n){return vi(this,"text",n,yi)},ic.remove=function(){return this.each("end.transition",function(){var n;!this.__transition__&&(n=this.parentNode)&&n.removeChild(this)})},ic.ease=function(n){var t=this.id;return arguments.length<1?this.node().__transition__[t].ease:("function"!=typeof n&&(n=oa.ease.apply(oa,arguments)),D(this,function(e){e.__transition__[t].ease=n}))},ic.delay=function(n){var t=this.id;return D(this,"function"==typeof n?function(e,r,u){e.__transition__[t].delay=n.call(e,e.__data__,r,u)|0}:(n|=0,function(e){e.__transition__[t].delay=n}))},ic.duration=function(n){var t=this.id;return D(this,"function"==typeof n?function(e,r,u){e.__transition__[t].duration=Math.max(1,n.call(e,e.__data__,r,u)|0)}:(n=Math.max(1,0|n),function(e){e.__transition__[t].duration=n}))},ic.each=function(n,t){var e=this.id;if(arguments.length<2){var r=oc,u=ec;ec=e,D(this,function(t,r,u){oc=t.__transition__[e],n.call(t,t.__data__,r,u)}),oc=r,ec=u}else D(this,function(r){r.__transition__[e].event.on(n,t)});return this},ic.transition=function(){for(var n,t,e,r,u=this.id,i=++ac,a=[],o=0,c=this.length;c>o;o++){a.push(n=[]);for(var t=this[o],l=0,f=t.length;f>l;l++)(e=t[l])&&(r=Object.create(e.__transition__[u]),r.delay+=r.duration,Mi(e,l,i,r)),n.push(e)}return mi(a,i)},oa.svg.axis=function(){function n(n){n.each(function(){var n,s=oa.select(this),h=null==l?e.ticks?e.ticks.apply(e,c):e.domain():l,g=null==t?e.tickFormat?e.tickFormat.apply(e,c):String:t,p=_i(e,h,f),d=s.selectAll(".tick.minor").data(p,String),m=d.enter().insert("line",".tick").attr("class","tick minor").style("opacity",1e-6),v=oa.transition(d.exit()).style("opacity",1e-6).remove(),y=oa.transition(d).style("opacity",1),M=s.selectAll(".tick.major").data(h,String),x=M.enter().insert("g","path").attr("class","tick major").style("opacity",1e-6),b=oa.transition(M.exit()).style("opacity",1e-6).remove(),_=oa.transition(M).style("opacity",1),w=Lu(e),S=s.selectAll(".domain").data([0]),E=(S.enter().append("path").attr("class","domain"),oa.transition(S)),k=e.copy(),A=this.__chart__||k;this.__chart__=k,x.append("line"),x.append("text");var q=x.select("line"),N=_.select("line"),T=M.select("text").text(g),C=x.select("text"),z=_.select("text");switch(r){case"bottom":n=xi,m.attr("y2",i),y.attr("x2",0).attr("y2",i),q.attr("y2",u),C.attr("y",Math.max(u,0)+o),N.attr("x2",0).attr("y2",u),z.attr("x",0).attr("y",Math.max(u,0)+o),T.attr("dy",".71em").style("text-anchor","middle"),E.attr("d","M"+w[0]+","+a+"V0H"+w[1]+"V"+a);break;case"top":n=xi,m.attr("y2",-i),y.attr("x2",0).attr("y2",-i),q.attr("y2",-u),C.attr("y",-(Math.max(u,0)+o)),N.attr("x2",0).attr("y2",-u),z.attr("x",0).attr("y",-(Math.max(u,0)+o)),T.attr("dy","0em").style("text-anchor","middle"),E.attr("d","M"+w[0]+","+-a+"V0H"+w[1]+"V"+-a);break;case"left":n=bi,m.attr("x2",-i),y.attr("x2",-i).attr("y2",0),q.attr("x2",-u),C.attr("x",-(Math.max(u,0)+o)),N.attr("x2",-u).attr("y2",0),z.attr("x",-(Math.max(u,0)+o)).attr("y",0),T.attr("dy",".32em").style("text-anchor","end"),E.attr("d","M"+-a+","+w[0]+"H0V"+w[1]+"H"+-a);break;case"right":n=bi,m.attr("x2",i),y.attr("x2",i).attr("y2",0),q.attr("x2",u),C.attr("x",Math.max(u,0)+o),N.attr("x2",u).attr("y2",0),z.attr("x",Math.max(u,0)+o).attr("y",0),T.attr("dy",".32em").style("text-anchor","start"),E.attr("d","M"+a+","+w[0]+"H0V"+w[1]+"H"+a)}if(e.ticks)x.call(n,A),_.call(n,k),b.call(n,k),m.call(n,A),y.call(n,k),v.call(n,k);else{var D=k.rangeBand()/2,j=function(n){return k(n)+D};x.call(n,j),_.call(n,j)}})}var t,e=oa.scale.linear(),r=cc,u=6,i=6,a=6,o=3,c=[10],l=null,f=0;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in lc?t+"":cc,n):r},n.ticks=function(){return arguments.length?(c=arguments,n):c},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t,e){if(!arguments.length)return u;var r=arguments.length-1;return u=+t,i=r>1?+e:u,a=r>0?+arguments[r]:u,n},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(t){return arguments.length?(f=+t,n):f},n};var cc="bottom",lc={top:1,right:1,bottom:1,left:1};oa.svg.brush=function(){function n(i){i.each(function(){var i,a=oa.select(this),l=a.selectAll(".background").data([0]),s=a.selectAll(".extent").data([0]),h=a.selectAll(".resize").data(f,String);a.style("pointer-events","all").on("mousedown.brush",u).on("touchstart.brush",u),l.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),s.enter().append("rect").attr("class","extent").style("cursor","move"),h.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return fc[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),h.style("display",n.empty()?"none":null),h.exit().remove(),o&&(i=Lu(o),l.attr("x",i[0]).attr("width",i[1]-i[0]),e(a)),c&&(i=Lu(c),l.attr("y",i[0]).attr("height",i[1]-i[0]),r(a)),t(a)})}function t(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+h[+/e$/.test(n)][0]+","+h[+/^s/.test(n)][1]+")"})}function e(n){n.select(".extent").attr("x",h[0][0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",h[1][0]-h[0][0])}function r(n){n.select(".extent").attr("y",h[0][1]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1][1]-h[0][1])}function u(){function u(){var n=oa.event.changedTouches;return n?oa.touches(y,n)[0]:oa.mouse(y)}function f(){oa.event.keyCode==32&&(E||(m=null,k[0]-=h[1][0],k[1]-=h[1][1],E=2),l())}function s(){oa.event.keyCode==32&&2==E&&(k[0]+=h[1][0],k[1]+=h[1][1],E=0,l())}function g(){var n=u(),i=!1;v&&(n[0]+=v[0],n[1]+=v[1]),E||(oa.event.altKey?(m||(m=[(h[0][0]+h[1][0])/2,(h[0][1]+h[1][1])/2]),k[0]=h[+(n[0]<m[0])][0],k[1]=h[+(n[1]<m[1])][1]):m=null),w&&p(n,o,0)&&(e(b),i=!0),S&&p(n,c,1)&&(r(b),i=!0),i&&(t(b),x({type:"brush",mode:E?"move":"resize"}))}function p(n,t,e){var r,u,a=Lu(t),o=a[0],c=a[1],l=k[e],f=h[1][e]-h[0][e];return E&&(o-=l,c-=f+l),r=Math.max(o,Math.min(c,n[e])),E?u=(r+=l)+f:(m&&(l=Math.max(o,Math.min(c,2*m[e]-r))),r>l?(u=r,r=l):u=l),h[0][e]!==r||h[1][e]!==u?(i=null,h[0][e]=r,h[1][e]=u,!0):void 0}function d(){g(),b.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),oa.select("body").style("cursor",null),A.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),x({type:"brushend"}),l()}var m,v,y=this,M=oa.select(oa.event.target),x=a.of(y,arguments),b=oa.select(y),_=M.datum(),w=!/^(n|s)$/.test(_)&&o,S=!/^(e|w)$/.test(_)&&c,E=M.classed("extent"),k=u(),A=oa.select(la).on("mousemove.brush",g).on("mouseup.brush",d).on("touchmove.brush",g).on("touchend.brush",d).on("keydown.brush",f).on("keyup.brush",s);if(E)k[0]=h[0][0]-k[0],k[1]=h[0][1]-k[1];else if(_){var q=+/w$/.test(_),N=+/^n/.test(_);v=[h[1-q][0]-k[0],h[1-N][1]-k[1]],k[0]=h[q][0],k[1]=h[N][1]}else oa.event.altKey&&(m=k.slice());b.style("pointer-events","none").selectAll(".resize").style("display",null),oa.select("body").style("cursor",M.style("cursor")),x({type:"brushstart"}),g(),l()
}var i,a=s(n,"brushstart","brush","brushend"),o=null,c=null,f=sc[0],h=[[0,0],[0,0]];return n.x=function(t){return arguments.length?(o=t,f=sc[!o<<1|!c],n):o},n.y=function(t){return arguments.length?(c=t,f=sc[!o<<1|!c],n):c},n.extent=function(t){var e,r,u,a,l;return arguments.length?(i=[[0,0],[0,0]],o&&(e=t[0],r=t[1],c&&(e=e[0],r=r[0]),i[0][0]=e,i[1][0]=r,o.invert&&(e=o(e),r=o(r)),e>r&&(l=e,e=r,r=l),h[0][0]=0|e,h[1][0]=0|r),c&&(u=t[0],a=t[1],o&&(u=u[1],a=a[1]),i[0][1]=u,i[1][1]=a,c.invert&&(u=c(u),a=c(a)),u>a&&(l=u,u=a,a=l),h[0][1]=0|u,h[1][1]=0|a),n):(t=i||h,o&&(e=t[0][0],r=t[1][0],i||(e=h[0][0],r=h[1][0],o.invert&&(e=o.invert(e),r=o.invert(r)),e>r&&(l=e,e=r,r=l))),c&&(u=t[0][1],a=t[1][1],i||(u=h[0][1],a=h[1][1],c.invert&&(u=c.invert(u),a=c.invert(a)),u>a&&(l=u,u=a,a=l))),o&&c?[[e,u],[r,a]]:o?[e,r]:c&&[u,a])},n.clear=function(){return i=null,h[0][0]=h[0][1]=h[1][0]=h[1][1]=0,n},n.empty=function(){return o&&h[0][0]===h[1][0]||c&&h[0][1]===h[1][1]},oa.rebind(n,a,"on")};var fc={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},sc=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]];oa.time={};var hc=Date,gc=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];wi.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){pc.setUTCDate.apply(this._,arguments)},setDay:function(){pc.setUTCDay.apply(this._,arguments)},setFullYear:function(){pc.setUTCFullYear.apply(this._,arguments)},setHours:function(){pc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){pc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){pc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){pc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){pc.setUTCSeconds.apply(this._,arguments)},setTime:function(){pc.setTime.apply(this._,arguments)}};var pc=Date.prototype,dc="%a %b %e %X %Y",mc="%m/%d/%Y",vc="%H:%M:%S",yc=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],Mc=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],xc=["January","February","March","April","May","June","July","August","September","October","November","December"],bc=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];oa.time.year=Si(function(n){return n=oa.time.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),oa.time.years=oa.time.year.range,oa.time.years.utc=oa.time.year.utc.range,oa.time.day=Si(function(n){var t=new hc(1970,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),oa.time.days=oa.time.day.range,oa.time.days.utc=oa.time.day.utc.range,oa.time.dayOfYear=function(n){var t=oa.time.year(n);return Math.floor((n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*6e4)/864e5)},gc.forEach(function(n,t){n=n.toLowerCase(),t=7-t;var e=oa.time[n]=Si(function(n){return(n=oa.time.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+Math.floor(t)*7)},function(n){var e=oa.time.year(n).getDay();return Math.floor((oa.time.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});oa.time[n+"s"]=e.range,oa.time[n+"s"].utc=e.utc.range,oa.time[n+"OfYear"]=function(n){var e=oa.time.year(n).getDay();return Math.floor((oa.time.dayOfYear(n)+(e+t)%7)/7)}}),oa.time.week=oa.time.sunday,oa.time.weeks=oa.time.sunday.range,oa.time.weeks.utc=oa.time.sunday.utc.range,oa.time.weekOfYear=oa.time.sundayOfYear,oa.time.format=function(n){function t(t){for(var r,u,i,a=[],o=-1,c=0;++o<e;)n.charCodeAt(o)===37&&(a.push(n.substring(c,o)),(u=qc[r=n.charAt(++o)])!=null&&(r=n.charAt(++o)),(i=Nc[r])&&(r=i(t,null==u?"e"===r?" ":"0":u)),a.push(r),c=o+1);return a.push(n.substring(c,o)),a.join("")}var e=n.length;return t.parse=function(t){var e={y:1900,m:0,d:1,H:0,M:0,S:0,L:0},r=ki(e,n,t,0);if(r!=t.length)return null;"p"in e&&(e.H=e.H%12+e.p*12);var u=new hc;return u.setFullYear(e.y,e.m,e.d),u.setHours(e.H,e.M,e.S,e.L),u},t.toString=function(){return n},t};var _c=Ai(yc),wc=Ai(Mc),Sc=Ai(xc),Ec=qi(xc),kc=Ai(bc),Ac=qi(bc),qc={"-":"",_:" ",0:"0"},Nc={a:function(n){return Mc[n.getDay()]},A:function(n){return yc[n.getDay()]},b:function(n){return bc[n.getMonth()]},B:function(n){return xc[n.getMonth()]},c:oa.time.format(dc),d:function(n,t){return Ni(n.getDate(),t,2)},e:function(n,t){return Ni(n.getDate(),t,2)},H:function(n,t){return Ni(n.getHours(),t,2)},I:function(n,t){return Ni(n.getHours()%12||12,t,2)},j:function(n,t){return Ni(1+oa.time.dayOfYear(n),t,3)},L:function(n,t){return Ni(n.getMilliseconds(),t,3)},m:function(n,t){return Ni(n.getMonth()+1,t,2)},M:function(n,t){return Ni(n.getMinutes(),t,2)},p:function(n){return n.getHours()>=12?"PM":"AM"},S:function(n,t){return Ni(n.getSeconds(),t,2)},U:function(n,t){return Ni(oa.time.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Ni(oa.time.mondayOfYear(n),t,2)},x:oa.time.format(mc),X:oa.time.format(vc),y:function(n,t){return Ni(n.getFullYear()%100,t,2)},Y:function(n,t){return Ni(n.getFullYear()%1e4,t,4)},Z:Bi,"%":function(){return"%"}},Tc={a:Ti,A:Ci,b:zi,B:Di,c:ji,d:Yi,e:Yi,H:Ui,I:Ui,L:Xi,m:Oi,M:Ii,p:Zi,S:Vi,x:Li,X:Fi,y:Pi,Y:Hi},Cc=/^\s*\d+/,zc=oa.map({am:0,pm:1});oa.time.format.utc=function(n){function t(n){try{hc=wi;var t=new hc;return t._=n,e(t)}finally{hc=Date}}var e=oa.time.format(n);return t.parse=function(n){try{hc=wi;var t=e.parse(n);return t&&t._}finally{hc=Date}},t.toString=e.toString,t};var Dc=oa.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");oa.time.format.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?$i:Dc,$i.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},$i.toString=Dc.toString,oa.time.second=Si(function(n){return new hc(Math.floor(n/1e3)*1e3)},function(n,t){n.setTime(n.getTime()+Math.floor(t)*1e3)},function(n){return n.getSeconds()}),oa.time.seconds=oa.time.second.range,oa.time.seconds.utc=oa.time.second.utc.range,oa.time.minute=Si(function(n){return new hc(Math.floor(n/6e4)*6e4)},function(n,t){n.setTime(n.getTime()+Math.floor(t)*6e4)},function(n){return n.getMinutes()}),oa.time.minutes=oa.time.minute.range,oa.time.minutes.utc=oa.time.minute.utc.range,oa.time.hour=Si(function(n){var t=n.getTimezoneOffset()/60;return new hc((Math.floor(n/36e5-t)+t)*36e5)},function(n,t){n.setTime(n.getTime()+Math.floor(t)*36e5)},function(n){return n.getHours()}),oa.time.hours=oa.time.hour.range,oa.time.hours.utc=oa.time.hour.utc.range,oa.time.month=Si(function(n){return n=oa.time.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),oa.time.months=oa.time.month.range,oa.time.months.utc=oa.time.month.utc.range;var jc=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Lc=[[oa.time.second,1],[oa.time.second,5],[oa.time.second,15],[oa.time.second,30],[oa.time.minute,1],[oa.time.minute,5],[oa.time.minute,15],[oa.time.minute,30],[oa.time.hour,1],[oa.time.hour,3],[oa.time.hour,6],[oa.time.hour,12],[oa.time.day,1],[oa.time.day,2],[oa.time.week,1],[oa.time.month,1],[oa.time.month,3],[oa.time.year,1]],Fc=[[oa.time.format("%Y"),Dt],[oa.time.format("%B"),function(n){return n.getMonth()}],[oa.time.format("%b %d"),function(n){return n.getDate()!=1}],[oa.time.format("%a %d"),function(n){return n.getDay()&&n.getDate()!=1}],[oa.time.format("%I %p"),function(n){return n.getHours()}],[oa.time.format("%I:%M"),function(n){return n.getMinutes()}],[oa.time.format(":%S"),function(n){return n.getSeconds()}],[oa.time.format(".%L"),function(n){return n.getMilliseconds()}]],Hc=oa.scale.linear(),Pc=Wi(Fc);Lc.year=function(n,t){return Hc.domain(n.map(na)).ticks(t).map(Qi)},oa.time.scale=function(){return Ji(oa.scale.linear(),Lc,Pc)};var Rc=Lc.map(function(n){return[n[0].utc,n[1]]}),Oc=[[oa.time.format.utc("%Y"),Dt],[oa.time.format.utc("%B"),function(n){return n.getUTCMonth()}],[oa.time.format.utc("%b %d"),function(n){return n.getUTCDate()!=1}],[oa.time.format.utc("%a %d"),function(n){return n.getUTCDay()&&n.getUTCDate()!=1}],[oa.time.format.utc("%I %p"),function(n){return n.getUTCHours()}],[oa.time.format.utc("%I:%M"),function(n){return n.getUTCMinutes()}],[oa.time.format.utc(":%S"),function(n){return n.getUTCSeconds()}],[oa.time.format.utc(".%L"),function(n){return n.getUTCMilliseconds()}]],Yc=Wi(Oc);return Rc.year=function(n,t){return Hc.domain(n.map(ea)).ticks(t).map(ta)},oa.time.scale.utc=function(){return Ji(oa.scale.linear(),Rc,Yc)},oa.text=function(){return oa.xhr.apply(oa,arguments).response(ra)},oa.json=function(n,t){return oa.xhr(n,"application/json",t).response(ua)},oa.html=function(n,t){return oa.xhr(n,"text/html",t).response(ia)},oa.xml=function(){return oa.xhr.apply(oa,arguments).response(aa)},oa}();
// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Hinter = (function() {
    function Hinter(element) {
      this.set_bottom_links = __bind(this.set_bottom_links, this);
      this.answer_choice_handle = __bind(this.answer_choice_handle, this);
      this.wizard_link_handle = __bind(this.wizard_link_handle, this);
      this.clear_default_text = __bind(this.clear_default_text, this);
      this.submit_hint = __bind(this.submit_hint, this);
      this.vote = __bind(this.vote, this);
      this.expand = __bind(this.expand, this);
      this.bind = __bind(this.bind, this);
      this.capture_problem = __bind(this.capture_problem, this);
      this.el = $(element).find('.crowdsource-wrapper');
      this.url = this.el.data('url');
      Logger.listen('problem_graded', this.el.data('child-url'), this.capture_problem);
      this.render();
    }

    Hinter.prototype.capture_problem = function(event_type, data, element) {
      var answers, response,
        _this = this;
      answers = data[0];
      response = data[1];
      if (response.search(/class="correct/) === -1) {
        return $.postWithPrefix("" + this.url + "/get_hint", answers, function(response) {
          return _this.render(response.contents);
        });
      } else {
        return $.postWithPrefix("" + this.url + "/get_feedback", answers, function(response) {
          return _this.render(response.contents);
        });
      }
    };

    Hinter.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Hinter.prototype.bind = function() {
      this.$('input.vote').click(this.vote);
      this.$('input.submit-hint').click(this.submit_hint);
      this.$('.custom-hint').click(this.clear_default_text);
      this.$('.expand').click(this.expand);
      this.$('.wizard-link').click(this.wizard_link_handle);
      return this.$('.answer-choice').click(this.answer_choice_handle);
    };

    Hinter.prototype.expand = function(eventObj) {
      var target;
      target = this.$('#' + this.$(eventObj.currentTarget).data('target'));
      if (this.$(target).css('display') === 'none') {
        this.$(target).css('display', 'block');
      } else {
        this.$(target).css('display', 'none');
      }
      return this.set_bottom_links();
    };

    Hinter.prototype.vote = function(eventObj) {
      var all_pks, post_json, target,
        _this = this;
      target = this.$(eventObj.currentTarget);
      all_pks = this.$('#pk-list').attr('data-pk-list');
      post_json = {
        'answer': target.attr('data-answer'),
        'hint': target.data('hintno'),
        'pk_list': all_pks
      };
      return $.postWithPrefix("" + this.url + "/vote", post_json, function(response) {
        return _this.render(response.contents);
      });
    };

    Hinter.prototype.submit_hint = function(eventObj) {
      var post_json, textarea,
        _this = this;
      textarea = $('.custom-hint');
      if (this.answer === '') {
        return;
      }
      post_json = {
        'answer': this.answer,
        'hint': textarea.val()
      };
      return $.postWithPrefix("" + this.url + "/submit_hint", post_json, function(response) {
        return _this.render(response.contents);
      });
    };

    Hinter.prototype.clear_default_text = function(eventObj) {
      var target;
      target = this.$(eventObj.currentTarget);
      if (target.data('cleared') === void 0) {
        target.val('');
        return target.data('cleared', true);
      }
    };

    Hinter.prototype.wizard_link_handle = function(eventObj) {
      var target;
      target = this.$(eventObj.currentTarget);
      return this.go_to(target.attr('dest'));
    };

    Hinter.prototype.answer_choice_handle = function(eventObj) {
      this.answer = this.$(eventObj.target).attr('value');
      this.$('#blank-answer').html(this.answer);
      return this.go_to('p3');
    };

    Hinter.prototype.set_bottom_links = function() {
      var viewbox_height;
      this.$('.bottom').css('margin-top', '0px');
      viewbox_height = parseInt(this.$('.wizard-viewbox').css('height'), 10);
      return this.$('.bottom').each(function(index, obj) {
        var view_height;
        view_height = parseInt($(obj).parent().css('height'), 10);
        return $(obj).css('margin-top', (viewbox_height - view_height) + 'px');
      });
    };

    Hinter.prototype.render = function(content) {
      var hints_exist, styles,
        _this = this;
      if (content) {
        content = content.trim();
      }
      if (content) {
        this.el.html(content);
        this.el.show();
        JavascriptLoader.executeModuleScripts(this.el, function() {
          return _this.bind();
        });
        this.$('#previous-answer-0').css('display', 'inline');
      } else {
        this.el.hide();
      }
      this.answer = '';
      styles = document.body.style;
      if (styles.WebkitTransform === '' || styles.transform === '') {
        this.go_to = this.transform_go_to;
      } else {
        this.go_to = this.legacy_go_to;
      }
      hints_exist = this.$('#hints-exist').html() === 'True';
      if (hints_exist) {
        return this.go_to('p1');
      } else {
        return this.go_to('p2');
      }
    };

    Hinter.prototype.transform_go_to = function(view_id) {
      var id_to_index, translate_string;
      id_to_index = {
        'p1': 0,
        'p2': 1,
        'p3': 2
      };
      translate_string = 'translateX(' + id_to_index[view_id] * -1 * parseInt($('#' + view_id).css('width'), 10) + 'px)';
      this.$('.wizard-container').css('transform', translate_string);
      this.$('.wizard-container').css('-webkit-transform', translate_string);
      return this.set_bottom_links();
    };

    Hinter.prototype.legacy_go_to = function(view_id) {
      this.$('.wizard-view').css('display', 'none');
      this.$('#' + view_id).css('display', 'block');
      return this.set_bottom_links();
    };

    return Hinter;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.PeerGradingProblemBackend = (function() {
    function PeerGradingProblemBackend(ajax_url, mock_backend) {
      this.mock_backend = mock_backend;
      this.ajax_url = ajax_url;
      this.mock_cnt = 0;
    }

    PeerGradingProblemBackend.prototype.post = function(cmd, data, callback) {
      var _this = this;
      if (this.mock_backend) {
        return callback(this.mock(cmd, data));
      } else {
        return $.post(this.ajax_url + cmd, data, callback).error(function() {
          return callback({
            success: false,
            error: "Error occured while performing this operation"
          });
        });
      }
    };

    PeerGradingProblemBackend.prototype.mock = function(cmd, data) {
      var response;
      if (cmd === 'is_student_calibrated') {
        response = {
          success: true,
          calibrated: this.mock_cnt >= 2
        };
      } else if (cmd === 'show_calibration_essay') {
        this.mock_cnt++;
        response = {
          success: true,
          submission_id: 1,
          submission_key: 'abcd',
          student_response: 'Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of "de Finibus Bonorum et Malorum" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, "Lorem ipsum dolor sit amet..", comes from a line in section 1.10.32.\n\nThe standard chunk of Lorem Ipsum used since the 1500s is reproduced below for those interested. Sections 1.10.32 and 1.10.33 from "de Finibus Bonorum et Malorum" by Cicero are also reproduced in their exact original form, accompanied by English versions from the 1914 translation by H. Rackham.',
          prompt: '<h2>S11E3: Metal Bands</h2>\n<p>Shown below are schematic band diagrams for two different metals. Both diagrams appear different, yet both of the elements are undisputably metallic in nature.</p>\n<p>* Why is it that both sodium and magnesium behave as metals, even though the s-band of magnesium is filled? </p>\n<p>This is a self-assessed open response question. Please use as much space as you need in the box below to answer the question.</p>',
          rubric: '<table class="rubric"><tbody><tr><th>Purpose</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-0" value="0"><label for="score-0-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-1" value="1"><label for="score-0-1">Unclear purpose or main idea</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-2" value="2"><label for="score-0-2">Communicates an identifiable purpose and/or main idea for an audience</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-3" value="3"><label for="score-0-3">Achieves a clear and distinct purpose for a targeted audience and communicates main ideas with effectively used techniques to introduce and represent ideas and insights</label>\n</td>\n</tr><tr><th>Organization</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-0" value="0"><label for="score-1-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-1" value="1"><label for="score-1-1">Organization is unclear; introduction, body, and/or conclusion are underdeveloped, missing or confusing.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-2" value="2"><label for="score-1-2">Organization is occasionally unclear; introduction, body or conclusion may be underdeveloped.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-3" value="3"><label for="score-1-3">Organization is clear and easy to follow; introduction, body and conclusion are defined and aligned with purpose.</label>\n</td>\n</tr></tbody></table>',
          max_score: 4
        };
      } else if (cmd === 'get_next_submission') {
        response = {
          success: true,
          submission_id: 1,
          submission_key: 'abcd',
          student_response: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec tristique ante. Proin at mauris sapien, quis varius leo. Morbi laoreet leo nisi. Morbi aliquam lacus ante. Cras iaculis velit sed diam mattis a fermentum urna luctus. Duis consectetur nunc vitae felis facilisis eget vulputate risus viverra. Cras consectetur ullamcorper lobortis. Nam eu gravida lorem. Nulla facilisi. Nullam quis felis enim. Mauris orci lectus, dictum id cursus in, vulputate in massa.\n\nPhasellus non varius sem. Nullam commodo lacinia odio sit amet egestas. Donec ullamcorper sapien sagittis arcu volutpat placerat. Phasellus ut pretium ante. Nam dictum pulvinar nibh dapibus tristique. Sed at tellus mi, fringilla convallis justo. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus tristique rutrum nulla sed eleifend. Praesent at nunc arcu. Mauris condimentum faucibus nibh, eget commodo quam viverra sed. Morbi in tincidunt dolor. Morbi sed augue et augue interdum fermentum.\n\nCurabitur tristique purus ac arcu consequat cursus. Cras diam felis, dignissim quis placerat at, aliquet ac metus. Mauris vulputate est eu nibh imperdiet varius. Cras aliquet rhoncus elit a laoreet. Mauris consectetur erat et erat scelerisque eu faucibus dolor consequat. Nam adipiscing sagittis nisl, eu mollis massa tempor ac. Nulla scelerisque tempus blandit. Phasellus ac ipsum eros, id posuere arcu. Nullam non sapien arcu. Vivamus sit amet lorem justo, ac tempus turpis. Suspendisse pharetra gravida imperdiet. Pellentesque lacinia mi eu elit luctus pellentesque. Sed accumsan libero a magna elementum varius. Nunc eget pellentesque metus. ',
          prompt: '<h2>S11E3: Metal Bands</h2>\n<p>Shown below are schematic band diagrams for two different metals. Both diagrams appear different, yet both of the elements are undisputably metallic in nature.</p>\n<p>* Why is it that both sodium and magnesium behave as metals, even though the s-band of magnesium is filled? </p>\n<p>This is a self-assessed open response question. Please use as much space as you need in the box below to answer the question.</p>',
          rubric: '<table class="rubric"><tbody><tr><th>Purpose</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-0" value="0"><label for="score-0-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-1" value="1"><label for="score-0-1">Unclear purpose or main idea</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-2" value="2"><label for="score-0-2">Communicates an identifiable purpose and/or main idea for an audience</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-0" id="score-0-3" value="3"><label for="score-0-3">Achieves a clear and distinct purpose for a targeted audience and communicates main ideas with effectively used techniques to introduce and represent ideas and insights</label>\n</td>\n</tr><tr><th>Organization</th>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-0" value="0"><label for="score-1-0">No product</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-1" value="1"><label for="score-1-1">Organization is unclear; introduction, body, and/or conclusion are underdeveloped, missing or confusing.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-2" value="2"><label for="score-1-2">Organization is occasionally unclear; introduction, body or conclusion may be underdeveloped.</label>\n</td>\n\n<td>\n<input type="radio" class="score-selection" name="score-selection-1" id="score-1-3" value="3"><label for="score-1-3">Organization is clear and easy to follow; introduction, body and conclusion are defined and aligned with purpose.</label>\n</td>\n</tr></tbody></table>',
          max_score: 4
        };
      } else if (cmd === 'save_calibration_essay') {
        response = {
          success: true,
          actual_score: 2
        };
      } else if (cmd === 'save_grade') {
        response = {
          success: true
        };
      }
      return response;
    };

    return PeerGradingProblemBackend;

  })();

  this.PeerGradingProblem = (function() {
    PeerGradingProblem.prototype.prompt_wrapper_sel = '.prompt-wrapper';

    PeerGradingProblem.prototype.peer_grading_container_sel = '.peer-grading-container';

    PeerGradingProblem.prototype.submission_container_sel = '.submission-container';

    PeerGradingProblem.prototype.prompt_container_sel = '.prompt-container';

    PeerGradingProblem.prototype.rubric_container_sel = '.rubric-container';

    PeerGradingProblem.prototype.flag_student_container_sel = '.flag-student-container';

    PeerGradingProblem.prototype.answer_unknown_container_sel = '.answer-unknown-container';

    PeerGradingProblem.prototype.calibration_panel_sel = '.calibration-panel';

    PeerGradingProblem.prototype.grading_panel_sel = '.grading-panel';

    PeerGradingProblem.prototype.content_panel_sel = '.content-panel';

    PeerGradingProblem.prototype.grading_message_sel = '.grading-message';

    PeerGradingProblem.prototype.question_header_sel = '.question-header';

    PeerGradingProblem.prototype.flag_submission_confirmation_sel = '.flag-submission-confirmation';

    PeerGradingProblem.prototype.flag_submission_confirmation_button_sel = '.flag-submission-confirmation-button';

    PeerGradingProblem.prototype.flag_submission_removal_button_sel = '.flag-submission-removal-button';

    PeerGradingProblem.prototype.grading_wrapper_sel = '.grading-wrapper';

    PeerGradingProblem.prototype.calibration_feedback_sel = '.calibration-feedback';

    PeerGradingProblem.prototype.interstitial_page_sel = '.interstitial-page';

    PeerGradingProblem.prototype.calibration_interstitial_page_sel = '.calibration-interstitial-page';

    PeerGradingProblem.prototype.error_container_sel = '.error-container';

    PeerGradingProblem.prototype.feedback_area_sel = '.feedback-area';

    PeerGradingProblem.prototype.score_selection_container_sel = '.score-selection-container';

    PeerGradingProblem.prototype.rubric_selection_container_sel = '.rubric-selection-container';

    PeerGradingProblem.prototype.submit_button_sel = '.submit-button';

    PeerGradingProblem.prototype.action_button_sel = '.action-button';

    PeerGradingProblem.prototype.calibration_feedback_button_sel = '.calibration-feedback-button';

    PeerGradingProblem.prototype.interstitial_page_button_sel = '.interstitial-page-button';

    PeerGradingProblem.prototype.calibration_interstitial_page_button_sel = '.calibration-interstitial-page-button';

    PeerGradingProblem.prototype.flag_checkbox_sel = '.flag-checkbox';

    PeerGradingProblem.prototype.answer_unknown_checkbox_sel = '.answer-unknown-checkbox';

    PeerGradingProblem.prototype.calibration_text_sel = '.calibration-text';

    PeerGradingProblem.prototype.grading_text_sel = '.grading-text';

    PeerGradingProblem.prototype.calibration_feedback_wrapper_sel = '.calibration-feedback-wrapper';

    function PeerGradingProblem(backend, el) {
      this.scroll_to_top = __bind(this.scroll_to_top, this);
      this.collapse_question = __bind(this.collapse_question, this);
      this.gentle_alert = __bind(this.gentle_alert, this);
      this.setup_score_selection = __bind(this.setup_score_selection, this);
      this.show_submit_button = __bind(this.show_submit_button, this);
      this.render_error = __bind(this.render_error, this);
      this.render_calibration_interstitial_page = __bind(this.render_calibration_interstitial_page, this);
      this.render_interstitial_page = __bind(this.render_interstitial_page, this);
      this.render_calibration_feedback = __bind(this.render_calibration_feedback, this);
      this.render_submission_data = __bind(this.render_submission_data, this);
      this.render_submission = __bind(this.render_submission, this);
      this.render_calibration = __bind(this.render_calibration, this);
      this.keyup_handler = __bind(this.keyup_handler, this);
      this.keydown_handler = __bind(this.keydown_handler, this);
      this.graded_callback = __bind(this.graded_callback, this);
      this.submission_callback = __bind(this.submission_callback, this);
      this.calibration_callback = __bind(this.calibration_callback, this);
      this.calibration_check_callback = __bind(this.calibration_check_callback, this);
      this.flag_box_checked = __bind(this.flag_box_checked, this);
      this.close_dialog_box = __bind(this.close_dialog_box, this);
      this.remove_flag = __bind(this.remove_flag, this);
      this.submit_grade = __bind(this.submit_grade, this);
      this.submit_calibration_essay = __bind(this.submit_calibration_essay, this);
      this.fetch_submission_essay = __bind(this.fetch_submission_essay, this);
      this.fetch_calibration_essay = __bind(this.fetch_calibration_essay, this);
      this.is_calibrated_check = __bind(this.is_calibrated_check, this);
      var _this = this;
      this.el = el;
      this.prompt_wrapper = $(this.prompt_wrapper_sel);
      this.backend = backend;
      this.is_ctrl = false;
      this.el = $(this.peer_grading_container_sel);
      this.location = $('.peer-grading').data('location');
      if (!this.location) {
        return;
      }
      this.submission_container = this.$(this.submission_container_sel);
      this.prompt_container = this.$(this.prompt_container_sel);
      this.rubric_container = this.$(this.rubric_container_sel);
      this.flag_student_container = this.$(this.flag_student_container_sel);
      this.answer_unknown_container = this.$(this.answer_unknown_container_sel);
      this.calibration_panel = this.$(this.calibration_panel_sel);
      this.grading_panel = this.$(this.grading_panel_sel);
      this.content_panel = this.$(this.content_panel_sel);
      this.grading_message = this.$(this.grading_message_sel);
      this.grading_message.hide();
      this.question_header = this.$(this.question_header_sel);
      this.question_header.click(this.collapse_question);
      this.flag_submission_confirmation = this.$(this.flag_submission_confirmation_sel);
      this.flag_submission_confirmation_button = this.$(this.flag_submission_confirmation_button_sel);
      this.flag_submission_removal_button = this.$(this.flag_submission_removal_button_sel);
      this.flag_submission_confirmation_button.click(this.close_dialog_box);
      this.flag_submission_removal_button.click(this.remove_flag);
      this.grading_wrapper = this.$(this.grading_wrapper_sel);
      this.calibration_feedback_panel = this.$(this.calibration_feedback_sel);
      this.interstitial_page = this.$(this.interstitial_page_sel);
      this.interstitial_page.hide();
      this.calibration_interstitial_page = this.$(this.calibration_interstitial_page_sel);
      this.calibration_interstitial_page.hide();
      this.error_container = this.$(this.error_container_sel);
      this.submission_key_input = $("input[name='submission-key']");
      this.essay_id_input = this.$("input[name='essay-id']");
      this.feedback_area = this.$(this.feedback_area_sel);
      this.score_selection_container = this.$(this.score_selection_container_sel);
      this.rubric_selection_container = this.$(this.rubric_selection_container_sel);
      this.grade = null;
      this.calibration = null;
      this.submit_button = this.$(this.submit_button_sel);
      this.action_button = this.$(this.action_button_sel);
      this.calibration_feedback_button = this.$(this.calibration_feedback_button_sel);
      this.interstitial_page_button = this.$(this.interstitial_page_button_sel);
      this.calibration_interstitial_page_button = this.$(this.calibration_interstitial_page_button_sel);
      this.flag_student_checkbox = this.$(this.flag_checkbox_sel);
      this.answer_unknown_checkbox = this.$(this.answer_unknown_checkbox_sel);
      $(window).keydown(this.keydown_handler);
      $(window).keyup(this.keyup_handler);
      Collapsible.setCollapsibles(this.content_panel);
      this.action_button.click(function() {
        return history.back();
      });
      this.calibration_feedback_button.click(function() {
        _this.calibration_feedback_panel.hide();
        _this.grading_wrapper.show();
        _this.gentle_alert("Calibration essay saved.  Fetching the next essay.");
        return _this.is_calibrated_check();
      });
      this.interstitial_page_button.click(function() {
        _this.interstitial_page.hide();
        return _this.is_calibrated_check();
      });
      this.calibration_interstitial_page_button.click(function() {
        _this.calibration_interstitial_page.hide();
        return _this.is_calibrated_check();
      });
      this.flag_student_checkbox.click(function() {
        return _this.flag_box_checked();
      });
      this.calibration_feedback_button.hide();
      this.calibration_feedback_panel.hide();
      this.error_container.hide();
      this.flag_submission_confirmation.hide();
      this.is_calibrated_check();
    }

    PeerGradingProblem.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    PeerGradingProblem.prototype.is_calibrated_check = function() {
      return this.backend.post('is_student_calibrated', {
        location: this.location
      }, this.calibration_check_callback);
    };

    PeerGradingProblem.prototype.fetch_calibration_essay = function() {
      return this.backend.post('show_calibration_essay', {
        location: this.location
      }, this.render_calibration);
    };

    PeerGradingProblem.prototype.fetch_submission_essay = function() {
      return this.backend.post('get_next_submission', {
        location: this.location
      }, this.render_submission);
    };

    PeerGradingProblem.prototype.construct_data = function() {
      var data;
      data = {
        rubric_scores: this.rub.get_score_list(),
        score: this.rub.get_total_score(),
        location: this.location,
        submission_id: this.essay_id_input.val(),
        submission_key: this.submission_key_input.val(),
        feedback: this.feedback_area.val(),
        submission_flagged: this.flag_student_checkbox.is(':checked'),
        answer_unknown: this.answer_unknown_checkbox.is(':checked')
      };
      return data;
    };

    PeerGradingProblem.prototype.submit_calibration_essay = function() {
      var data;
      data = this.construct_data();
      this.submit_button.hide();
      return this.backend.post('save_calibration_essay', data, this.calibration_callback);
    };

    PeerGradingProblem.prototype.submit_grade = function() {
      var data;
      data = this.construct_data();
      this.submit_button.hide();
      return this.backend.post('save_grade', data, this.submission_callback);
    };

    PeerGradingProblem.prototype.remove_flag = function() {
      this.flag_student_checkbox.removeAttr("checked");
      this.close_dialog_box();
      return this.submit_button.attr('disabled', true);
    };

    PeerGradingProblem.prototype.close_dialog_box = function() {
      return $(this.flag_submission_confirmation_sel).dialog('close');
    };

    PeerGradingProblem.prototype.flag_box_checked = function() {
      if (this.flag_student_checkbox.is(':checked')) {
        this.$(this.flag_submission_confirmation_sel).dialog({
          height: 400,
          width: 400
        });
        return this.submit_button.attr('disabled', false);
      }
    };

    PeerGradingProblem.prototype.calibration_check_callback = function(response) {
      if (response.success) {
        if (response.calibrated && (this.calibration === null || this.calibration === false)) {
          this.calibration = false;
          return this.fetch_submission_essay();
        } else if (response.calibrated && this.calibration === true) {
          this.calibration = false;
          return this.render_interstitial_page();
        } else if (!response.calibrated && this.calibration === null) {
          this.calibration = true;
          return this.render_calibration_interstitial_page();
        } else {
          this.calibration = true;
          return this.fetch_calibration_essay();
        }
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("Error contacting the grading service");
      }
    };

    PeerGradingProblem.prototype.calibration_callback = function(response) {
      if (response.success) {
        return this.render_calibration_feedback(response);
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("Error saving calibration score");
      }
    };

    PeerGradingProblem.prototype.submission_callback = function(response) {
      var message;
      if (response.success) {
        this.is_calibrated_check();
        this.grading_message.fadeIn();
        message = "<p>Successfully saved your feedback. Fetching the next essay.";
        if (response.required_done) {
          message = message + " You have completed the required number of gradings.";
        }
        message = message + "</p>";
        return this.grading_message.html(message);
      } else {
        if (response.error) {
          return this.render_error(response.error);
        } else {
          return this.render_error("Error occurred while submitting grade");
        }
      }
    };

    PeerGradingProblem.prototype.graded_callback = function(event) {
      var ev, ul;
      ev = this.$(event.target).parent().parent();
      ul = ev.parent().parent();
      ul.find(".rubric-label-selected").removeClass('rubric-label-selected');
      ev.addClass('rubric-label-selected');
      if (this.rub.check_complete()) {
        this.grading_message.hide();
        this.show_submit_button();
        return this.grade = this.rub.get_total_score();
      }
    };

    PeerGradingProblem.prototype.keydown_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === false) {
        return this.is_ctrl = true;
      } else if (event.which === 13 && this.submit_button.is(':visible') && this.is_ctrl === true) {
        if (this.calibration) {
          return this.submit_calibration_essay();
        } else {
          return this.submit_grade();
        }
      }
    };

    PeerGradingProblem.prototype.keyup_handler = function(event) {
      if (event.which === 17 && this.is_ctrl === true) {
        return this.is_ctrl = false;
      }
    };

    PeerGradingProblem.prototype.render_calibration = function(response) {
      if (response.success) {
        this.submission_container.html("");
        this.render_submission_data(response);
        this.calibration_panel.addClass('current-state');
        this.grading_panel.removeClass('current-state');
        this.calibration_panel.find(this.calibration_text_sel).show();
        this.grading_panel.find(this.calibration_text_sel).show();
        this.calibration_panel.find(this.grading_text_sel).hide();
        this.grading_panel.find(this.grading_text_sel).hide();
        this.flag_student_container.hide();
        this.answer_unknown_container.hide();
        this.feedback_area.val("");
        this.submit_button.show();
        this.submit_button.unbind('click');
        this.submit_button.click(this.submit_calibration_essay);
        this.submit_button.attr('disabled', true);
        return this.scroll_to_top();
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("An error occurred while retrieving the next calibration essay");
      }
    };

    PeerGradingProblem.prototype.render_submission = function(response) {
      if (response.success) {
        this.submit_button.hide();
        this.submission_container.html("");
        this.render_submission_data(response);
        this.calibration_panel.removeClass('current-state');
        this.grading_panel.addClass('current-state');
        this.calibration_panel.find(this.calibration_text_sel).hide();
        this.grading_panel.find(this.calibration_text_sel).hide();
        this.calibration_panel.find(this.grading_text_sel).show();
        this.grading_panel.find(this.grading_text_sel).show();
        this.flag_student_container.show();
        this.answer_unknown_container.show();
        this.feedback_area.val("");
        this.flag_student_checkbox.removeAttr("checked");
        this.submit_button.show();
        this.submit_button.unbind('click');
        this.submit_button.click(this.submit_grade);
        this.submit_button.attr('disabled', true);
        return this.scroll_to_top();
      } else if (response.error) {
        return this.render_error(response.error);
      } else {
        return this.render_error("An error occured when retrieving the next submission.");
      }
    };

    PeerGradingProblem.prototype.make_paragraphs = function(text) {
      var new_text, paragraph, paragraph_split, _i, _len;
      paragraph_split = text.split(/\n\s*\n/);
      new_text = '';
      for (_i = 0, _len = paragraph_split.length; _i < _len; _i++) {
        paragraph = paragraph_split[_i];
        new_text += "<p>" + paragraph + "</p>";
      }
      return new_text;
    };

    PeerGradingProblem.prototype.render_submission_data = function(response) {
      this.content_panel.show();
      this.error_container.hide();
      this.submission_container.append(this.make_paragraphs(response.student_response));
      this.prompt_container.html(response.prompt);
      this.rubric_selection_container.html(response.rubric);
      this.submission_key_input.val(response.submission_key);
      this.essay_id_input.val(response.submission_id);
      this.setup_score_selection(response.max_score);
      this.submit_button.hide();
      this.action_button.hide();
      this.calibration_feedback_panel.hide();
      this.rub = new Rubric(this.el);
      return this.rub.initialize(this.location);
    };

    PeerGradingProblem.prototype.render_calibration_feedback = function(response) {
      var actual_score, calibration_wrapper, score;
      this.calibration_feedback_panel.slideDown();
      calibration_wrapper = this.$(this.calibration_feedback_wrapper_sel);
      calibration_wrapper.html("<p>The score you gave was: " + this.grade + ". The actual score is: " + response.actual_score + "</p>");
      score = parseInt(this.grade);
      actual_score = parseInt(response.actual_score);
      if (score === actual_score) {
        calibration_wrapper.append("<p>Your score matches the actual score!</p>");
      } else {
        calibration_wrapper.append("<p>You may want to review the rubric again.</p>");
      }
      if (response.actual_rubric !== void 0) {
        calibration_wrapper.append("<div>Instructor Scored Rubric: " + response.actual_rubric + "</div>");
      }
      if (response.actual_feedback.feedback !== void 0) {
        calibration_wrapper.append("<div>Instructor Feedback: " + response.actual_feedback + "</div>");
      }
      this.$("input[name='score-selection']").attr('disabled', true);
      this.submit_button.hide();
      return this.calibration_feedback_button.show();
    };

    PeerGradingProblem.prototype.render_interstitial_page = function() {
      this.content_panel.hide();
      this.grading_message.hide();
      return this.interstitial_page.show();
    };

    PeerGradingProblem.prototype.render_calibration_interstitial_page = function() {
      this.content_panel.hide();
      this.action_button.hide();
      return this.calibration_interstitial_page.show();
    };

    PeerGradingProblem.prototype.render_error = function(error_message) {
      this.error_container.show();
      this.calibration_feedback_panel.hide();
      this.error_container.html(error_message);
      this.content_panel.hide();
      return this.action_button.show();
    };

    PeerGradingProblem.prototype.show_submit_button = function() {
      this.submit_button.attr('disabled', false);
      return this.submit_button.show();
    };

    PeerGradingProblem.prototype.setup_score_selection = function(max_score) {
      return this.$("input[class='score-selection']").change(this.graded_callback);
    };

    PeerGradingProblem.prototype.gentle_alert = function(msg) {
      this.grading_message.fadeIn();
      return this.grading_message.html("<p>" + msg + "</p>");
    };

    PeerGradingProblem.prototype.collapse_question = function(event) {
      var new_text;
      this.prompt_container.slideToggle();
      this.prompt_container.toggleClass('open');
      if (this.question_header.text() === "Hide Prompt") {
        new_text = "Show Prompt";
        Logger.log('oe_hide_question', {
          location: this.location
        });
      } else {
        Logger.log('oe_show_question', {
          location: this.location
        });
        new_text = "Hide Prompt";
      }
      this.question_header.text(new_text);
      return false;
    };

    PeerGradingProblem.prototype.scroll_to_top = function() {
      return $('html, body').animate({
        scrollTop: $(".peer-grading").offset().top
      }, 200);
    };

    return PeerGradingProblem;

  })();

}).call(this);

(function (requirejs, require, define) {
define('PollMain', ['logme'], function (logme) {

PollMain.prototype = {

'showAnswerGraph': function (poll_answers, total) {
    var _this, totalValue;

    totalValue = parseFloat(total);
    if (isFinite(totalValue) === false) {
        return;
    }

    _this = this;

    $.each(poll_answers, function (index, value) {
        var numValue, percentValue;

        numValue = parseFloat(value);
        if (isFinite(numValue) === false) {
            return;
        }

        percentValue = (numValue / totalValue) * 100.0;

        _this.answersObj[index].statsEl.show();
        _this.answersObj[index].numberEl.html('' + value + ' (' + percentValue.toFixed(1) + '%)');
        _this.answersObj[index].percentEl.css({
            'width': '' + percentValue.toFixed(1) + '%'
        });
    });
},

'submitAnswer': function (answer, answerObj) {
    var _this;

    // Make sure that the user can answer a question only once.
    if (this.questionAnswered === true) {
        return;
    }
    this.questionAnswered = true;

    _this = this;

    console.log('submit answer');

    answerObj.buttonEl.addClass('answered');

    // Send the data to the server as an AJAX request. Attach a callback that will
    // be fired on server's response.
    $.postWithPrefix(
        _this.ajax_url + '/' + answer,  {},
        function (response) {
            console.log('success! response = ');
            console.log(response);

            _this.showAnswerGraph(response.poll_answers, response.total);

            if (_this.canReset === true) {
                _this.resetButton.show();
            }

            // Initialize Conditional constructors.
            if (_this.wrapperSectionEl !== null) {
                $(_this.wrapperSectionEl).find('.xmodule_ConditionalModule').each(function (index, value) {
                    new window.Conditional(value, _this.id.replace(/^poll_/, ''));
                });
            }
        }
    );

}, // End-of: 'submitAnswer': function (answer, answerEl) {


'submitReset': function () {
    var _this;

    _this = this;

    console.log('submit reset');

    // Send the data to the server as an AJAX request. Attach a callback that will
    // be fired on server's response.
    $.postWithPrefix(
        this.ajax_url + '/' + 'reset_poll',
        {},
        function (response) {
            console.log('success! response = ');
            console.log(response);

            if (
                (response.hasOwnProperty('status') !== true) ||
                (typeof response.status !== 'string') ||
                (response.status.toLowerCase() !== 'success')) {
                return;
            }

            _this.questionAnswered = false;
            _this.questionEl.find('.button.answered').removeClass('answered');
            _this.questionEl.find('.stats').hide();
            _this.resetButton.hide();

            // Initialize Conditional constructors. We will specify the third parameter as 'true'
            // notifying the constructor that this is a reset operation.
            if (_this.wrapperSectionEl !== null) {
                $(_this.wrapperSectionEl).find('.xmodule_ConditionalModule').each(function (index, value) {
                    new window.Conditional(value, _this.id.replace(/^poll_/, ''));
                });
            }
        }
    );
}, // End-of: 'submitAnswer': function (answer, answerEl) {

'postInit': function () {
    var _this;

    // Access this object inside inner functions.
    _this = this;

    if (
        (this.jsonConfig.poll_answer.length > 0) &&
        (this.jsonConfig.answers.hasOwnProperty(this.jsonConfig.poll_answer) === false)
    ) {
        this.questionEl.append(
            '<h3>Error!</h3>' +
            '<p>XML data format changed. List of answers was modified, but poll data was not updated.</p>'
        );

        return;
    }

    // Get the DOM id of the question.
    this.id = this.questionEl.attr('id');

    // Get the URL to which we will post the users answer to the question.
    this.ajax_url = this.questionEl.data('ajax-url');

    this.questionHtmlMarkup = $('<div />').html(this.jsonConfig.question).text();
    this.questionEl.append(this.questionHtmlMarkup);

    // When the user selects and answer, we will set this flag to true.
    this.questionAnswered = false;

    this.answersObj = {};
    this.shortVersion = true;

    $.each(this.jsonConfig.answers, function (index, value) {
        if (value.length >= 18) {
            _this.shortVersion = false;
        }
    });

    $.each(this.jsonConfig.answers, function (index, value) {
        var answer;

        answer = {};

        _this.answersObj[index] = answer;

        answer.el = $('<div class="poll_answer"></div>');

        answer.questionEl = $('<div class="question"></div>');
        answer.buttonEl = $('<div class="button"></div>');
        answer.textEl = $('<div class="text"></div>');
        answer.questionEl.append(answer.buttonEl);
        answer.questionEl.append(answer.textEl);

        answer.el.append(answer.questionEl);

        answer.statsEl = $('<div class="stats"></div>');
        answer.barEl = $('<div class="bar"></div>');
        answer.percentEl = $('<div class="percent"></div>');
        answer.barEl.append(answer.percentEl);
        answer.numberEl = $('<div class="number"></div>');
        answer.statsEl.append(answer.barEl);
        answer.statsEl.append(answer.numberEl);

        answer.statsEl.hide();

        answer.el.append(answer.statsEl);

        answer.textEl.html(value);

        if (_this.shortVersion === true) {
            $.each(answer, function (index, value) {
                if (value instanceof jQuery) {
                    value.addClass('short');
                }
            });
        }

        answer.el.appendTo(_this.questionEl);

        answer.textEl.on('click', function () {
            _this.submitAnswer(index, answer);
        });

        answer.buttonEl.on('click', function () {
            _this.submitAnswer(index, answer);
        });

        if (index === _this.jsonConfig.poll_answer) {
            answer.buttonEl.addClass('answered');
            _this.questionAnswered = true;
        }
    });

    console.log(this.jsonConfig.reset);

    if ((typeof this.jsonConfig.reset === 'string') && (this.jsonConfig.reset.toLowerCase() === 'true')) {
        this.canReset = true;

        this.resetButton = $('<div class="button reset-button">Change your vote</div>');

        if (this.questionAnswered === false) {
            this.resetButton.hide();
        }

        this.resetButton.appendTo(this.questionEl);

        this.resetButton.on('click', function () {
            _this.submitReset();
        });
    } else {
        this.canReset = false;
    }

    // If it turns out that the user already answered the question, show the answers graph.
    if (this.questionAnswered === true) {
        this.showAnswerGraph(this.jsonConfig.poll_answers, this.jsonConfig.total);
    }
} // End-of: 'postInit': function () {
}; // End-of: PollMain.prototype = {

return PollMain;

function PollMain(el) {
    var _this;

    this.questionEl = $(el).find('.poll_question');
    if (this.questionEl.length !== 1) {
        // We require one question DOM element.
        logme('ERROR: PollMain constructor requires one question DOM element.');

        return;
    }

    // Just a safety precussion. If we run this code more than once, multiple 'click' callback handlers will be
    // attached to the same DOM elements. We don't want this to happen.
    if (this.questionEl.attr('poll_main_processed') === 'true') {
        logme(
            'ERROR: PolMain JS constructor was called on a DOM element that has already been processed once.'
        );

        return;
    }

    // This element was not processed earlier.
    // Make sure that next time we will not process this element a second time.
    this.questionEl.attr('poll_main_processed', 'true');

    // Access this object inside inner functions.
    _this = this;

    // DOM element which contains the current poll along with any conditionals. By default we assume that such
    // element is not present. We will try to find it.
    this.wrapperSectionEl = null;

    (function (tempEl, c1) {
        while (tempEl.tagName.toLowerCase() !== 'body') {
            tempEl = $(tempEl).parent()[0];
            c1 += 1;

            if (
                (tempEl.tagName.toLowerCase() === 'section') &&
                ($(tempEl).hasClass('xmodule_WrapperModule') === true)
            ) {
                _this.wrapperSectionEl = tempEl;

                break;
            } else if (c1 > 50) {
                // In case something breaks, and we enter an endless loop, a sane
                // limit for loop iterations.

                break;
            }
        }
    }($(el)[0], 0));

    try {
        this.jsonConfig = JSON.parse(this.questionEl.children('.poll_question_div').html());

        $.postWithPrefix(
            '' + this.questionEl.data('ajax-url') + '/' + 'get_state',  {},
            function (response) {
                _this.jsonConfig.poll_answer = response.poll_answer;
                _this.jsonConfig.total = response.total;

                $.each(response.poll_answers, function (index, value) {
                    _this.jsonConfig.poll_answers[index] = value;
                });

                _this.questionEl.children('.poll_question_div').html(JSON.stringify(_this.jsonConfig));

                _this.postInit();
            }
        );

        return;
    } catch (err) {
        logme(
            'ERROR: Invalid JSON config for poll ID "' + this.id + '".',
            'Error messsage: "' + err.message + '".'
        );

        return;
    }
} // End-of: function PollMain(el) {

}); // End-of: define('PollMain', ['logme'], function (logme) {

// End-of: (function (requirejs, require, define) {
}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Generated by CoffeeScript 1.6.3
(function() {
  this.Conditional = (function() {
    function Conditional(element, callerElId) {
      var dependencies;
      this.el = $(element).find('.conditional-wrapper');
      this.callerElId = callerElId;
      if (callerElId !== void 0) {
        dependencies = this.el.data('depends');
        if ((typeof dependencies === 'string') && (dependencies.length > 0) && (dependencies.indexOf(callerElId) === -1)) {
          return;
        }
      }
      this.url = this.el.data('url');
      this.render(element);
    }

    Conditional.prototype.render = function(element) {
      var _this = this;
      return $.postWithPrefix("" + this.url + "/conditional_get", function(response) {
        var i, parentEl, parentId, _i, _len, _ref;
        _this.el.html('');
        _ref = response.html;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _this.el.append(i);
        }
        parentEl = $(element).parent();
        parentId = parentEl.attr('id');
        if (response.message === false) {
          if (parentId.indexOf('vert') === 0) {
            parentEl.hide();
          } else {
            $(element).hide();
          }
        } else {
          if (parentId.indexOf('vert') === 0) {
            parentEl.show();
          } else {
            $(element).show();
          }
        }
        return XModule.loadModules(_this.el);
      });
    };

    return Conditional;

  })();

}).call(this);

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('logme', [], function () {
    var debugMode;

    // debugMode can be one of the following:
    //
    //     true - All messages passed to logme will be written to the internal
    //            browser console.
    //     false - Suppress all output to the internal browser console.
    //
    // Obviously, if anywhere there is a direct console.log() call, we can't do
    // anything about it. That's why use logme() - it will allow to turn off
    // the output of debug information with a single change to a variable.
    debugMode = true;

    return logme;

    /*
     * function: logme
     *
     * A helper function that provides logging facilities. We don't want
     * to call console.log() directly, because sometimes it is not supported
     * by the browser. Also when everything is routed through this function.
     * the logging output can be easily turned off.
     *
     * logme() supports multiple parameters. Each parameter will be passed to
     * console.log() function separately.
     *
     */
    function logme() {
        var i;

        if (
            (typeof debugMode === 'undefined') ||
            (debugMode !== true) ||
            (typeof window.console === 'undefined')
        ) {
            return;
        }

        for (i = 0; i < arguments.length; i++) {
            window.console.log(arguments[i]);
        }
    } // End-of: function logme
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Generated by CoffeeScript 1.6.3
(function() {
  this.Collapsible = (function() {
    function Collapsible() {}

    Collapsible.setCollapsibles = function(el) {
      /*
      el: container
      */

      var short_custom;
      el.find('.longform').hide();
      el.find('.shortform').append('<a href="#" class="full">See full output</a>');
      short_custom = el.find('.shortform-custom');
      short_custom.each(function(index, elt) {
        var close_text, open_text;
        open_text = $(elt).data('open-text');
        close_text = $(elt).data('close-text');
        $(elt).append("<a href='#' class='full-custom'>" + open_text + "</a>");
        return $(elt).find('.full-custom').click(function(event) {
          return Collapsible.toggleFull(event, open_text, close_text);
        });
      });
      el.find('.collapsible header + section').hide();
      el.find('.full').click(function(event) {
        return Collapsible.toggleFull(event, "See full output", "Hide output");
      });
      return el.find('.collapsible header a').click(Collapsible.toggleHint);
    };

    Collapsible.toggleFull = function(event, open_text, close_text) {
      var new_text;
      event.preventDefault();
      $(event.target).parent().siblings().slideToggle();
      $(event.target).parent().parent().toggleClass('open');
      if ($(event.target).text() === open_text) {
        new_text = close_text;
      } else {
        new_text = open_text;
      }
      return $(event.target).text(new_text);
    };

    Collapsible.toggleHint = function(event) {
      event.preventDefault();
      $(event.target).parent().siblings().slideToggle();
      return $(event.target).parent().parent().toggleClass('open');
    };

    return Collapsible;

  }).call(this);

}).call(this);

/*
 * Word cloud layout by Jason Davies
 * https://github.com/jasondavies/d3-cloud
 * 
 *
 * Copyright (c) 2012, Jason Davies.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *   * The name Jason Davies may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
(function(exports) {
  function cloud() {
    var size = [256, 256],
        text = cloudText,
        font = cloudFont,
        fontSize = cloudFontSize,
        fontStyle = cloudFontNormal,
        fontWeight = cloudFontNormal,
        rotate = cloudRotate,
        padding = cloudPadding,
        spiral = archimedeanSpiral,
        words = [],
        timeInterval = Infinity,
        event = d3.dispatch("word", "end"),
        timer = null,
        cloud = {};

    cloud.start = function() {
      var board = zeroArray((size[0] >> 5) * size[1]),
          bounds = null,
          n = words.length,
          i = -1,
          tags = [],
          data = words.map(function(d, i) {
            d.text = text.call(this, d, i);
            d.font = font.call(this, d, i);
            d.style = fontStyle.call(this, d, i);
            d.weight = fontWeight.call(this, d, i);
            d.rotate = rotate.call(this, d, i);
            d.size = ~~fontSize.call(this, d, i);
            d.padding = cloudPadding.call(this, d, i);
            return d;
          }).sort(function(a, b) { return b.size - a.size; });

      if (timer) clearInterval(timer);
      timer = setInterval(step, 0);
      step();

      return cloud;

      function step() {
        var start = +new Date,
            d;
        while (+new Date - start < timeInterval && ++i < n && timer) {
          d = data[i];
          d.x = (size[0] * (Math.random() + .5)) >> 1;
          d.y = (size[1] * (Math.random() + .5)) >> 1;
          cloudSprite(d, data, i);
          if (place(board, d, bounds)) {
            tags.push(d);
            event.word(d);
            if (bounds) cloudBounds(bounds, d);
            else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];
            // Temporary hack
            d.x -= size[0] >> 1;
            d.y -= size[1] >> 1;
          }
        }
        if (i >= n) {
          cloud.stop();
          event.end(tags, bounds);
        }
      }
    }

    cloud.stop = function() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      return cloud;
    };

    cloud.timeInterval = function(x) {
      if (!arguments.length) return timeInterval;
      timeInterval = x == null ? Infinity : x;
      return cloud;
    };

    function place(board, tag, bounds) {
      var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
          startX = tag.x,
          startY = tag.y,
          maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
          s = spiral(size),
          dt = Math.random() < .5 ? 1 : -1,
          t = -dt,
          dxdy,
          dx,
          dy;

      while (dxdy = s(t += dt)) {
        dx = ~~dxdy[0];
        dy = ~~dxdy[1];

        if (Math.min(dx, dy) > maxDelta) break;

        tag.x = startX + dx;
        tag.y = startY + dy;

        if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
            tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
        // TODO only check for collisions within current bounds.
        if (!bounds || !cloudCollide(tag, board, size[0])) {
          if (!bounds || collideRects(tag, bounds)) {
            var sprite = tag.sprite,
                w = tag.width >> 5,
                sw = size[0] >> 5,
                lx = tag.x - (w << 4),
                sx = lx & 0x7f,
                msx = 32 - sx,
                h = tag.y1 - tag.y0,
                x = (tag.y + tag.y0) * sw + (lx >> 5),
                last;
            for (var j = 0; j < h; j++) {
              last = 0;
              for (var i = 0; i <= w; i++) {
                board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
              }
              x += sw;
            }
            delete tag.sprite;
            return true;
          }
        }
      }
      return false;
    }

    cloud.words = function(x) {
      if (!arguments.length) return words;
      words = x;
      return cloud;
    };

    cloud.size = function(x) {
      if (!arguments.length) return size;
      size = [+x[0], +x[1]];
      return cloud;
    };

    cloud.font = function(x) {
      if (!arguments.length) return font;
      font = d3.functor(x);
      return cloud;
    };

    cloud.fontStyle = function(x) {
      if (!arguments.length) return fontStyle;
      fontStyle = d3.functor(x);
      return cloud;
    };

    cloud.fontWeight = function(x) {
      if (!arguments.length) return fontWeight;
      fontWeight = d3.functor(x);
      return cloud;
    };

    cloud.rotate = function(x) {
      if (!arguments.length) return rotate;
      rotate = d3.functor(x);
      return cloud;
    };

    cloud.text = function(x) {
      if (!arguments.length) return text;
      text = d3.functor(x);
      return cloud;
    };

    cloud.spiral = function(x) {
      if (!arguments.length) return spiral;
      spiral = spirals[x + ""] || x;
      return cloud;
    };

    cloud.fontSize = function(x) {
      if (!arguments.length) return fontSize;
      fontSize = d3.functor(x);
      return cloud;
    };

    cloud.padding = function(x) {
      if (!arguments.length) return padding;
      padding = d3.functor(x);
      return cloud;
    };

    return d3.rebind(cloud, event, "on");
  }

  function cloudText(d) {
    return d.text;
  }

  function cloudFont() {
    return "serif";
  }

  function cloudFontNormal() {
    return "normal";
  }

  function cloudFontSize(d) {
    return Math.sqrt(d.value);
  }

  function cloudRotate() {
    return (~~(Math.random() * 6) - 3) * 30;
  }

  function cloudPadding() {
    return 1;
  }

  // Fetches a monochrome sprite bitmap for the specified text.
  // Load in batches for speed.
  function cloudSprite(d, data, di) {
    if (d.sprite) return;
    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
    var x = 0,
        y = 0,
        maxh = 0,
        n = data.length;
    di--;
    while (++di < n) {
      d = data[di];
      c.save();
      c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
      var w = c.measureText(d.text + "m").width * ratio,
          h = d.size << 1;
      if (d.rotate) {
        var sr = Math.sin(d.rotate * cloudRadians),
            cr = Math.cos(d.rotate * cloudRadians),
            wcr = w * cr,
            wsr = w * sr,
            hcr = h * cr,
            hsr = h * sr;
        w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
        h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
      } else {
        w = (w + 0x1f) >> 5 << 5;
      }
      if (h > maxh) maxh = h;
      if (x + w >= (cw << 5)) {
        x = 0;
        y += maxh;
        maxh = 0;
      }
      if (y + h >= ch) break;
      c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
      if (d.rotate) c.rotate(d.rotate * cloudRadians);
      c.fillText(d.text, 0, 0);
      c.restore();
      d.width = w;
      d.height = h;
      d.xoff = x;
      d.yoff = y;
      d.x1 = w >> 1;
      d.y1 = h >> 1;
      d.x0 = -d.x1;
      d.y0 = -d.y1;
      x += w;
    }
    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
        sprite = [];
    while (--di >= 0) {
      d = data[di];
      var w = d.width,
          w32 = w >> 5,
          h = d.y1 - d.y0,
          p = d.padding;
      // Zero the buffer
      for (var i = 0; i < h * w32; i++) sprite[i] = 0;
      x = d.xoff;
      if (x == null) return;
      y = d.yoff;
      var seen = 0,
          seenRow = -1;
      for (var j = 0; j < h; j++) {
        for (var i = 0; i < w; i++) {
          var k = w32 * j + (i >> 5),
              m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
          if (p) {
            if (j) sprite[k - w32] |= m;
            if (j < w - 1) sprite[k + w32] |= m;
            m |= (m << 1) | (m >> 1);
          }
          sprite[k] |= m;
          seen |= m;
        }
        if (seen) seenRow = j;
        else {
          d.y0++;
          h--;
          j--;
          y++;
        }
      }
      d.y1 = d.y0 + seenRow;
      d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
    }
  }

  // Use mask-based collision detection.
  function cloudCollide(tag, board, sw) {
    sw >>= 5;
    var sprite = tag.sprite,
        w = tag.width >> 5,
        lx = tag.x - (w << 4),
        sx = lx & 0x7f,
        msx = 32 - sx,
        h = tag.y1 - tag.y0,
        x = (tag.y + tag.y0) * sw + (lx >> 5),
        last;
    for (var j = 0; j < h; j++) {
      last = 0;
      for (var i = 0; i <= w; i++) {
        if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
            & board[x + i]) return true;
      }
      x += sw;
    }
    return false;
  }

  function cloudBounds(bounds, d) {
    var b0 = bounds[0],
        b1 = bounds[1];
    if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
    if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
    if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
    if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
  }

  function collideRects(a, b) {
    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
  }

  function archimedeanSpiral(size) {
    var e = size[0] / size[1];
    return function(t) {
      return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
    };
  }

  function rectangularSpiral(size) {
    var dy = 4,
        dx = dy * size[0] / size[1],
        x = 0,
        y = 0;
    return function(t) {
      var sign = t < 0 ? -1 : 1;
      // See triangular numbers: T_n = n * (n + 1) / 2.
      switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
        case 0:  x += dx; break;
        case 1:  y += dy; break;
        case 2:  x -= dx; break;
        default: y -= dy; break;
      }
      return [x, y];
    };
  }

  // TODO reuse arrays?
  function zeroArray(n) {
    var a = [],
        i = -1;
    while (++i < n) a[i] = 0;
    return a;
  }

  var cloudRadians = Math.PI / 180,
      cw = 1 << 11 >> 5,
      ch = 1 << 11,
      canvas,
      ratio = 1;

  if (typeof document !== "undefined") {
    canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
  } else {
    // node-canvas support
    var Canvas = require("canvas");
    canvas = new Canvas(cw << 5, ch);
  }

  var c = canvas.getContext("2d"),
      spirals = {
        archimedean: archimedeanSpiral,
        rectangular: rectangularSpiral
      };
  c.fillStyle = "red";
  c.textAlign = "center";

  exports.cloud = cloud;
})(typeof exports === "undefined" ? d3.layout || (d3.layout = {}) : exports);

(function (requirejs, require, define) {

// VideoPlayer module.
define(
'video/03_video_player.js',
['video/02_html5_video.js'],
function (HTML5Video) {

    // VideoPlayer() function - what this module "exports".
    return function (state) {
        state.videoPlayer = {};

        _makeFunctionsPublic(state);
        _initialize(state);
        // No callbacks to DOM events (click, mousemove, etc.).
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called,
    //     these functions will get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoPlayer.pause         = _.bind(pause, state);
        state.videoPlayer.play          = _.bind(play, state);
        state.videoPlayer.update        = _.bind(update, state);
        state.videoPlayer.onSpeedChange = _.bind(onSpeedChange, state);
        state.videoPlayer.onCaptionSeek = _.bind(onSeek, state);
        state.videoPlayer.onSlideSeek   = _.bind(onSeek, state);
        state.videoPlayer.onEnded       = _.bind(onEnded, state);
        state.videoPlayer.onPause       = _.bind(onPause, state);
        state.videoPlayer.onPlay        = _.bind(onPlay, state);

        state.videoPlayer.onUnstarted = _.bind(
            onUnstarted, state
        );

        state.videoPlayer.handlePlaybackQualityChange = _.bind(
            handlePlaybackQualityChange, state
        );

        state.videoPlayer.onPlaybackQualityChange = _.bind(
            onPlaybackQualityChange, state
        );

        state.videoPlayer.onStateChange  = _.bind(onStateChange, state);
        state.videoPlayer.onReady        = _.bind(onReady, state);
        state.videoPlayer.updatePlayTime = _.bind(updatePlayTime, state);
        state.videoPlayer.isPlaying      = _.bind(isPlaying, state);
        state.videoPlayer.log            = _.bind(log, state);
        state.videoPlayer.duration       = _.bind(duration, state);
        state.videoPlayer.onVolumeChange = _.bind(onVolumeChange, state);
    }

    // function _initialize(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _initialize(state) {
        var youTubeId;

        if (state.videoType === 'youtube') {
            state.videoPlayer.PlayerState = YT.PlayerState;
            state.videoPlayer.PlayerState.UNSTARTED = -1;
        } else { // if (state.videoType === 'html5') {
            state.videoPlayer.PlayerState = HTML5Video.PlayerState;
        }

        state.videoPlayer.currentTime = 0;

        state.videoPlayer.playerVars = {
            controls: 0,
            wmode: 'transparent',
            rel: 0,
            showinfo: 0,
            enablejsapi: 1,
            modestbranding: 1
        };

        if (state.currentPlayerMode !== 'flash') {
            state.videoPlayer.playerVars.html5 = 1;
        }

        if (state.config.start) {
            state.videoPlayer.playerVars.start = state.config.start;
            state.videoPlayer.playerVars.wmode = 'window';
        }
        if (state.config.end) {
          state.videoPlayer.playerVars.end = state.config.end;
        }

        // There is a bug which prevents YouTube API to correctly set the speed
        // to 1.0 from another speed in Firefox when in HTML5 mode. There is a
        // fix which basically reloads the video at speed 1.0 when this change
        // is requested (instead of simply requesting a speed change to 1.0).
        // This has to be done only when the video is being watched in Firefox.
        // We need to figure out what browser is currently executing this code.
        //
        // TODO: Check the status of
        // http://code.google.com/p/gdata-issues/issues/detail?id=4654
        // When the YouTube team fixes the API bug, we can remove this
        // temporary bug fix.
        state.browserIsFirefox = navigator.userAgent
            .toLowerCase().indexOf('firefox') > -1;

        if (state.videoType === 'html5') {
            state.videoPlayer.player = new HTML5Video.Player(state.el, {
                playerVars:   state.videoPlayer.playerVars,
                videoSources: state.html5Sources,
                events: {
                    onReady:       state.videoPlayer.onReady,
                    onStateChange: state.videoPlayer.onStateChange
                }
            });
        } else { // if (state.videoType === 'youtube') {
            if (state.currentPlayerMode === 'flash') {
                youTubeId = state.youtubeId();
            } else {
                youTubeId = state.youtubeId('1.0');
            }
            state.videoPlayer.player = new YT.Player(state.id, {
                playerVars: state.videoPlayer.playerVars,
                videoId: youTubeId,
                events: {
                    onReady: state.videoPlayer.onReady,
                    onStateChange: state.videoPlayer.onStateChange,
                    onPlaybackQualityChange: state.videoPlayer
                        .onPlaybackQualityChange
                }
            });
        }
    }

    // function _restartUsingFlash(state)
    //
    //     When we are about to play a YouTube video in HTML5 mode and discover
    //     that we only have one available playback rate, we will switch to
    //     Flash mode. In Flash speed switching is done by reloading videos
    //     recorded at different frame rates.
    function _restartUsingFlash(state) {
        // Remove from the page current iFrame with HTML5 video.
        state.videoPlayer.player.destroy();

        // Remember for future page loads that we should use Flash mode.
        $.cookie('current_player_mode', 'flash', {
            'expires': 3650,
            'path': '/'
        });
        state.currentPlayerMode = 'flash';

        console.log('[Video info]: Changing YouTube player mode to "flash".');

        // Removed configuration option that requests the HTML5 mode.
        delete state.videoPlayer.playerVars.html5;

        // Request for the creation of a new Flash player
        state.videoPlayer.player = new YT.Player(state.id, {
            playerVars: state.videoPlayer.playerVars,
            videoId: state.youtubeId(),
            events: {
                onReady: state.videoPlayer.onReady,
                onStateChange: state.videoPlayer.onStateChange,
                onPlaybackQualityChange: state.videoPlayer
                    .onPlaybackQualityChange
            }
        });
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function pause() {
        if (this.videoPlayer.player.pauseVideo) {
            this.videoPlayer.player.pauseVideo();
        }
    }

    function play() {
        if (this.videoPlayer.player.playVideo) {
            this.videoPlayer.player.playVideo();
        }
    }

    // This function gets the video's current play position in time
    // (currentTime) and its duration.
    // It is called at a regular interval when the video is playing (see
    // below).
    function update() {
        this.videoPlayer.currentTime = this.videoPlayer.player
            .getCurrentTime();

        if (isFinite(this.videoPlayer.currentTime)) {
            this.videoPlayer.updatePlayTime(this.videoPlayer.currentTime);
        }
    }

    function onSpeedChange(newSpeed, updateCookie) {
        if (this.currentPlayerMode === 'flash') {
            this.videoPlayer.currentTime = Time.convert(
                this.videoPlayer.currentTime,
                parseFloat(this.speed),
                newSpeed
            );
        }
        newSpeed = parseFloat(newSpeed).toFixed(2).replace(/\.00$/, '.0');

        this.videoPlayer.log(
            'speed_change_video',
            {
                current_time: this.videoPlayer.currentTime,
                old_speed: this.speed,
                new_speed: newSpeed
            }
        );

        this.setSpeed(newSpeed, updateCookie);

        if (
            this.currentPlayerMode === 'html5' &&
            !(
                this.browserIsFirefox &&
                newSpeed === '1.0' &&
                this.videoType === 'youtube'
            )
        ) {
            this.videoPlayer.player.setPlaybackRate(newSpeed);
        } else {
            // We request the reloading of the video in the case when YouTube
            // is in Flash player mode, or when we are in Firefox, and the new
            // speed is 1.0. The second case is necessary to avoid the bug
            // where in Firefox speed switching to 1.0 in HTML5 player mode is
            // handled incorrectly by YouTube API.
            if (this.videoPlayer.isPlaying()) {
                this.videoPlayer.player.loadVideoById(
                    this.youtubeId(), this.videoPlayer.currentTime
                );
            } else {
                this.videoPlayer.player.cueVideoById(
                    this.youtubeId(), this.videoPlayer.currentTime
                );
            }

            this.videoPlayer.updatePlayTime(this.videoPlayer.currentTime);
        }
    }

    // Every 200 ms, if the video is playing, we call the function update, via
    // clearInterval. This interval is called updateInterval.
    // It is created on a onPlay event. Cleared on a onPause event.
    // Reinitialized on a onSeek event.
    function onSeek(params) {
        this.videoPlayer.log(
            'seek_video',
            {
                old_time: this.videoPlayer.currentTime,
                new_time: params.time,
                type: params.type
            }
        );

        this.videoPlayer.player.seekTo(params.time, true);

        if (this.videoPlayer.isPlaying()) {
            clearInterval(this.videoPlayer.updateInterval);
            this.videoPlayer.updateInterval = setInterval(
                this.videoPlayer.update, 200
            );
        } else {
            this.videoPlayer.currentTime = params.time;
        }

        this.videoPlayer.updatePlayTime(params.time);
    }

    function onEnded() {
        this.trigger('videoControl.pause', null);

        if (this.config.show_captions) {
            this.trigger('videoCaption.pause', null);
        }
    }

    function onPause() {
        this.videoPlayer.log(
            'pause_video',
            {
                'currentTime': this.videoPlayer.currentTime
            }
        );

        clearInterval(this.videoPlayer.updateInterval);
        delete this.videoPlayer.updateInterval;

        this.trigger('videoControl.pause', null);

        if (this.config.show_captions) {
            this.trigger('videoCaption.pause', null);
        }
    }

    function onPlay() {
        this.videoPlayer.log(
            'play_video',
            {
                'currentTime': this.videoPlayer.currentTime
            }
        );

        if (!this.videoPlayer.updateInterval) {
            this.videoPlayer.updateInterval = setInterval(
                this.videoPlayer.update, 200
            );
        }

        this.trigger('videoControl.play', null);

        if (this.config.show_captions) {
            this.trigger('videoCaption.play', null);
        }
    }

    function onUnstarted() { }

    function handlePlaybackQualityChange(value) {
        this.videoPlayer.player.setPlaybackQuality(value);
    }

    function onPlaybackQualityChange() {
        var quality;

        quality = this.videoPlayer.player.getPlaybackQuality();

        this.trigger('videoQualityControl.onQualityChange', quality);
    }

    function onReady() {
        var availablePlaybackRates, baseSpeedSubs, _this;

        this.videoPlayer.log('load_video');

        availablePlaybackRates = this.videoPlayer.player
                                    .getAvailablePlaybackRates();

        // Because of problems with muting sound outside of range 0.25 and
        // 5.0, we should filter our available playback rates.
        // Issues:
        //   https://code.google.com/p/chromium/issues/detail?id=264341
        //   https://bugzilla.mozilla.org/show_bug.cgi?id=840745
        //   https://developer.mozilla.org/en-US/docs/DOM/HTMLMediaElement

        availablePlaybackRates = _.filter(
            availablePlaybackRates,
            function (item) {
                var speed = Number(item);
                return speed > 0.25 && speed <= 5;
            }
        );

        if (
            this.currentPlayerMode === 'html5' &&
            this.videoType === 'youtube'
        ) {
            if (availablePlaybackRates.length === 1) {
                // This condition is needed in cases when Firefox version is
                // less than 20. In those versions HTML5 playback could only
                // happen at 1 speed (no speed changing). Therefore, in this
                // case, we need to switch back to Flash.
                //
                // This might also happen in other browsers, therefore when we
                // have 1 speed available, we fall back to Flash.

                _restartUsingFlash(this);

                return;
            } else if (availablePlaybackRates.length > 1) {
                // We need to synchronize available frame rates with the ones
                // that the user specified.

                baseSpeedSubs = this.videos['1.0'];
                _this = this;
                // this.videos is a dictionary containing various frame rates
                // and their associated subs.

                // First clear the dictionary.
                $.each(this.videos, function (index, value) {
                    delete _this.videos[index];
                });
                this.speeds = [];
                // Recreate it with the supplied frame rates.
                $.each(availablePlaybackRates, function (index, value) {
                    var key = value.toFixed(2).replace(/\.00$/, '.0');

                    _this.videos[key] = baseSpeedSubs;

                    _this.speeds.push(key);
                });

                this.trigger(
                    'videoSpeedControl.reRender',
                    {
                        newSpeeds: this.speeds,
                        currentSpeed: this.speed
                    }
                );

                this.setSpeed($.cookie('video_speed'));
            }
        }

        if (this.currentPlayerMode === 'html5') {
            this.videoPlayer.player.setPlaybackRate(this.speed);
        }

        if (
            !onTouchBasedDevice() &&
            $('.video:first').data('autoplay') === 'True'
        ) {
            this.videoPlayer.play();
        }
    }

    function onStateChange(event) {
        switch (event.data) {
            case this.videoPlayer.PlayerState.UNSTARTED:
                this.videoPlayer.onUnstarted();
                break;
            case this.videoPlayer.PlayerState.PLAYING:
                this.videoPlayer.onPlay();
                break;
            case this.videoPlayer.PlayerState.PAUSED:
                this.videoPlayer.onPause();
                break;
            case this.videoPlayer.PlayerState.ENDED:
                this.videoPlayer.onEnded();
                break;
        }
    }

    function updatePlayTime(time) {
        var duration;

        duration = this.videoPlayer.duration();

        this.trigger(
            'videoProgressSlider.updatePlayTime',
            {
                time: time,
                duration: duration
            }
        );

        this.trigger(
            'videoControl.updateVcrVidTime',
            {
                time: time,
                duration: duration
            }
        );

        this.trigger('videoCaption.updatePlayTime', time);
    }

    function isPlaying() {
        var playerState = this.videoPlayer.player.getPlayerState(),
            PLAYING = this.videoPlayer.PlayerState.PLAYING;

        return playerState === PLAYING;
    }

    function duration() {
        var dur;

        dur = this.videoPlayer.player.getDuration();

        if (!isFinite(dur)) {
            dur = this.getDuration();
        }

        return dur;
    }

    function log(eventName, data) {
        var logInfo;

        // Default parameters that always get logged.
        logInfo = {
            'id':   this.id,
            'code': this.youtubeId()
        };

        // If extra parameters were passed to the log.
        if (data) {
            $.each(data, function (paramName, value) {
                logInfo[paramName] = value;
            });
        }

        if (this.videoType === 'youtube') {
            logInfo.code = this.youtubeId();
        } else  if (this.videoType === 'html5') {
                logInfo.code = 'html5';
        }

        Logger.log(eventName, logInfo);
    }

    function onVolumeChange(volume) {
        this.videoPlayer.player.setVolume(volume);
    }
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.InlineDiscussion = (function(_super) {
    __extends(InlineDiscussion, _super);

    function InlineDiscussion(element) {
      this.el = $(element).find('.discussion-module');
      this.view = new DiscussionModuleView({
        el: this.el
      });
    }

    return InlineDiscussion;

  })(XModule.Descriptor);

}).call(this);

(function (requirejs, require, define) {

// VideoControl module.
define(
'video/04_video_control.js',
[],
function () {

    // VideoControl() function - what this module "exports".
    return function (state) {
        state.videoControl = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoControl.showControls     = _.bind(showControls,state);
        state.videoControl.hideControls     = _.bind(hideControls,state);
        state.videoControl.play             = _.bind(play,state);
        state.videoControl.pause            = _.bind(pause,state);
        state.videoControl.togglePlayback   = _.bind(togglePlayback,state);
        state.videoControl.toggleFullScreen = _.bind(toggleFullScreen,state);
        state.videoControl.exitFullScreen   = _.bind(exitFullScreen,state);
        state.videoControl.updateVcrVidTime = _.bind(updateVcrVidTime,state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their initial configuration. Also
    //     make the created DOM elements available via the 'state' object. Much easier to work this
    //     way - you don't have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoControl.el = state.el.find('.video-controls');
        // state.videoControl.el.append(el);

        state.videoControl.sliderEl            = state.videoControl.el.find('.slider');
        state.videoControl.playPauseEl         = state.videoControl.el.find('.video_control');
        state.videoControl.secondaryControlsEl = state.videoControl.el.find('.secondary-controls');
        state.videoControl.fullScreenEl        = state.videoControl.el.find('.add-fullscreen');
        state.videoControl.vidTimeEl           = state.videoControl.el.find('.vidtime');

        state.videoControl.fullScreenState = false;

        if (!onTouchBasedDevice()) {
            state.videoControl.pause();
        } else {
            state.videoControl.play();
        }

        if (state.videoType === 'html5') {
            state.videoControl.fadeOutTimeout = state.config.fadeOutTimeout;

            state.videoControl.el.addClass('html5');
            state.controlHideTimeout = setTimeout(state.videoControl.hideControls, state.videoControl.fadeOutTimeout);
        }
    }

    // function _bindHandlers(state)
    //
    //     Bind any necessary function callbacks to DOM events (click, mousemove, etc.).
    function _bindHandlers(state) {
        state.videoControl.playPauseEl.on('click', state.videoControl.togglePlayback);
        state.videoControl.fullScreenEl.on('click', state.videoControl.toggleFullScreen);
        $(document).on('keyup', state.videoControl.exitFullScreen);

        if (state.videoType === 'html5') {
            state.el.on('mousemove', state.videoControl.showControls);
            state.el.on('keydown', state.videoControl.showControls);
        }
        // The state.previousFocus is used in video_speed_control to track 
        // the element that had the focus before it.
        state.videoControl.playPauseEl.on('blur', function () {
            state.previousFocus = 'playPause';
        });
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************
    function showControls(event) {
        if (!this.controlShowLock) {
            if (!this.captionsHidden) {
                return;
            }

            this.controlShowLock = true;

            if (this.controlState === 'invisible') {
                this.videoControl.el.show();
                this.controlState = 'visible';
            } else if (this.controlState === 'hiding') {
                this.videoControl.el.stop(true, false).css('opacity', 1).show();
                this.controlState = 'visible';
            } else if (this.controlState === 'visible') {
                clearTimeout(this.controlHideTimeout);
            }

            this.controlHideTimeout = setTimeout(this.videoControl.hideControls, this.videoControl.fadeOutTimeout);

            this.controlShowLock = false;
        }
    }

    function hideControls() {
        var _this;

        this.controlHideTimeout = null;

        if (!this.captionsHidden) {
            return;
        }

        this.controlState = 'hiding';

        _this = this;

        this.videoControl.el.fadeOut(this.videoControl.fadeOutTimeout, function () {
            _this.controlState = 'invisible';
        });
    }

    function play() {
        this.videoControl.playPauseEl.removeClass('play').addClass('pause').attr('title', gettext('Pause'));
        this.videoControl.isPlaying = true;
    }

    function pause() {
        this.videoControl.playPauseEl.removeClass('pause').addClass('play').attr('title', gettext('Play'));
        this.videoControl.isPlaying = false;
    }

    function togglePlayback(event) {
        event.preventDefault();

        if (this.videoControl.isPlaying) {
            this.trigger('videoPlayer.pause', null);
        } else {
            this.trigger('videoPlayer.play', null);
        }
    }

    function toggleFullScreen(event) {
        event.preventDefault();
        var fullScreenClassNameEl = this.el.add(document.documentElement);

        if (this.videoControl.fullScreenState) {
            this.videoControl.fullScreenState = false;
            fullScreenClassNameEl.removeClass('video-fullscreen');
            this.isFullScreen = false;
            this.videoControl.fullScreenEl.attr('title', gettext('Fullscreen'));
        } else {
            this.videoControl.fullScreenState = true;
            fullScreenClassNameEl.addClass('video-fullscreen');
            this.isFullScreen = true;
            this.videoControl.fullScreenEl.attr('title', gettext('Exit fullscreen'));
        }

        this.trigger('videoCaption.resize', null);
    }

    function exitFullScreen(event) {
        if ((this.isFullScreen) && (event.keyCode === 27)) {
            this.videoControl.toggleFullScreen(event);
        }
    }

    function updateVcrVidTime(params) {
        this.videoControl.vidTimeEl.html(Time.format(params.time) + ' / ' + Time.format(params.duration));
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Generated by CoffeeScript 1.6.3
(function() {
  this.JavascriptLoader = (function() {
    function JavascriptLoader() {}

    JavascriptLoader.executeModuleScripts = function(el, callback) {
      var callbackCalled, completed, completionHandlerGenerator, completionHandlerGeneratorIE, i, loaded, placeholders,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      placeholders = el.find(".script_placeholder");
      if (placeholders.length === 0) {
        if (callback != null) {
          callback();
        }
        return;
      }
      completed = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = placeholders.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(false);
        }
        return _results;
      })();
      callbackCalled = false;
      completionHandlerGeneratorIE = function(index) {
        return function() {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            return completionHandlerGenerator(index)();
          }
        };
      };
      completionHandlerGenerator = function(index) {
        return function() {
          var allComplete, flag, _i, _len;
          allComplete = true;
          completed[index] = true;
          for (_i = 0, _len = completed.length; _i < _len; _i++) {
            flag = completed[_i];
            if (!flag) {
              allComplete = false;
              break;
            }
          }
          if (allComplete && !callbackCalled) {
            callbackCalled = true;
            if (callback != null) {
              return callback();
            }
          }
        };
      };
      loaded = {};
      return placeholders.each(function(index, placeholder) {
        var s, src;
        src = $(placeholder).attr("data-src");
        if (!(src in loaded)) {
          loaded[src] = true;
          s = document.createElement('script');
          s.setAttribute('src', src);
          s.setAttribute('type', "text/javascript");
          s.onload = completionHandlerGenerator(index);
          s.onreadystatechange = completionHandlerGeneratorIE(index);
          $('head')[0].appendChild(s);
        } else {
          completionHandlerGenerator(index)();
        }
        return $(placeholder).remove();
      });
    };

    return JavascriptLoader;

  })();

}).call(this);

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('GeneralMethods', [], function () {
    if (!String.prototype.trim) {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        String.prototype.trim = function trim(str) {
            return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        };
    }

    return {
        'module_name': 'GeneralMethods',
        'module_status': 'OK'
    };
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

// Generated by CoffeeScript 1.6.3
(function() {
  this.HTMLModule = (function() {
    function HTMLModule(element) {
      this.element = element;
      this.el = $(this.element);
      JavascriptLoader.executeModuleScripts(this.el);
      Collapsible.setCollapsibles(this.el);
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, this.el[0]]);
    }

    HTMLModule.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    return HTMLModule;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  this.Collapsible = (function() {
    function Collapsible() {}

    Collapsible.setCollapsibles = function(el) {
      /*
      el: container
      */

      var short_custom;
      el.find('.longform').hide();
      el.find('.shortform').append('<a href="#" class="full">See full output</a>');
      short_custom = el.find('.shortform-custom');
      short_custom.each(function(index, elt) {
        var close_text, open_text;
        open_text = $(elt).data('open-text');
        close_text = $(elt).data('close-text');
        $(elt).append("<a href='#' class='full-custom'>" + open_text + "</a>");
        return $(elt).find('.full-custom').click(function(event) {
          return Collapsible.toggleFull(event, open_text, close_text);
        });
      });
      el.find('.collapsible header + section').hide();
      el.find('.full').click(function(event) {
        return Collapsible.toggleFull(event, "See full output", "Hide output");
      });
      return el.find('.collapsible header a').click(Collapsible.toggleHint);
    };

    Collapsible.toggleFull = function(event, open_text, close_text) {
      var new_text;
      event.preventDefault();
      $(event.target).parent().siblings().slideToggle();
      $(event.target).parent().parent().toggleClass('open');
      if ($(event.target).text() === open_text) {
        new_text = close_text;
      } else {
        new_text = open_text;
      }
      return $(event.target).text(new_text);
    };

    Collapsible.toggleHint = function(event) {
      event.preventDefault();
      $(event.target).parent().siblings().slideToggle();
      return $(event.target).parent().parent().toggleClass('open');
    };

    return Collapsible;

  }).call(this);

}).call(this);

window.WordCloud = function (el) {
    RequireJS.require(['WordCloudMain'], function (WordCloudMain) {
        new WordCloudMain(el);
    });
};

// Generated by CoffeeScript 1.6.3
(function() {
  this.JavascriptLoader = (function() {
    function JavascriptLoader() {}

    JavascriptLoader.executeModuleScripts = function(el, callback) {
      var callbackCalled, completed, completionHandlerGenerator, completionHandlerGeneratorIE, i, loaded, placeholders,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      placeholders = el.find(".script_placeholder");
      if (placeholders.length === 0) {
        if (callback != null) {
          callback();
        }
        return;
      }
      completed = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = placeholders.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(false);
        }
        return _results;
      })();
      callbackCalled = false;
      completionHandlerGeneratorIE = function(index) {
        return function() {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            return completionHandlerGenerator(index)();
          }
        };
      };
      completionHandlerGenerator = function(index) {
        return function() {
          var allComplete, flag, _i, _len;
          allComplete = true;
          completed[index] = true;
          for (_i = 0, _len = completed.length; _i < _len; _i++) {
            flag = completed[_i];
            if (!flag) {
              allComplete = false;
              break;
            }
          }
          if (allComplete && !callbackCalled) {
            callbackCalled = true;
            if (callback != null) {
              return callback();
            }
          }
        };
      };
      loaded = {};
      return placeholders.each(function(index, placeholder) {
        var s, src;
        src = $(placeholder).attr("data-src");
        if (!(src in loaded)) {
          loaded[src] = true;
          s = document.createElement('script');
          s.setAttribute('src', src);
          s.setAttribute('type', "text/javascript");
          s.onload = completionHandlerGenerator(index);
          s.onreadystatechange = completionHandlerGeneratorIE(index);
          $('head')[0].appendChild(s);
        } else {
          completionHandlerGenerator(index)();
        }
        return $(placeholder).remove();
      });
    };

    return JavascriptLoader;

  })();

}).call(this);

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('Sliders', ['logme'], function (logme) {
    return Sliders;

    function Sliders(gstId, state) {
        var c1, paramName, allParamNames, sliderDiv;

        allParamNames = state.getAllParameterNames();

        for (c1 = 0; c1 < allParamNames.length; c1 += 1) {
            paramName = allParamNames[c1];

            sliderDiv = $('#' + gstId + '_slider_' + paramName);

            if (sliderDiv.length === 1) {
                createSlider(sliderDiv, paramName);
            } else if (sliderDiv.length > 1) {
                logme('ERROR: Found more than one slider for the parameter "' + paramName + '".');
                logme('sliderDiv.length = ', sliderDiv.length);
            } // else {
            //     logme('MESSAGE: Did not find a slider for the parameter "' + paramName + '".');
            // }
        }

        function createSlider(sliderDiv, paramName) {
            var paramObj;

            paramObj = state.getParamObj(paramName);

            // Check that the retrieval went OK.
            if (paramObj === undefined) {
                logme('ERROR: Could not get a paramObj for parameter "' + paramName + '".');

                return;
            }

            // Create a jQuery UI slider from the slider DIV. We will set
            // starting parameters, and will also attach a handler to update
            // the 'state' on the 'slide' event.
            sliderDiv.slider({
                'min': paramObj.min,
                'max': paramObj.max,
                'value': paramObj.value,
                'step': paramObj.step
            });

            // Tell the parameter object stored in state that we have a slider
            // that is attached to it. Next time when the parameter changes, it
            // will also update the value of this slider.
            paramObj.sliderDiv = sliderDiv;

            // Atach callbacks to update the slider's parameter.
            paramObj.sliderDiv.on('slide', sliderOnSlide);
            paramObj.sliderDiv.on('slidechange', sliderOnChange);

            return;

            // Update the 'state' - i.e. set the value of the parameter this
            // slider is attached to to a new value.
            //
            // This will cause the plot to be redrawn each time after the user
            // drags the slider handle and releases it.
            function sliderOnSlide(event, ui) {
                // Last parameter passed to setParameterValue() will be 'true'
                // so that the function knows we are a slider, and it can
                // change the our value back in the case when the new value is
                // invalid for some reason.
                if (state.setParameterValue(paramName, ui.value, sliderDiv, true, 'slide') === undefined) {
                    logme('ERROR: Could not update the parameter named "' + paramName + '" with the value "' + ui.value + '".');
                }
            }

            function sliderOnChange(event, ui) {
                if (state.setParameterValue(paramName, ui.value, sliderDiv, true, 'change') === undefined) {
                    logme('ERROR: Could not update the parameter named "' + paramName + '" with the value "' + ui.value + '".');
                }
            }
        }
    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

(function (requirejs, require, define) {

// VideoQualityControl module.
define(
'video/05_video_quality_control.js',
[],
function () {

    // VideoQualityControl() function - what this module "exports".
    return function (state) {
        // Changing quality for now only works for YouTube videos.
        if (state.videoType !== 'youtube') {
            return;
        }

        state.videoQualityControl = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoQualityControl.onQualityChange = _.bind(onQualityChange, state);
        state.videoQualityControl.toggleQuality   = _.bind(toggleQuality, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their initial configuration. Also
    //     make the created DOM elements available via the 'state' object. Much easier to work this
    //     way - you don't have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoQualityControl.el = state.el.find('a.quality_control');

        state.videoQualityControl.el.show();
        state.videoQualityControl.quality = null;
    }

    // function _bindHandlers(state)
    //
    //     Bind any necessary function callbacks to DOM events (click, mousemove, etc.).
    function _bindHandlers(state) {
        state.videoQualityControl.el.on('click', state.videoQualityControl.toggleQuality);
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function onQualityChange(value) {
        this.videoQualityControl.quality = value;

        if (_.indexOf(this.config.availableQualities, value) !== -1) {
            this.videoQualityControl.el.addClass('active');
        } else {
            this.videoQualityControl.el.removeClass('active');
        }
    }

    // This function change quality of video.
    // Right now we haven't ability to choose quality of HD video,
    // 'hd720' will be played by default as HD video(this thing is hardcoded).
    // If suggested quality level is not available for the video,
    // then the quality will be set to the next lowest level that is available.
    // (large -> medium)
    function toggleQuality(event) {
        var newQuality,
            value = this.videoQualityControl.quality;

        event.preventDefault();

        if (_.indexOf(this.config.availableQualities, value) !== -1) {
            newQuality = 'large';
        } else {
            newQuality = 'hd720';
        }

        this.trigger('videoPlayer.handlePlaybackQualityChange', newQuality);
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

/**
 * @file The main module definition for Word Cloud XModule.
 *
 *  Defines a constructor function which operates on a DOM element. Either show the user text inputs so
 *  he can enter words, or render his selected words along with the word cloud representing the top words.
 *
 *  @module WordCloudMain
 *
 *  @exports WordCloudMain
 *
 *  @requires logme
 *
 *  @external d3, $, RequireJS
 */

(function (requirejs, require, define) {
define('WordCloudMain', ['logme'], function (logme) {

    /**
     * @function WordCloudMain
     *
     * This function will process all the attributes from the DOM element passed, taking all of
     * the configuration attributes. It will either then attach a callback handler for the click
     * event on the button in the case when the user needs to enter words, or it will call the
     * appropriate mehtod to generate and render a word cloud from user's enetered words along with
     * all of the other words.
     *
     * @constructor
     *
     * @param {jQuery} el DOM element where the word cloud will be processed and created.
     */
    var WordCloudMain = function (el) {
        var _this = this;

        this.wordCloudEl = $(el).find('.word_cloud');

        // Get the URL to which we will post the users words.
        this.ajax_url = this.wordCloudEl.data('ajax-url');

        // Dimensions of the box where the word cloud will be drawn.
        this.width = 635;
        this.height = 635;

        // Hide WordCloud container before Ajax request done
        this.wordCloudEl.hide();

        // Retriveing response from the server as an AJAX request. Attach a callback that will
        // be fired on server's response.
        $.postWithPrefix(
            _this.ajax_url + '/' + 'get_state', null,
            function (response) {
                if (response.status !== 'success') {
                    logme('ERROR: ' + response.error);

                    return;
                }

                _this.configJson = response;
            }
        )
        .done(function () {
            // Show WordCloud container after Ajax request done
            _this.wordCloudEl.show();

            if (_this.configJson && _this.configJson.submitted) {
                _this.showWordCloud(_this.configJson);

                return;
            }
        });

        $(el).find('input.save').on('click', function () {
            _this.submitAnswer();
        });
    }; // End-of: var WordCloudMain = function (el) {

    /**
     * @function submitAnswer
     *
     * Callback to be executed when the user eneter his words. It will send user entries to the
     * server, and upon receiving correct response, will call the function to generate the
     * word cloud.
     */
    WordCloudMain.prototype.submitAnswer = function () {
        var _this = this,
            data = {'student_words': []};

        // Populate the data to be sent to the server with user's words.
        this.wordCloudEl.find('input.input-cloud').each(function (index, value) {
            data.student_words.push($(value).val());
        });

        // Send the data to the server as an AJAX request. Attach a callback that will
        // be fired on server's response.
        $.postWithPrefix(
            _this.ajax_url + '/' + 'submit', $.param(data),
            function (response) {
                if (response.status !== 'success') {
                    logme('ERROR: ' + response.error);

                    return;
                }

                _this.showWordCloud(response);
            }
        );

    }; // End-of: WordCloudMain.prototype.submitAnswer = function () {

    /**
     * @function showWordCloud
     *
     * @param {object} response The response from the server that contains the user's entered words
     * along with all of the top words.
     *
     * This function will set up everything for d3 and launch the draw method. Among other things,
     * iw will determine maximum word size.
     */
    WordCloudMain.prototype.showWordCloud = function (response) {
        var words,
            _this = this,
            maxSize, minSize, scaleFactor, maxFontSize, minFontSize;

        this.wordCloudEl.find('.input_cloud_section').hide();

        words = response.top_words;
        maxSize = 0;
        minSize = 10000;
        scaleFactor = 1;
        maxFontSize = 200;
        minFontSize = 15;

        // Find the word with the maximum percentage. I.e. the most popular word.
        $.each(words, function (index, word) {
            if (word.size > maxSize) {
                maxSize = word.size;
            }
            if (word.size < minSize) {
                minSize = word.size;
            }
        });

        // Find the longest word, and calculate the scale appropriately. This is
        // required so that even long words fit into the drawing area.
        //
        // This is a fix for: if the word is very long and/or big, it is discarded by
        // for unknown reason.
        $.each(words, function (index, word) {
            var tempScaleFactor = 1.0,
                size = ((word.size / maxSize) * maxFontSize);

            if (size * 0.7 * word.text.length > _this.width) {
                tempScaleFactor = ((_this.width / word.text.length) / 0.7) / size;
            }

            if (scaleFactor > tempScaleFactor) {
                scaleFactor = tempScaleFactor;
            }
        });

        // Update the maximum font size based on the longest word.
        maxFontSize *= scaleFactor;

        // Generate the word cloud.
        d3.layout.cloud().size([this.width, this.height])
            .words(words)
            .rotate(function () {
                return Math.floor((Math.random() * 2)) * 90;
            })
            .font('Impact')
            .fontSize(function (d) {
                var size = (d.size / maxSize) * maxFontSize;

                size = size >= minFontSize ? size : minFontSize;

                return size;
            })
            .on('end', function (words, bounds) {
                // Draw the word cloud.
                _this.drawWordCloud(response, words, bounds);
            })
            .start();
    }; // End-of: WordCloudMain.prototype.showWordCloud = function (response) {

    /**
     * @function drawWordCloud
     *
     * This function will be called when d3 has finished initing the state for our word cloud,
     * and it is ready to hand off the process to the drawing routine. Basically set up everything
     * necessary for the actual drwing of the words.
     *
     * @param {object} response The response from the server that contains the user's entered words
     * along with all of the top words.
     *
     * @param {array} words An array of objects. Each object must have two properties. One property
     * is 'text' (the actual word), and the other property is 'size' which represents the number that the
     * word was enetered by the students.
     *
     * @param {array} bounds An array of two objects. First object is the top-left coordinates of the bounding
     * box where all of the words fir, second object is the bottom-right coordinates of the bounding box. Each
     * coordinate object contains two properties: 'x', and 'y'.
     */
    WordCloudMain.prototype.drawWordCloud = function (response, words, bounds) {
            // Color words in different colors.
        var fill = d3.scale.category20(),

            // Will be populated by words the user enetered.
            studentWordsKeys = [],

            // Comma separated string of user enetered words.
            studentWordsStr,

            // By default we do not scale.
            scale = 1,

            // Cahing of DOM element
            cloudSectionEl = this.wordCloudEl.find('.result_cloud_section'),

            // Needed for cahing of d3 group elements
            groupEl;

        // If bounding rectangle is given, scale based on the bounding box of all the words.
        if (bounds) {
            scale = 0.5 * Math.min(
                this.width / Math.abs(bounds[1].x - this.width / 2),
                this.width / Math.abs(bounds[0].x - this.width / 2),
                this.height / Math.abs(bounds[1].y - this.height / 2),
                this.height / Math.abs(bounds[0].y - this.height / 2)
            );
        }

        $.each(response.student_words, function (word, stat) {
            var percent = (response.display_student_percents) ? ' ' + (Math.round(100 * (stat / response.total_count))) + '%' : '';

            studentWordsKeys.push('<strong>' + word + '</strong>' + percent);
        });
        studentWordsStr = '' + studentWordsKeys.join(', ');

        cloudSectionEl
            .addClass('active')
            .find('.your_words').html(studentWordsStr)
            .find('.total_num_words').html(response.total_count);

        $(cloudSectionEl.attr('id') + ' .word_cloud').empty();

        // Actual drawing of word cloud.
        groupEl = d3.select('#' + cloudSectionEl.attr('id') + ' .word_cloud').append('svg')
                .attr('width', this.width)
                .attr('height', this.height)
                .append('g')
                .attr('transform', 'translate(' + (0.5 * this.width) + ',' + (0.5 * this.height) + ')')
                .selectAll('text')
                .data(words)
                .enter().append('g');

        groupEl
            .append('title')
            .text(function (d) {
                var res = '';

                $.each(response.top_words, function(index, value){
                    if (value.text === d.text) {
                        res = value.percent + '%';

                        return;
                    }
                });

                return res;
            });

        groupEl
            .append('text')
            .style('font-size', function (d) {
                return d.size + 'px';
            })
            .style('font-family', 'Impact')
            .style('fill', function (d, i) {
                return fill(i);
            })
            .attr('text-anchor', 'middle')
            .attr('transform', function (d) {
                return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')scale(' + scale + ')';
            })
            .text(function (d) {               
                return d.text;
            });
    }; // End-of: WordCloudMain.prototype.drawWordCloud = function (words, bounds) {

    return WordCloudMain;

}); // End-of: define('WordCloudMain', ['logme'], function (logme) {
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define) {

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Annotatable = (function() {
    Annotatable.prototype._debug = false;

    Annotatable.prototype.wrapperSelector = '.annotatable-wrapper';

    Annotatable.prototype.toggleAnnotationsSelector = '.annotatable-toggle-annotations';

    Annotatable.prototype.toggleInstructionsSelector = '.annotatable-toggle-instructions';

    Annotatable.prototype.instructionsSelector = '.annotatable-instructions';

    Annotatable.prototype.sectionSelector = '.annotatable-section';

    Annotatable.prototype.spanSelector = '.annotatable-span';

    Annotatable.prototype.replySelector = '.annotatable-reply';

    Annotatable.prototype.problemXModuleSelector = '.xmodule_CapaModule';

    Annotatable.prototype.problemSelector = 'section.problem';

    Annotatable.prototype.problemInputSelector = 'section.problem .annotation-input';

    Annotatable.prototype.problemReturnSelector = 'section.problem .annotation-return';

    function Annotatable(el) {
      this.onMoveTip = __bind(this.onMoveTip, this);
      this.onShowTip = __bind(this.onShowTip, this);
      this.onClickReturn = __bind(this.onClickReturn, this);
      this.onClickReply = __bind(this.onClickReply, this);
      this.onClickToggleInstructions = __bind(this.onClickToggleInstructions, this);
      this.onClickToggleAnnotations = __bind(this.onClickToggleAnnotations, this);
      if (this._debug) {
        console.log('loaded Annotatable');
      }
      this.el = el;
      this.$el = $(el);
      this.init();
    }

    Annotatable.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Annotatable.prototype.init = function() {
      this.initEvents();
      return this.initTips();
    };

    Annotatable.prototype.initEvents = function() {
      var _ref;
      _ref = [false, false], this.annotationsHidden = _ref[0], this.instructionsHidden = _ref[1];
      this.$(this.toggleAnnotationsSelector).bind('click', this.onClickToggleAnnotations);
      this.$(this.toggleInstructionsSelector).bind('click', this.onClickToggleInstructions);
      this.$el.delegate(this.replySelector, 'click', this.onClickReply);
      return $('body').delegate(this.problemReturnSelector, 'click', this.onClickReturn);
    };

    Annotatable.prototype.initTips = function() {
      var _this = this;
      return this.$(this.spanSelector).each(function(index, el) {
        return $(el).qtip(_this.getSpanTipOptions(el));
      });
    };

    Annotatable.prototype.getSpanTipOptions = function(el) {
      return {
        content: {
          title: {
            text: this.makeTipTitle(el)
          },
          text: this.makeTipContent(el)
        },
        position: {
          my: 'bottom center',
          at: 'top center',
          target: $(el),
          container: this.$(this.wrapperSelector),
          adjust: {
            y: -5
          }
        },
        show: {
          event: 'click mouseenter',
          solo: true
        },
        hide: {
          event: 'click mouseleave',
          delay: 500,
          fixed: true
        },
        style: {
          classes: 'ui-tooltip-annotatable'
        },
        events: {
          show: this.onShowTip,
          move: this.onMoveTip
        }
      };
    };

    Annotatable.prototype.onClickToggleAnnotations = function(e) {
      return this.toggleAnnotations();
    };

    Annotatable.prototype.onClickToggleInstructions = function(e) {
      return this.toggleInstructions();
    };

    Annotatable.prototype.onClickReply = function(e) {
      return this.replyTo(e.currentTarget);
    };

    Annotatable.prototype.onClickReturn = function(e) {
      return this.returnFrom(e.currentTarget);
    };

    Annotatable.prototype.onShowTip = function(event, api) {
      if (this.annotationsHidden) {
        return event.preventDefault();
      }
    };

    Annotatable.prototype.onMoveTip = function(event, api, position) {
      /*
      This method handles an edge case in which a tooltip is displayed above
      a non-overlapping span like this:
      
                           (( TOOLTIP ))
                                \/
      text text text ... text text text ...... <span span span>
      <span span span>
      
      The problem is that the tooltip looks disconnected from both spans, so
      we should re-position the tooltip to appear above the span.
      */

      var adjust_y, container, container_offset, focus_rect, is_non_overlapping, offset_left, offset_top, rect_center, rect_top, rects, target, tip, tip_height, tip_left, tip_top, tip_width, win_width, _ref, _ref1, _ref2;
      tip = api.elements.tooltip;
      adjust_y = ((_ref = api.options.position) != null ? (_ref1 = _ref.adjust) != null ? _ref1.y : void 0 : void 0) || 0;
      container = ((_ref2 = api.options.position) != null ? _ref2.container : void 0) || $('body');
      target = api.elements.target;
      rects = $(target).get(0).getClientRects();
      is_non_overlapping = (rects != null ? rects.length : void 0) === 2 && rects[0].left > rects[1].right;
      if (is_non_overlapping) {
        focus_rect = (rects[0].width > rects[1].width ? rects[0] : rects[1]);
        rect_center = focus_rect.left + (focus_rect.width / 2);
        rect_top = focus_rect.top;
        tip_width = $(tip).width();
        tip_height = $(tip).height();
        container_offset = $(container).offset();
        offset_left = -container_offset.left;
        offset_top = $(document).scrollTop() - container_offset.top;
        tip_left = offset_left + rect_center - (tip_width / 2);
        tip_top = offset_top + rect_top - tip_height + adjust_y;
        win_width = $(window).width();
        if (tip_left < offset_left) {
          tip_left = offset_left;
        } else if (tip_left + tip_width > win_width + offset_left) {
          tip_left = win_width + offset_left - tip_width;
        }
        return $.extend(position, {
          'left': tip_left,
          'top': tip_top
        });
      }
    };

    Annotatable.prototype.getSpanForProblemReturn = function(el) {
      var problem_id;
      problem_id = $(this.problemReturnSelector).index(el);
      return this.$(this.spanSelector).filter("[data-problem-id='" + problem_id + "']");
    };

    Annotatable.prototype.getProblem = function(el) {
      var problem_id;
      problem_id = this.getProblemId(el);
      return $(this.problemSelector).has(this.problemInputSelector).eq(problem_id);
    };

    Annotatable.prototype.getProblemId = function(el) {
      return $(el).data('problem-id');
    };

    Annotatable.prototype.toggleAnnotations = function() {
      var hide;
      hide = (this.annotationsHidden = !this.annotationsHidden);
      this.toggleAnnotationButtonText(hide);
      this.toggleSpans(hide);
      return this.toggleTips(hide);
    };

    Annotatable.prototype.toggleTips = function(hide) {
      var visible;
      visible = this.findVisibleTips();
      return this.hideTips(visible);
    };

    Annotatable.prototype.toggleAnnotationButtonText = function(hide) {
      var buttonText;
      buttonText = (hide ? 'Show' : 'Hide') + ' Annotations';
      return this.$(this.toggleAnnotationsSelector).text(buttonText);
    };

    Annotatable.prototype.toggleInstructions = function() {
      var hide;
      hide = (this.instructionsHidden = !this.instructionsHidden);
      this.toggleInstructionsButton(hide);
      return this.toggleInstructionsText(hide);
    };

    Annotatable.prototype.toggleInstructionsButton = function(hide) {
      var cls, txt;
      txt = (hide ? 'Expand' : 'Collapse') + ' Instructions';
      cls = (hide ? ['expanded', 'collapsed'] : ['collapsed', 'expanded']);
      return this.$(this.toggleInstructionsSelector).text(txt).removeClass(cls[0]).addClass(cls[1]);
    };

    Annotatable.prototype.toggleInstructionsText = function(hide) {
      var slideMethod;
      slideMethod = (hide ? 'slideUp' : 'slideDown');
      return this.$(this.instructionsSelector)[slideMethod]();
    };

    Annotatable.prototype.toggleSpans = function(hide) {
      return this.$(this.spanSelector).toggleClass('hide', hide, 250);
    };

    Annotatable.prototype.replyTo = function(buttonEl) {
      var el, offset;
      offset = -20;
      el = this.getProblem(buttonEl);
      if (el.length > 0) {
        return this.scrollTo(el, this.afterScrollToProblem, offset);
      } else {
        if (this._debug) {
          return console.log('problem not found. event: ', e);
        }
      }
    };

    Annotatable.prototype.returnFrom = function(buttonEl) {
      var el, offset;
      offset = -200;
      el = this.getSpanForProblemReturn(buttonEl);
      if (el.length > 0) {
        return this.scrollTo(el, this.afterScrollToSpan, offset);
      } else {
        if (this._debug) {
          return console.log('span not found. event:', e);
        }
      }
    };

    Annotatable.prototype.scrollTo = function(el, after, offset) {
      var _this = this;
      if (offset == null) {
        offset = -20;
      }
      if ($(el).length > 0) {
        return $('html,body').scrollTo(el, {
          duration: 500,
          onAfter: this._once(function() {
            return after != null ? after.call(_this, el) : void 0;
          }),
          offset: offset
        });
      }
    };

    Annotatable.prototype.afterScrollToProblem = function(problem_el) {
      return problem_el.effect('highlight', {}, 500);
    };

    Annotatable.prototype.afterScrollToSpan = function(span_el) {
      return span_el.addClass('selected', 400, 'swing', function() {
        return span_el.removeClass('selected', 400, 'swing');
      });
    };

    Annotatable.prototype.makeTipContent = function(el) {
      var _this = this;
      return function(api) {
        var comment, problem_id, reply, text;
        text = $(el).data('comment-body');
        comment = _this.createComment(text);
        problem_id = _this.getProblemId(el);
        reply = _this.createReplyLink(problem_id);
        return $(comment).add(reply);
      };
    };

    Annotatable.prototype.makeTipTitle = function(el) {
      var _this = this;
      return function(api) {
        var title;
        title = $(el).data('comment-title');
        if (title) {
          return title;
        } else {
          return 'Commentary';
        }
      };
    };

    Annotatable.prototype.createComment = function(text) {
      return $("<div class=\"annotatable-comment\">" + text + "</div>");
    };

    Annotatable.prototype.createReplyLink = function(problem_id) {
      return $("<a class=\"annotatable-reply\" href=\"javascript:void(0);\" data-problem-id=\"" + problem_id + "\">Reply to Annotation</a>");
    };

    Annotatable.prototype.findVisibleTips = function() {
      var visible;
      visible = [];
      this.$(this.spanSelector).each(function(index, el) {
        var api, tip;
        api = $(el).qtip('api');
        tip = $(api != null ? api.elements.tooltip : void 0);
        if (tip.is(':visible')) {
          return visible.push(el);
        }
      });
      return visible;
    };

    Annotatable.prototype.hideTips = function(elements) {
      return $(elements).qtip('hide');
    };

    Annotatable.prototype._once = function(fn) {
      var done,
        _this = this;
      done = false;
      return function() {
        if (!done) {
          fn.call(_this);
        }
        return done = true;
      };
    };

    return Annotatable;

  })();

}).call(this);

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('Inputs', ['logme'], function (logme) {
    return Inputs;

    function Inputs(gstId, gstClass, state) {
        var c1, paramName, allParamNames;

        allParamNames = state.getAllParameterNames();

        for (c1 = 0; c1 < allParamNames.length; c1 += 1) {
            $('#' + gstId).find('.' + gstClass + '_input').each(function (index, value) {
                var inputDiv, paramName;

                paramName = allParamNames[c1];
                inputDiv = $(value);

                if (paramName === inputDiv.data('var')) {
                    createInput(inputDiv, paramName);
                }
            });
        }

        return;

        function createInput(inputDiv, paramName) {
            var paramObj;

            paramObj = state.getParamObj(paramName);

            // Check that the retrieval went OK.
            if (paramObj === undefined) {
                logme('ERROR: Could not get a paramObj for parameter "' + paramName + '".');

                return;
            }

            // Bind a function to the 'change' event. Whenever the user changes
            // the value of this text input, and presses 'enter' (or clicks
            // somewhere else on the page), this event will be triggered, and
            // our callback will be called.
            inputDiv.bind('change', inputOnChange);

            inputDiv.val(paramObj.value);

            // Lets style the input element nicely. We will use the button()
            // widget for this since there is no native widget for the text
            // input.
            inputDiv.button().css({
                'font': 'inherit',
                'color': 'inherit',
                'text-align': 'left',
                'outline': 'none',
                'cursor': 'text',
                'height': '15px'
            });

            // Tell the parameter object from state that we are attaching a
            // text input to it. Next time the parameter will be updated with
            // a new value, tis input will also be updated.
            paramObj.inputDivs.push(inputDiv);

            return;

            // Update the 'state' - i.e. set the value of the parameter this
            // input is attached to to a new value.
            //
            // This will cause the plot to be redrawn each time after the user
            // changes the value in the input. Note that he has to either press
            // 'Enter', or click somewhere else on the page in order for the
            // 'change' event to be tiggered.
            function inputOnChange(event) {
                var inputDiv;

                inputDiv = $(this);
                state.setParameterValue(paramName, inputDiv.val(), inputDiv);
            }
        }
    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

(function (requirejs, require, define) {

/*
"This is as true in everyday life as it is in battle: we are given one life
and the decision is ours whether to wait for circumstances to make up our
mind, or whether to act, and in acting, to live."
 Omar N. Bradley
 */

// VideoProgressSlider module.
define(
'video/06_video_progress_slider.js',
[],
function () {

    // VideoProgressSlider() function - what this module "exports".
    return function (state) {
        state.videoProgressSlider = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        // No callbacks to DOM events (click, mousemove, etc.).
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoProgressSlider.onSlide        = _.bind(onSlide, state);
        state.videoProgressSlider.onStop         = _.bind(onStop, state);
        state.videoProgressSlider.updatePlayTime = _.bind(updatePlayTime, state);
        //Added for tests -- JM
        state.videoProgressSlider.buildSlider = _.bind(buildSlider, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their initial configuration. Also
    //     make the created DOM elements available via the 'state' object. Much easier to work this
    //     way - you don't have to do repeated jQuery element selects.
    function _renderElements(state) {
        if (!onTouchBasedDevice()) {
            state.videoProgressSlider.el = state.videoControl.sliderEl;

            buildSlider(state);
            _buildHandle(state);
        }
    }

    function _buildHandle(state) {
        state.videoProgressSlider.handle = state.videoProgressSlider.el.find('.ui-slider-handle');
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function buildSlider(state) {
        state.videoProgressSlider.slider = state.videoProgressSlider.el.slider({
            range: 'min',
            slide: state.videoProgressSlider.onSlide,
            stop: state.videoProgressSlider.onStop
        });
    }

    function onSlide(event, ui) {
        this.videoProgressSlider.frozen = true;

        this.trigger('videoPlayer.onSlideSeek', {'type': 'onSlideSeek', 'time': ui.value});
    }

    function onStop(event, ui) {
        var _this = this;

        this.videoProgressSlider.frozen = true;

        this.trigger('videoPlayer.onSlideSeek', {'type': 'onSlideSeek', 'time': ui.value});

        setTimeout(function() {
            _this.videoProgressSlider.frozen = false;
        }, 200);
    }

    //Changed for tests -- JM: Check if it is the cause of Chrome Bug Valera noticed
    function updatePlayTime(params) {
        if ((this.videoProgressSlider.slider) && (!this.videoProgressSlider.frozen)) {
            /*this.videoProgressSlider.slider
                .slider('option', 'max', params.duration)
                .slider('value', params.time);*/
            this.videoProgressSlider.slider.slider('option', 'max', params.duration);
            this.videoProgressSlider.slider.slider('option', 'value', params.time);
        }
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('Graph', ['logme'], function (logme) {

    return Graph;

    function Graph(gstId, config, state) {
        var plotDiv, dataSeries, functions, xaxis, yaxis, numPoints, xrange,
            asymptotes, movingLabels, xTicksNames, yTicksNames, graphBarWidth, graphBarAlign;

        // We need plot configuration settings. Without them we can't continue.
        if ($.isPlainObject(config.plot) === false) {
            return;
        }

        // We must have a graph container DIV element available in order to
        // proceed.
        plotDiv = $('#' + gstId + '_plot');
        if (plotDiv.length === 0) {
            logme('ERROR: Could not find the plot DIV with ID "' + gstId + '_plot".');

            return;
        }

        if (plotDiv.width() === 0) {
            plotDiv.width(300);
        }

        // Sometimes, when height is not explicitly set via CSS (or by some
        // other means), it is 0 pixels by default. When Flot will try to plot
        // a graph in this DIV with 0 height, then it will raise an error. To
        // prevent this, we will set it to be equal to the width.
        if (plotDiv.height() === 0) {
            plotDiv.height(plotDiv.width());
        }

        plotDiv.css('position', 'relative');

        // Configure some settings for the graph.
        if (setGraphXRange() === false) {
            logme('ERROR: Could not configure the xrange. Will not continue.');

            return;
        }

        if (setGraphAxes() === false) {
            logme('ERROR: Could not process configuration for the axes.');

            return;
        }

        graphBarWidth = 1;
        graphBarAlign = null;

        getBarWidth();
        getBarAlign();

        // Get the user defined functions. If there aren't any, don't do
        // anything else.
        createFunctions();

        if (functions.length === 0) {
            logme('ERROR: No functions were specified, or something went wrong.');

            return;
        }

        if (createMarkingsFunctions() === false) {
            return;
        }
        if (createMovingLabelFunctions() === false) {
            return;
        }

        // Create the initial graph and plot it for the user to see.
        if (generateData() === true) {
            updatePlot();
        }

        // Bind an event. Whenever some constant changes, the graph will be
        // redrawn
        state.bindUpdatePlotEvent(plotDiv, onUpdatePlot);

        return;

        function getBarWidth() {
            if (config.plot.hasOwnProperty('bar_width') === false) {
                return;
            }

            if (typeof config.plot.bar_width !== 'string') {
                logme('ERROR: The parameter config.plot.bar_width must be a string.');

                return;
            }

            if (isFinite(graphBarWidth = parseFloat(config.plot.bar_width)) === false) {
                logme('ERROR: The parameter config.plot.bar_width is not a valid floating number.');
                graphBarWidth = 1;

                return;
            }

            return;
        }

        function getBarAlign() {
            if (config.plot.hasOwnProperty('bar_align') === false) {
                return;
            }

            if (typeof config.plot.bar_align !== 'string') {
                logme('ERROR: The parameter config.plot.bar_align must be a string.');

                return;
            }

            if (
                (config.plot.bar_align.toLowerCase() !== 'left') &&
                (config.plot.bar_align.toLowerCase() !== 'center')
            ) {
                logme('ERROR: Property config.plot.bar_align can be one of "left", or "center".');

                return;
            }

            graphBarAlign = config.plot.bar_align.toLowerCase();

            return;
        }

        function createMovingLabelFunctions() {
            var c1, returnStatus;

            returnStatus = true;
            movingLabels = [];

            if (config.plot.hasOwnProperty('moving_label') !== true) {
                returnStatus = true;
            } else if ($.isPlainObject(config.plot.moving_label) === true) {
                if (processMovingLabel(config.plot.moving_label) === false) {
                    returnStatus = false;
                }
            } else if ($.isArray(config.plot.moving_label) === true) {
                for (c1 = 0; c1 < config.plot.moving_label.length; c1++) {
                    if (processMovingLabel(config.plot.moving_label[c1]) === false) {
                        returnStatus = false;
                    }
                }
            }

            return returnStatus;
        }

        function processMovingLabel(obj) {
            var labelText, funcString, disableAutoReturn, paramNames, func,
                fontWeight, fontColor;

            if (obj.hasOwnProperty('@text') === false) {
                logme('ERROR: You did not define a "text" attribute for the moving_label.');

                return false;
            }
            if (typeof obj['@text'] !== 'string') {
                logme('ERROR: "text" attribute is not a string.');

                return false;
            }
            labelText = obj['@text'];

            if (obj.hasOwnProperty('#text') === false) {
                logme('ERROR: moving_label is missing function declaration.');

                return false;
            }
            if (typeof obj['#text'] !== 'string') {
                logme('ERROR: Function declaration is not a string.');

                return false;
            }
            funcString = obj['#text'];

            fontColor = 'black';
            if (
                (obj.hasOwnProperty('@color') === true) &&
                (typeof obj['@color'] === 'string')
            ) {
                fontColor = obj['@color'];
            }

            fontWeight = 'normal';
            if (
                (obj.hasOwnProperty('@weight') === true) &&
                (typeof obj['@weight'] === 'string')
            ) {
                if (
                    (obj['@weight'].toLowerCase() === 'normal') ||
                    (obj['@weight'].toLowerCase() === 'bold')
                ) {
                    fontWeight = obj['@weight'];
                } else {
                    logme('ERROR: Moving label can have a weight property of "normal" or "bold".');
                }
            }

            disableAutoReturn = obj['@disable_auto_return'];

            funcString = $('<div>').html(funcString).text();

            if (
                (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                            (disableAutoReturn.toLowerCase() !== 'true')
                    )
            ) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    logme(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            paramNames = state.getAllParameterNames();
            paramNames.push(funcString);

            try {
                func = Function.apply(null, paramNames);
            } catch (err) {
                logme(
                    'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                );
                logme('Error message: "' + err.message + '"');

                if (state.showDebugInfo) {
                    $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from the string "' + funcString + '".' + '</div>');
                    $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                }

                paramNames.pop();

                return false;
            }

            paramNames.pop();

            movingLabels.push({
                'labelText': labelText,
                'func': func,
                'el': null,
                'fontColor': fontColor,
                'fontWeight': fontWeight
            });

            return true;
        }

        function createMarkingsFunctions() {
            var c1, paramNames, returnStatus;

            returnStatus = true;

            asymptotes = [];
            paramNames = state.getAllParameterNames();

            if ($.isPlainObject(config.plot.asymptote)) {
                if (processAsymptote(config.plot.asymptote) === false) {
                    returnStatus = false;
                }
            } else if ($.isArray(config.plot.asymptote)) {
                for (c1 = 0; c1 < config.plot.asymptote.length; c1 += 1) {
                    if (processAsymptote(config.plot.asymptote[c1]) === false) {
                        returnStatus = false;
                    }
                }
            }

            return returnStatus;

            // Read configuration options for asymptotes, and store them as
            // an array of objects. Each object will have 3 properties:
            //
            //    - color: the color of the asymptote line
            //    - type: 'x' (vertical), or 'y' (horizontal)
            //    - func: the function that will generate the value at which
            //            the asymptote will be plotted; i.e. x = func(), or
            //            y = func(); for now only horizontal and vertical
            //            asymptotes are supported
            //
            // Since each asymptote can have a variable function - function
            // that relies on some parameter specified in the config - we will
            // generate each asymptote just before we draw the graph. See:
            //
            //     function updatePlot()
            //     function generateMarkings()
            //
            // Asymptotes are really thin rectangles implemented via the Flot's
            // markings option.
            function processAsymptote(asyObj) {
                var newAsyObj, funcString, func;

                newAsyObj = {};

                if (typeof asyObj['@type'] === 'string') {
                    if (asyObj['@type'].toLowerCase() === 'x') {
                        newAsyObj.type = 'x';
                    } else if (asyObj['@type'].toLowerCase() === 'y') {
                        newAsyObj.type = 'y';
                    } else {
                        logme('ERROR: Attribute "type" for asymptote can be "x" or "y".');

                        return false;
                    }
                } else {
                    logme('ERROR: Attribute "type" for asymptote is not specified.');

                    return false;
                }

                if (typeof asyObj['#text'] === 'string') {
                    funcString = asyObj['#text'];
                } else {
                    logme('ERROR: Function body for asymptote is not specified.');

                    return false;
                }

                newAsyObj.color = '#000';
                if (typeof asyObj['@color'] === 'string') {
                    newAsyObj.color = asyObj['@color'];
                }

                newAsyObj.label = false;
                if (
                    (asyObj.hasOwnProperty('@label') === true) &&
                    (typeof asyObj['@label'] === 'string')
                ) {
                    newAsyObj.label = asyObj['@label'];
                }

                funcString = $('<div>').html(funcString).text();

                disableAutoReturn = asyObj['@disable_auto_return'];
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    if (funcString.search(/return/i) === -1) {
                        funcString = 'return ' + funcString;
                    }
                } else {
                    if (funcString.search(/return/i) === -1) {
                        logme(
                            'ERROR: You have specified a JavaScript ' +
                            'function without a "return" statemnt. Your ' +
                            'function will return "undefined" by default.'
                        );
                    }
                }

                paramNames.push(funcString);

                try {
                    func = Function.apply(null, paramNames);
                } catch (err) {
                    logme('ERROR: Asymptote function body could not be converted to function object.');
                    logme('Error message: "".' + err.message);

                    return false;
                }

                paramNames.pop();

                newAsyObj.func = func;
                asymptotes.push(newAsyObj);

                return true;
            }
        }

        function setGraphAxes() {
            xaxis = {
                'tickFormatter': null
            };

            if (typeof config.plot['xticks'] === 'string') {
                if (processTicks(config.plot['xticks'], xaxis, 'xunits') === false) {
                    logme('ERROR: Could not process the ticks for x-axis.');

                    return false;
                }
            } else {
                // logme('MESSAGE: "xticks" were not specified. Using defaults.');

                return false;
            }

            yaxis = {
                'tickFormatter': null
            };
            if (typeof config.plot['yticks'] === 'string') {
                if (processTicks(config.plot['yticks'], yaxis, 'yunits') === false) {
                    logme('ERROR: Could not process the ticks for y-axis.');

                    return false;
                }
            } else {
                // logme('MESSAGE: "yticks" were not specified. Using defaults.');

                return false;
            }

            xTicksNames = null;
            yTicksNames = null;

            if (checkForTicksNames('x') === false) {
                return false;
            }

            if (checkForTicksNames('y') === false) {
                return false;
            }

            return true;

            //
            // function checkForTicksNames(axisName)
            //
            // The parameter "axisName" can be either "x" or "y" (string). Depending on it, the function
            // will set "xTicksNames" or "yTicksNames" private variable.
            //
            // This function does not return anything. It sets the private variable "xTicksNames" ("yTicksNames")
            // to the object converted by JSON.parse from the XML parameter "plot.xticks_names" ("plot.yticks_names").
            // If the "plot.xticks_names" ("plot.yticks_names") is missing or it is not a valid JSON string, then
            // "xTicksNames" ("yTicksNames") will be set to "null".
            //
            // Depending on the "xTicksNames" ("yTicksNames") being "null" or an object, the plot will either draw
            // number ticks, or use the names specified by the opbject.
            //
            function checkForTicksNames(axisName) {
                var tmpObj;

                if ((axisName !== 'x') && (axisName !== 'y')) {
                    // This is not an error. This funcion should simply stop executing.

                    return true;
                }

                if (
                    (config.plot.hasOwnProperty(axisName + 'ticks_names') === true) ||
                    (typeof config.plot[axisName + 'ticks_names'] === 'string')
                ) {
                    try {
                        tmpObj = JSON.parse(config.plot[axisName + 'ticks_names']);
                    } catch (err) {
                        logme(
                            'ERROR: plot.' + axisName + 'ticks_names is not a valid JSON string.',
                            'Error message: "' + err.message + '".'
                        );

                        return false;
                    }

                    if (axisName === 'x') {
                        xTicksNames = tmpObj;
                        xaxis.tickFormatter = xAxisTickFormatter;
                    }
                    // At this point, we are certain that axisName = 'y'.
                    else {
                        yTicksNames = tmpObj;
                        yaxis.tickFormatter = yAxisTickFormatter;
                    }
                }
            }

            function processTicks(ticksStr, ticksObj, unitsType) {
                var ticksBlobs, tempFloat, tempTicks, c1, c2;

                // The 'ticks' setting is a string containing 3 floating-point
                // numbers.
                ticksBlobs = ticksStr.split(',');

                if (ticksBlobs.length !== 3) {
                    logme('ERROR: Did not get 3 blobs from ticksStr = "' + ticksStr + '".');

                    return false;
                }

                tempFloat = parseFloat(ticksBlobs[0]);
                if (isNaN(tempFloat) === false) {
                    ticksObj.min = tempFloat;
                } else {
                    logme('ERROR: Invalid "min". ticksBlobs[0] = ', ticksBlobs[0]);

                    return false;
                }

                tempFloat = parseFloat(ticksBlobs[1]);
                if (isNaN(tempFloat) === false) {
                    ticksObj.tickSize = tempFloat;
                } else {
                    logme('ERROR: Invalid "tickSize". ticksBlobs[1] = ', ticksBlobs[1]);

                    return false;
                }

                tempFloat = parseFloat(ticksBlobs[2]);
                if (isNaN(tempFloat) === false) {
                    ticksObj.max = tempFloat;
                } else {
                    logme('ERROR: Invalid "max". ticksBlobs[2] = ', ticksBlobs[2]);

                    return false;
                }

                // Is the starting tick to the left of the ending tick (on the
                // x-axis)? If not, set default starting and ending tick.
                if (ticksObj.min >= ticksObj.max) {
                    logme('ERROR: Ticks min >= max.');

                    return false;
                }

                // Make sure the range makes sense - i.e. that there are at
                // least 3 ticks. If not, set a tickSize which will produce
                // 11 ticks. tickSize is the spacing between the ticks.
                if (ticksObj.tickSize > ticksObj.max - ticksObj.min) {
                    logme('ERROR: tickSize > max - min.');

                    return false;
                }

                //  units: change last tick to units
                if (typeof config.plot[unitsType] === 'string') {
                    tempTicks = [];

                    for (c1 = ticksObj.min; c1 <= ticksObj.max; c1 += ticksObj.tickSize) {
                        c2 = roundToPrec(c1, ticksObj.tickSize);
                        tempTicks.push([c2, c2]);
                    }

                    tempTicks.pop();
                    tempTicks.push([
                        roundToPrec(ticksObj.max, ticksObj.tickSize),
                        config.plot[unitsType]
                    ]);

                    ticksObj.tickSize = null;
                    ticksObj.ticks = tempTicks;
                }

                return true;

                function roundToPrec(num, prec) {
                    var c1, tn1, tn2, digitsBefore, digitsAfter;

                    tn1 = Math.abs(num);
                    tn2 = Math.abs(prec);

                    // Find out number of digits BEFORE the decimal point.
                    c1 = 0;
                    tn1 = Math.abs(num);
                    while (tn1 >= 1) {
                        c1 += 1;

                        tn1 /= 10;
                    }
                    digitsBefore = c1;

                    // Find out number of digits AFTER the decimal point.
                    c1 = 0;
                    tn1 = Math.abs(num);
                    while (Math.round(tn1) !== tn1) {
                        c1 += 1;

                        tn1 *= 10;
                    }
                    digitsAfter = c1;

                    // For precision, find out number of digits AFTER the
                    // decimal point.
                    c1 = 0;
                    while (Math.round(tn2) !== tn2) {
                        c1 += 1;

                        tn2 *= 10;
                    }

                    // If precision is more than 1 (no digits after decimal
                    // points).
                    if (c1 === 0) {
                        return num;
                    }

                    // If the precision contains digits after the decimal
                    // point, we apply special rules.
                    else {
                        tn1 = Math.abs(num);

                        // if (digitsAfter > c1) {
                            tn1 = tn1.toFixed(c1);
                        // } else {
                        //     tn1 = tn1.toPrecision(digitsBefore + digitsAfter);
                        // }
                    }

                    if (num < 0) {
                        return -tn1;
                    }

                    return tn1;
                }
            }
        }

        function setGraphXRange() {
            var xRangeStr, xRangeBlobs, tempNum, allParamNames, funcString,
                disableAutoReturn;

            xrange = {};

            if ($.isPlainObject(config.plot.xrange) === false) {
                logme(
                    'ERROR: Expected config.plot.xrange to be an object. ' +
                    'It is not.'
                );
                logme('config.plot.xrange = ', config.plot.xrange);

                return false;
            }

            if (config.plot.xrange.hasOwnProperty('min') === false) {
                logme(
                    'ERROR: Expected config.plot.xrange.min to be ' +
                    'present. It is not.'
                );

                return false;
            }

            disableAutoReturn = false;
            if (typeof config.plot.xrange.min === 'string') {
                funcString = config.plot.xrange.min;
            } else if (
                ($.isPlainObject(config.plot.xrange.min) === true) &&
                (config.plot.xrange.min.hasOwnProperty('#text') === true) &&
                (typeof config.plot.xrange.min['#text'] === 'string')
            ) {
                funcString = config.plot.xrange.min['#text'];

                disableAutoReturn =
                    config.plot.xrange.min['@disable_auto_return'];
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    disableAutoReturn = false;
                } else {
                    disableAutoReturn = true;
                }
            } else {
                logme(
                    'ERROR: Could not get a function definition for ' +
                    'xrange.min property.'
                );

                return false;
            }

            funcString = $('<div>').html(funcString).text();

            if (disableAutoReturn === false) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    logme(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            allParamNames = state.getAllParameterNames();

            allParamNames.push(funcString);
            try {
                xrange.min = Function.apply(null, allParamNames);
            } catch (err) {
                logme(
                    'ERROR: could not create a function from the string "' +
                    funcString + '" for xrange.min.'
                );
                logme('Error message: "' + err.message + '"');

                if (state.showDebugInfo) {
                    $('#' + gstId).html(
                        '<div style="color: red;">' + 'ERROR IN ' +
                        'XML: Could not create a function from the string "' +
                        funcString + '" for xrange.min.' + '</div>'
                    );
                    $('#' + gstId).append(
                        '<div style="color: red;">' + 'Error ' +
                        'message: "' + err.message + '".' + '</div>'
                    );
                }

                return false;
            }
            allParamNames.pop();

            if (config.plot.xrange.hasOwnProperty('max') === false) {
                logme(
                    'ERROR: Expected config.plot.xrange.max to be ' +
                    'present. It is not.'
                );

                return false;
            }

            disableAutoReturn = false;
            if (typeof config.plot.xrange.max === 'string') {
                funcString = config.plot.xrange.max;
            } else if (
                ($.isPlainObject(config.plot.xrange.max) === true) &&
                (config.plot.xrange.max.hasOwnProperty('#text') === true) &&
                (typeof config.plot.xrange.max['#text'] === 'string')
            ) {
                funcString = config.plot.xrange.max['#text'];

                disableAutoReturn =
                    config.plot.xrange.max['@disable_auto_return'];
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    disableAutoReturn = false;
                } else {
                    disableAutoReturn = true;
                }
            } else {
                logme(
                    'ERROR: Could not get a function definition for ' +
                    'xrange.max property.'
                );

                return false;
            }

            funcString = $('<div>').html(funcString).text();

            if (disableAutoReturn === false) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    logme(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            allParamNames.push(funcString);
            try {
                xrange.max = Function.apply(null, allParamNames);
            } catch (err) {
                logme(
                    'ERROR: could not create a function from the string "' +
                    funcString + '" for xrange.max.'
                );
                logme('Error message: "' + err.message + '"');

                if (state.showDebugInfo) {
                    $('#' + gstId).html(
                        '<div style="color: red;">' + 'ERROR IN ' +
                        'XML: Could not create a function from the string "' +
                        funcString + '" for xrange.max.' + '</div>'
                    );
                    $('#' + gstId).append(
                        '<div style="color: red;">' + 'Error message: "' +
                        err.message + '".' + '</div>'
                    );
                }

                return false;
            }
            allParamNames.pop();

            tempNum = parseInt(config.plot.num_points, 10);
            if (isFinite(tempNum) === false) {
                tempNum = plotDiv.width() / 5.0;
            }

            if (
                (tempNum < 2) &&
                (tempNum > 1000)
            ) {
                logme(
                    'ERROR: Number of points is outside the allowed range ' +
                    '[2, 1000]'
                );
                logme('config.plot.num_points = ' + tempNum);

                return false;
            }

            numPoints = tempNum;

            return true;
        }

        function createFunctions() {
            var c1;

            functions = [];

            if (typeof config.functions === 'undefined') {
                logme('ERROR: config.functions is undefined.');

                return;
            }

            if (typeof config.functions["function"] === 'string') {

                // If just one function string is present.
                addFunction(config.functions["function"]);

            } else if ($.isPlainObject(config.functions["function"]) === true) {

                // If a function is present, but it also has properties
                // defined.
                callAddFunction(config.functions["function"]);

            } else if ($.isArray(config.functions["function"])) {

                // If more than one function is defined.
                for (c1 = 0; c1 < config.functions["function"].length; c1 += 1) {

                    // For each definition, we must check if it is a simple
                    // string definition, or a complex one with properties.
                    if (typeof config.functions["function"][c1] === 'string') {

                        // Simple string.
                        addFunction(config.functions["function"][c1]);

                    } else if ($.isPlainObject(config.functions["function"][c1])) {

                        // Properties are present.
                        callAddFunction(config.functions["function"][c1]);

                    }
                }
            } else {
                logme('ERROR: config.functions.function is of an unsupported type.');

                return;
            }

            return;

            // This function will reduce code duplication. We have to call
            // the function addFunction() several times passing object
            // properties as parameters. Rather than writing them out every
            // time, we will have a single place where it is done.
            function callAddFunction(obj) {
                if (
                    (obj.hasOwnProperty('@output')) &&
                    (typeof obj['@output'] === 'string')
                ) {

                    // If this function is meant to be calculated for an
                    // element then skip it.
                    if ((obj['@output'].toLowerCase() === 'element') ||
                        (obj['@output'].toLowerCase() === 'none')) {
                        return;
                    }

                    // If this function is meant to be calculated for a
                    // dynamic element in a label then skip it.
                    else if (obj['@output'].toLowerCase() === 'plot_label') {
                        return;
                    }

                    // It is an error if '@output' is not 'element',
                    // 'plot_label', or 'graph'. However, if the '@output'
                    // attribute is omitted, we will not have reached this.
                    else if (obj['@output'].toLowerCase() !== 'graph') {
                        logme(
                            'ERROR: Function "output" attribute can be ' +
                            'either "element", "plot_label", "none" or "graph".'
                        );

                        return;
                    }

                }

                // The user did not specify an "output" attribute, or it is
                // "graph".
                addFunction(
                    obj['#text'],
                    obj['@color'],
                    obj['@line'],
                    obj['@dot'],
                    obj['@label'],
                    obj['@point_size'],
                    obj['@fill_area'],
                    obj['@bar'],
                    obj['@disable_auto_return']
                );
            }

            function addFunction(funcString, color, line, dot, label,
                pointSize, fillArea, bar, disableAutoReturn) {

                var newFunctionObject, func, paramNames, c1, rgxp;

                // The main requirement is function string. Without it we can't
                // create a function, and the series cannot be calculated.
                if (typeof funcString !== 'string') {
                    return;
                }

                // Make sure that any HTML entities that were escaped will be
                // unescaped. This is done because if a string with escaped
                // HTML entities is passed to the Function() constructor, it
                // will break.
                funcString = $('<div>').html(funcString).text();

                // If the user did not specifically turn off this feature,
                // check if the function string contains a 'return', and
                // prepend a 'return ' to the string if one, or more, is not
                // found.
                if (
                    (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
                ) {
                    if (funcString.search(/return/i) === -1) {
                        funcString = 'return ' + funcString;
                    }
                } else {
                    if (funcString.search(/return/i) === -1) {
                        logme(
                            'ERROR: You have specified a JavaScript ' +
                            'function without a "return" statemnt. Your ' +
                            'function will return "undefined" by default.'
                        );
                    }
                }

                // Some defaults. If no options are set for the graph, we will
                // make sure that at least a line is drawn for a function.
                newFunctionObject = {
                    'line': true,
                    'dot': false,
                    'bars': false
                };

                // Get all of the parameter names defined by the user in the
                // XML.
                paramNames = state.getAllParameterNames();

                // The 'x' is always one of the function parameters.
                paramNames.push('x');

                // Must make sure that the function body also gets passed to
                // the Function constructor.
                paramNames.push(funcString);

                // Create the function from the function string, and all of the
                // available parameters AND the 'x' variable as it's parameters.
                // For this we will use the built-in Function object
                // constructor.
                //
                // If something goes wrong during this step, most
                // likely the user supplied an invalid JavaScript function body
                // string. In this case we will not proceed.
                try {
                    func = Function.apply(null, paramNames);
                } catch (err) {
                    logme(
                        'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                    );
                    logme('Error message: "' + err.message + '"');

                    if (state.showDebugInfo) {
                        $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from the string "' + funcString + '".' + '</div>');
                        $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                    }

                    paramNames.pop();
                    paramNames.pop();

                    return;
                }

                // Return the array back to original state. Remember that it is
                // a pointer to original array which is stored in state object.
                paramNames.pop();
                paramNames.pop();

                newFunctionObject['func'] = func;

                if (typeof color === 'string') {
                    newFunctionObject['color'] = color;
                }

                if (typeof line === 'string') {
                    if (line.toLowerCase() === 'true') {
                        newFunctionObject['line'] = true;
                    } else if (line.toLowerCase() === 'false') {
                        newFunctionObject['line'] = false;
                    }
                }

                if (typeof dot === 'string') {
                    if (dot.toLowerCase() === 'true') {
                        newFunctionObject['dot'] = true;
                    } else if (dot.toLowerCase() === 'false') {
                        newFunctionObject['dot'] = false;
                    }
                }

                if (typeof pointSize === 'string') {
                    newFunctionObject['pointSize'] = pointSize;
                }

                if (typeof bar === 'string') {
                    if (bar.toLowerCase() === 'true') {
                        newFunctionObject['bars'] = true;
                    } else if (bar.toLowerCase() === 'false') {
                        newFunctionObject['bars'] = false;
                    }
                }

                if (newFunctionObject['bars'] === true) {
                    newFunctionObject['line'] = false;
                    newFunctionObject['dot'] = false;
                    // To do: See if need to do anything here.
                } else if (
                    (newFunctionObject['dot'] === false) &&
                    (newFunctionObject['line'] === false)
                ) {
                    newFunctionObject['line'] = true;
                }

                if (newFunctionObject['line'] === true) {
                    if (typeof fillArea === 'string') {
                        if (fillArea.toLowerCase() === 'true') {
                            newFunctionObject['fillArea'] = true;
                        } else if (fillArea.toLowerCase() === 'false') {
                            newFunctionObject['fillArea'] = false;
                        } else {
                            logme('ERROR: The attribute fill_area should be either "true" or "false".');
                            logme('fill_area = "' + fillArea + '".');

                            return;
                        }
                    }
                }

                if (typeof label === 'string') {

                    newFunctionObject.specialLabel = false;
                    newFunctionObject.pldeHash = [];

                    // Let's check the label against all of the plde objects.
                    // plde is an abbreviation for Plot Label Dynamic Elements.
                    for (c1 = 0; c1 < state.plde.length; c1 += 1) {
                        rgxp = new RegExp(state.plde[c1].elId, 'g');

                        // If we find a dynamic element in the label, we will
                        // hash the current plde object, and indicate that this
                        // is a special label.
                        if (rgxp.test(label) === true) {
                            newFunctionObject.specialLabel = true;
                            newFunctionObject.pldeHash.push(state.plde[c1]);
                        }
                    }

                    newFunctionObject.label = label;
                } else {
                    newFunctionObject.label = false;
                }

                functions.push(newFunctionObject);
            }
        }

        // The callback that will be called whenever a constant changes (gets
        // updated via a slider or a text input).
        function onUpdatePlot(event) {
            if (generateData() === true) {
                updatePlot();
            }
        }

        function generateData() {
            var c0, c1, c3, functionObj, seriesObj, dataPoints, paramValues, x, y,
                start, end, step, numNotUndefined;

            paramValues = state.getAllParameterValues();

            dataSeries = [];

            for (c0 = 0; c0 < functions.length; c0 += 1) {
                functionObj = functions[c0];

                try {
                    start = xrange.min.apply(window, paramValues);
                } catch (err) {
                    logme('ERROR: Could not determine xrange start.');
                    logme('Error message: "' + err.message + '".');

                    if (state.showDebugInfo) {
                        $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not determine xrange start from defined function.' + '</div>');
                        $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                    }

                    return false;
                }
                try {
                    end = xrange.max.apply(window, paramValues);
                } catch (err) {
                    logme('ERROR: Could not determine xrange end.');
                    logme('Error message: "' + err.message + '".');

                    if (state.showDebugInfo) {
                        $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not determine xrange end from defined function.' + '</div>');
                        $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                    }

                    return false;
                }

                seriesObj = {};
                dataPoints = [];

                // For counting number of points added. In the end we will
                // compare this number to 'numPoints' specified in the config
                // JSON.
                c1 = 0;

                step = (end - start) / (numPoints - 1);

                // Generate the data points.
                for (x = start; x <= end; x += step) {

                    // Push the 'x' variable to the end of the parameter array.
                    paramValues.push(x);

                    // We call the user defined function, passing all of the
                    // available parameter values. Inside this function they
                    // will be accessible by their names.
                    try {
                        y = functionObj.func.apply(window, paramValues);
                    } catch (err) {
                        logme('ERROR: Could not generate data.');
                        logme('Error message: "' + err.message + '".');

                        if (state.showDebugInfo) {
                            $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not generate data from defined function.' + '</div>');
                            $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                        }

                        return false;
                    }

                    // Return the paramValues array to how it was before we
                    // added 'x' variable to the end of it.
                    paramValues.pop();

                    // Add the generated point to the data points set.
                    dataPoints.push([x, y]);

                    c1 += 1;

                }

                // If the last point did not get included because of rounding
                // of floating-point number addition, then we will include it
                // manually.
                if (c1 != numPoints) {
                    x = end;
                    paramValues.push(x);
                    try {
                        y = functionObj.func.apply(window, paramValues);
                    } catch (err) {
                        logme('ERROR: Could not generate data.');
                        logme('Error message: "' + err.message + '".');

                        if (state.showDebugInfo) {
                            $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not generate data from function.' + '</div>');
                            $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                        }

                        return false;
                    }
                    paramValues.pop();
                    dataPoints.push([x, y]);
                }

                // Put the entire data points set into the series object.
                seriesObj.data = dataPoints;

                // See if user defined a specific color for this function.
                if (functionObj.hasOwnProperty('color') === true) {
                    seriesObj.color = functionObj.color;
                }

                // See if a user defined a label for this function.
                if (functionObj.label !== false) {
                    if (functionObj.specialLabel === true) {
                        (function (c1) {
                            var tempLabel;

                            tempLabel = functionObj.label;

                            while (c1 < functionObj.pldeHash.length) {
                                tempLabel = tempLabel.replace(
                                    functionObj.pldeHash[c1].elId,
                                    functionObj.pldeHash[c1].func.apply(
                                        window,
                                        state.getAllParameterValues()
                                    )
                                );

                                c1 += 1;
                            }

                            seriesObj.label = tempLabel;
                        }(0));
                    } else {
                        seriesObj.label = functionObj.label;
                    }
                }

                // Should the data points be connected by a line?
                seriesObj.lines = {
                    'show': functionObj.line
                };

                if (functionObj.hasOwnProperty('fillArea') === true) {
                    seriesObj.lines.fill = functionObj.fillArea;
                }

                // Should each data point be represented by a point on the
                // graph?
                seriesObj.points = {
                    'show': functionObj.dot
                };

                seriesObj.bars = {
                    'show': functionObj.bars,
                    'barWidth': graphBarWidth
                };

                if (graphBarAlign !== null) {
                    seriesObj.bars.align = graphBarAlign;
                }

                if (functionObj.hasOwnProperty('pointSize')) {
                    seriesObj.points.radius = functionObj.pointSize;
                }

                // Add the newly created series object to the series set which
                // will be plotted by Flot.
                dataSeries.push(seriesObj);
            }

            if (graphBarAlign === null) {
                for (c0 = 0; c0 < numPoints; c0 += 1) {
                    // Number of points that have a value other than 'undefined' (undefined).
                    numNotUndefined = 0;

                    for (c1 = 0; c1 < dataSeries.length; c1 += 1) {
                        if (dataSeries[c1].bars.show === false) {
                            continue;
                        }

                        if (isFinite(parseInt(dataSeries[c1].data[c0][1])) === true) {
                            numNotUndefined += 1;
                        }
                    }

                    c3 = 0;
                    for (c1 = 0; c1 < dataSeries.length; c1 += 1) {
                        if (dataSeries[c1].bars.show === false) {
                            continue;
                        }

                        dataSeries[c1].data[c0][0] -= graphBarWidth * (0.5 * numNotUndefined - c3);

                        if (isFinite(parseInt(dataSeries[c1].data[c0][1])) === true) {
                            c3 += 1;
                        }
                    }
                }
            }

            for (c0 = 0; c0 < asymptotes.length; c0 += 1) {

                // If the user defined a label for this asympote, then the
                // property 'label' will be a string (in the other case it is
                // a boolean value 'false'). We will create an empty data set,
                // and add to it a label. This solution is a bit _wrong_ , but
                // it will have to do for now. Flot JS does not provide a way
                // to add labels to markings, and we use markings to generate
                // asymptotes.
                if (asymptotes[c0].label !== false) {
                    dataSeries.push({
                        'data': [],
                        'label': asymptotes[c0].label,
                        'color': asymptotes[c0].color
                    });
                }

            }

            return true;
        } // End-of: function generateData

        function updatePlot() {
            var paramValues, plotObj;

            paramValues = state.getAllParameterValues();

            if (xaxis.tickFormatter !== null) {
                xaxis.ticks = null;
            }

            if (yaxis.tickFormatter !== null) {
                yaxis.ticks = null;
            }

            // Tell Flot to draw the graph to our specification.
            plotObj = $.plot(
                plotDiv,
                dataSeries,
                {
                    'xaxis': xaxis,
                    'yaxis': yaxis,
                    'legend': {

                        // To show the legend or not. Note, even if 'show' is
                        // 'true', the legend will only show if labels are
                        // provided for at least one of the series that are
                        // going to be plotted.
                        'show': true,

                        // A floating point number in the range [0, 1]. The
                        // smaller the number, the more transparent will the
                        // legend background become.
                        'backgroundOpacity': 0

                    },
                    'grid': {
                        'markings': generateMarkings()
                    }
                }
            );

            updateMovingLabels();

            // The first time that the graph gets added to the page, the legend
            // is created from scratch. When it appears, MathJax works some
            // magic, and all of the specially marked TeX gets rendered nicely.
            // The next time when we update the graph, no such thing happens.
            // We must ask MathJax to typeset the legend again (well, we will
            // ask it to look at our entire graph DIV), the next time it's
            // worker queue is available.
            MathJax.Hub.Queue([
                'Typeset',
                MathJax.Hub,
                plotDiv.attr('id')
            ]);

            return;

            function updateMovingLabels() {
                var c1, labelCoord, pointOffset;

                for (c1 = 0; c1 < movingLabels.length; c1 += 1) {
                    if (movingLabels[c1].el === null) {
                        movingLabels[c1].el = $(
                            '<div>' +
                                movingLabels[c1].labelText +
                            '</div>'
                        );
                        movingLabels[c1].el.css('position', 'absolute');
                        movingLabels[c1].el.css('color', movingLabels[c1].fontColor);
                        movingLabels[c1].el.css('font-weight', movingLabels[c1].fontWeight);
                        movingLabels[c1].el.appendTo(plotDiv);

                        movingLabels[c1].elWidth = movingLabels[c1].el.width();
                        movingLabels[c1].elHeight = movingLabels[c1].el.height();
                    } else {
                        movingLabels[c1].el.detach();
                        movingLabels[c1].el.appendTo(plotDiv);
                    }

                    labelCoord = movingLabels[c1].func.apply(window, paramValues);

                    pointOffset = plotObj.pointOffset({'x': labelCoord.x, 'y': labelCoord.y});

                    movingLabels[c1].el.css('left', pointOffset.left - 0.5 * movingLabels[c1].elWidth);
                    movingLabels[c1].el.css('top', pointOffset.top - 0.5 * movingLabels[c1].elHeight);
                }
            }

            // Generate markings to represent asymptotes defined by the user.
            // See the following function for more details:
            //
            //     function processAsymptote()
            //
            function generateMarkings() {
                var c1, asymptote, markings, val;

                markings = [];

                for (c1 = 0; c1 < asymptotes.length; c1 += 1) {
                    asymptote = asymptotes[c1];

                    try {
                        val = asymptote.func.apply(window, paramValues);
                    } catch (err) {
                        logme('ERROR: Could not generate value from asymptote function.');
                        logme('Error message: ', err.message);

                        continue;
                    }

                    if (asymptote.type === 'x') {
                        markings.push({
                            'color': asymptote.color,
                            'lineWidth': 2,
                            'xaxis': {
                                'from': val,
                                'to': val
                            }
                        });
                    } else {
                        markings.push({
                            'color': asymptote.color,
                            'lineWidth': 2,
                            'yaxis': {
                                'from': val,
                                'to': val
                            }
                        });

                    }
                }

                return markings;
            }
        }

        function xAxisTickFormatter(val, axis) {
            if (xTicksNames.hasOwnProperty(val.toFixed(axis.tickDecimals)) === true) {
                return xTicksNames[val.toFixed(axis.tickDecimals)];
            }

            return '';
        }

        function yAxisTickFormatter(val, axis) {
            if (yTicksNames.hasOwnProperty(val.toFixed(axis.tickDecimals)) === true) {
                return yTicksNames[val.toFixed(axis.tickDecimals)];
            }

            return '';
        }
    }


});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

(function (requirejs, require, define) {

// VideoVolumeControl module.
define(
'video/07_video_volume_control.js',
[],
function () {

    // VideoVolumeControl() function - what this module "exports".
    return function (state) {
        state.videoVolumeControl = {};

        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoVolumeControl.onChange = _.bind(onChange, state);
        state.videoVolumeControl.toggleMute = _.bind(toggleMute, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their initial configuration. Also
    //     make the created DOM elements available via the 'state' object. Much easier to work this
    //     way - you don't have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoVolumeControl.el = state.el.find('div.volume');

        state.videoVolumeControl.buttonEl = state.videoVolumeControl.el.find('a');
        state.videoVolumeControl.volumeSliderEl = state.videoVolumeControl.el.find('.volume-slider');

        state.videoControl.secondaryControlsEl.prepend(state.videoVolumeControl.el);

        // Figure out what the current volume is. If no information about volume level could be retrieved,
        // then we will use the default 100 level (full volume).
        state.videoVolumeControl.currentVolume = parseInt($.cookie('video_player_volume_level'), 10);
        if (!isFinite(state.videoVolumeControl.currentVolume)) {
            state.videoVolumeControl.currentVolume = 100;
        }

        // Set it up so that muting/unmuting works correctly.
        state.videoVolumeControl.previousVolume = 100;

        state.videoVolumeControl.slider = state.videoVolumeControl.volumeSliderEl.slider({
            orientation: 'vertical',
            range: 'min',
            min: 0,
            max: 100,
            value: state.videoVolumeControl.currentVolume,
            change: state.videoVolumeControl.onChange,
            slide: state.videoVolumeControl.onChange
        });

        state.videoVolumeControl.el.toggleClass('muted', state.videoVolumeControl.currentVolume === 0);
    }

    /**
     * @desc Bind any necessary function callbacks to DOM events (click,
     *     mousemove, etc.).
     *
     * @type {function}
     * @access private
     *
     * @param {object} state The object containg the state of the video player.
     *     All other modules, their parameters, public variables, etc. are
     *     available via this object.
     *
     * @this {object} The global window object.
     *
     * @returns {undefined}
     */
    function _bindHandlers(state) {
        state.videoVolumeControl.buttonEl
            .on('click', state.videoVolumeControl.toggleMute);

        state.videoVolumeControl.el.on('mouseenter', function() {
            state.videoVolumeControl.el.addClass('open');
        });

        state.videoVolumeControl.el.on('mouseleave', function() {
            state.videoVolumeControl.el.removeClass('open');
        });

        // Attach a focus event to the volume button.
        state.videoVolumeControl.buttonEl.on('blur', function() {
            // If the focus is being trasnfered from the volume slider, then we
            // don't do anything except for unsetting the special flag.
            if (state.volumeBlur === true) {
                state.volumeBlur = false;
            }

            //If the focus is comming from elsewhere, then we must show the
            // volume slider and set focus to it.
            else {
                state.videoVolumeControl.el.addClass('open');
                state.videoVolumeControl.volumeSliderEl.find('a').focus();
            }
        });

        // Attach a blur event handler (loss of focus) to the volume slider
        // element. More specifically, we are attaching to the handle on
        // the slider with which you can change the volume.
        state.videoVolumeControl.volumeSliderEl.find('a')
            .on('blur', function () {
                // Hide the volume slider. This is done so that we can
                // continue to the next (or previous) element by tabbing.
                // Otherwise, after next tab we would come back to the volume
                // slider because it is the next element visible element that
                // we can tab to after the volume button.
                state.videoVolumeControl.el.removeClass('open');

                // Set focus to the volume button.
                state.videoVolumeControl.buttonEl.focus();

                // We store the fact that previous element that lost focus was
                // the volume clontrol.
                state.volumeBlur = true;
                // The following field is used in video_speed_control to track 
                // the element that had the focus before it.
                state.previousFocus = 'volume';
            });
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function onChange(event, ui) {
        this.videoVolumeControl.currentVolume = ui.value;
        this.videoVolumeControl.el.toggleClass('muted', this.videoVolumeControl.currentVolume === 0);

        $.cookie('video_player_volume_level', ui.value, {
            expires: 3650,
            path: '/'
        });

        this.trigger('videoPlayer.onVolumeChange', ui.value);
    }

    function toggleMute(event) {
        event.preventDefault();

        if (this.videoVolumeControl.currentVolume > 0) {
            this.videoVolumeControl.previousVolume = this.videoVolumeControl.currentVolume;
            this.videoVolumeControl.slider.slider('option', 'value', 0);
        } else {
            this.videoVolumeControl.slider.slider('option', 'value', this.videoVolumeControl.previousVolume);
        }
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('ElOutput', ['logme'], function (logme) {

    return ElOutput;

    function ElOutput(config, state) {

        if ($.isPlainObject(config.functions["function"])) {
            processFuncObj(config.functions["function"]);
        } else if ($.isArray(config.functions["function"])) {
            (function (c1) {
                while (c1 < config.functions["function"].length) {
                    if ($.isPlainObject(config.functions["function"][c1])) {
                        processFuncObj(config.functions["function"][c1]);
                    }

                    c1 += 1;
                }
            }(0));
        }

        return;

        function processFuncObj(obj) {
            var paramNames, funcString, func, el, disableAutoReturn, updateOnEvent;

            // We are only interested in functions that are meant for output to an
            // element.
            if (
                (typeof obj['@output'] !== 'string') ||
                ((obj['@output'].toLowerCase() !== 'element') && (obj['@output'].toLowerCase() !== 'none'))
            ) {
                return;
            }

            if (typeof obj['@el_id'] !== 'string') {
                logme('ERROR: You specified "output" as "element", but did not spify "el_id".');

                return;
            }

            if (typeof obj['#text'] !== 'string') {
                logme('ERROR: Function body is not defined.');

                return;
            }

            updateOnEvent = 'slide';
            if (
                (obj.hasOwnProperty('@update_on') === true) &&
                (typeof obj['@update_on'] === 'string') &&
                ((obj['@update_on'].toLowerCase() === 'slide') || (obj['@update_on'].toLowerCase() === 'change'))
            ) {
                updateOnEvent = obj['@update_on'].toLowerCase();
            }

            disableAutoReturn = obj['@disable_auto_return'];

            funcString = obj['#text'];

            if (
                (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
            ) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    logme(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            // Make sure that all HTML entities are converted to their proper
            // ASCII text equivalents.
            funcString = $('<div>').html(funcString).text();

            paramNames = state.getAllParameterNames();
            paramNames.push(funcString);

            try {
                func = Function.apply(null, paramNames);
            } catch (err) {
                logme(
                    'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                );
                logme('Error message: "' + err.message + '".');

                if (state.showDebugInfo) {
                    $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from string "' + funcString + '".' + '</div>');
                    $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                }

                paramNames.pop();

                return;
            }

            paramNames.pop();

            if (obj['@output'].toLowerCase() !== 'none') {
                el = $('#' + obj['@el_id']);

                if (el.length !== 1) {
                    logme(
                        'ERROR: DOM element with ID "' + obj['@el_id'] + '" ' +
                        'not found. Dynamic element not created.'
                    );

                    return;
                }

                el.html(func.apply(window, state.getAllParameterValues()));
            } else {
                el = null;
                func.apply(window, state.getAllParameterValues());
            }

            state.addDynamicEl(el, func, obj['@el_id'], updateOnEvent);
        }

    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

(function (requirejs, require, define) {

// VideoSpeedControl module.
define(
'video/08_video_speed_control.js',
[],
function () {

    // VideoSpeedControl() function - what this module "exports".
    return function (state) {
        state.videoSpeedControl = {};

        if (state.videoType === 'html5') {
            _initialize(state);
        } else if (state.videoType === 'youtube' && state.youtubeXhr) {
            state.youtubeXhr.done(function () {
                _initialize(state);
            });
        }

        if (state.videoType === 'html5' && !(_checkPlaybackRates())) {
            console.log(
                '[Video info]: HTML5 mode - playbackRate is not supported.'
            );

            _hideSpeedControl(state);

            return;
        }
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    function _initialize(state) {
        _makeFunctionsPublic(state);
        _renderElements(state);
        _bindHandlers(state);
    }

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called,
    //     these functions will get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoSpeedControl.changeVideoSpeed = _.bind(
            changeVideoSpeed, state
        );
        state.videoSpeedControl.setSpeed = _.bind(setSpeed, state);
        state.videoSpeedControl.reRender = _.bind(reRender, state);
    }

    // function _renderElements(state)
    //
    //     Create any necessary DOM elements, attach them, and set their
    //     initial configuration. Also make the created DOM elements available
    //     via the 'state' object. Much easier to work this way - you don't
    //     have to do repeated jQuery element selects.
    function _renderElements(state) {
        state.videoSpeedControl.speeds = state.speeds;

        state.videoSpeedControl.el = state.el.find('div.speeds');

        state.videoSpeedControl.videoSpeedsEl = state.videoSpeedControl.el
            .find('.video_speeds');

        state.videoControl.secondaryControlsEl.prepend(
            state.videoSpeedControl.el
        );

        $.each(state.videoSpeedControl.speeds, function (index, speed) {
            var link = '<a class="speed_link" href="#">' + speed + 'x</a>';

            state.videoSpeedControl.videoSpeedsEl
                .prepend(
                    $('<li data-speed="' + speed + '">' + link + '</li>')
                );
        });

        state.videoSpeedControl.setSpeed(state.speed);
    }

    /**
     * @desc Check if playbackRate supports by browser.
     *
     * @type {function}
     * @access private
     *
     * @param {object} state The object containg the state of the video player.
     *     All other modules, their parameters, public variables, etc. are
     *     available via this object.
     *
     * @this {object} The global window object.
     *
     * @returns {Boolean}
     *       true: Browser support playbackRate functionality.
     *       false: Browser doesn't support playbackRate functionality.
     */
    function _checkPlaybackRates() {
        var video = document.createElement('video');

        // If browser supports, 1.0 should be returned by playbackRate
        // property. In this case, function return True. Otherwise, False will
        // be returned.
        return Boolean(video.playbackRate);
    }

    // Hide speed control.
    function _hideSpeedControl(state) {
        state.el.find('div.speeds').hide();
    }

    /**
     * @desc Bind any necessary function callbacks to DOM events (click,
     *     mousemove, etc.).
     *
     * @type {function}
     * @access private
     *
     * @param {object} state The object containg the state of the video player.
     *     All other modules, their parameters, public variables, etc. are
     *     available via this object.
     *
     * @this {object} The global window object.
     *
     * @returns {undefined}
     */
    function _bindHandlers(state) {
        var speedLinks;

        state.videoSpeedControl.videoSpeedsEl.find('a')
            .on('click', state.videoSpeedControl.changeVideoSpeed);

        if (onTouchBasedDevice()) {
            state.videoSpeedControl.el.on('click', function (event) {
                // So that you can't highlight this control via a drag
                // operation, we disable the default browser actions on a
                // click event.
                event.preventDefault();

                state.videoSpeedControl.el.toggleClass('open');
            });
        } else {
            state.videoSpeedControl.el
                .on('mouseenter', function () {
                    state.videoSpeedControl.el.addClass('open');
                })
                .on('mouseleave', function () {
                    state.videoSpeedControl.el.removeClass('open');
                })
                .on('click', function (event) {
                    // So that you can't highlight this control via a drag
                    // operation, we disable the default browser actions on a
                    // click event.
                    event.preventDefault();

                    state.videoSpeedControl.el.removeClass('open');
                });

            // ******************************
            // The tabbing will cycle through the elements in the following
            // order:
            // 1. Play control
            // 2. Speed control
            // 3. Fastest speed called firstSpeed
            // 4. Intermediary speed called otherSpeed 
            // 5. Slowest speed called lastSpeed
            // 6. Volume control
            // This field will keep track of where the focus is coming from.
            state.previousFocus = '';

            // ******************************
            // Attach 'focus', and 'blur' events to the speed control which
            // either brings up the speed dialog with individual speed entries,
            // or closes it.
            state.videoSpeedControl.el.children('a')
                .on('focus', function () {
                    // If the focus is coming from the first speed entry 
                    // (tabbing backwards) or last speed entry (tabbing forward) 
                    // hide the speed entries dialog.
                    if (state.previousFocus === 'firstSpeed' ||
                        state.previousFocus === 'lastSpeed') {
                         state.videoSpeedControl.el.removeClass('open');
                    }
                })
                .on('blur', function () {
                    // When the focus leaves this element, the speed entries
                    // dialog will be shown.
                    
                    // If we are tabbing forward (previous focus is play
                    // control), we open the dialog and set focus on the first
                    // speed entry.
                    if (state.previousFocus === 'playPause') {
                        state.videoSpeedControl.el.addClass('open');
                        state.videoSpeedControl.videoSpeedsEl
                        .find('a.speed_link:first')
                        .focus();
                    }

                    // If we are tabbing backwards (previous focus is volume 
                    // control), we open the dialog and set focus on the 
                    // last speed entry.
                    if (state.previousFocus === 'volume') {
                        state.videoSpeedControl.el.addClass('open');
                        state.videoSpeedControl.videoSpeedsEl
                        .find('a.speed_link:last')
                        .focus();
                    }
                    
                });

            // ******************************
            // Attach 'blur' event to elements which represent individual speed
            // entries and use it to track the origin of the focus.
            speedLinks = state.videoSpeedControl.videoSpeedsEl
                .find('a.speed_link');

            speedLinks.first().on('blur', function () {
                // The previous focus is a speed entry (we are tabbing
                // backwards), the dialog will close, set focus on the speed
                // control and track the focus on first speed.
                if (state.previousFocus === 'otherSpeed') {
                    state.previousFocus = 'firstSpeed';
                    state.videoSpeedControl.el.children('a').focus();
                }    
            });

            // Track the focus on intermediary speeds.
            speedLinks
                .filter(function (index) {
                    return index === 1 || index === 2
                })
                .on('blur', function () {
                    state.previousFocus = 'otherSpeed';
                });

            speedLinks.last().on('blur', function () {
                // The previous focus is a speed entry (we are tabbing forward),
                // the dialog will close, set focus on the speed control and
                // track the focus on last speed.
                if (state.previousFocus === 'otherSpeed') {
                    state.previousFocus = 'lastSpeed';
                    state.videoSpeedControl.el.children('a').focus();
                }   
            });
            
        }
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this'
    // keyword) is the 'state' object. The magic private function that makes
    // them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    function setSpeed(speed) {
        this.videoSpeedControl.videoSpeedsEl.find('li').removeClass('active');
        this.videoSpeedControl.videoSpeedsEl
            .find("li[data-speed='" + speed + "']")
            .addClass('active');
        this.videoSpeedControl.el.find('p.active').html('' + speed + 'x');
    }

    function changeVideoSpeed(event) {
        var parentEl = $(event.target).parent();

        event.preventDefault();

        if (!parentEl.hasClass('active')) {
            this.videoSpeedControl.currentSpeed = parentEl.data('speed');

            this.videoSpeedControl.setSpeed(
                // To meet the API expected format.
                parseFloat(this.videoSpeedControl.currentSpeed)
                    .toFixed(2)
                    .replace(/\.00$/, '.0')
            );

            this.trigger(
                'videoPlayer.onSpeedChange',
                this.videoSpeedControl.currentSpeed
            );
        }
    }

    function reRender(params) {
        var _this = this;

        this.videoSpeedControl.videoSpeedsEl.empty();
        this.videoSpeedControl.videoSpeedsEl.find('li').removeClass('active');
        this.videoSpeedControl.speeds = params.newSpeeds;

        $.each(this.videoSpeedControl.speeds, function (index, speed) {
            var link, listItem;

            link = '<a class="speed_link" href="#">' + speed + 'x</a>';

            listItem = $('<li data-speed="' + speed + '">' + link + '</li>');

            if (speed === params.currentSpeed) {
                listItem.addClass('active');
            }

            _this.videoSpeedControl.videoSpeedsEl.prepend(listItem);
        });

        // Re-attach all events with their appropriate callbacks to the
        // newly generated elements.
        _bindHandlers(this);
    }

});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

(function (requirejs, require, define) {

// VideoCaption module.
define(
'video/09_video_caption.js',
[],
function () {

    /**
     * @desc VideoCaption module exports a function.
     *
     * @type {function}
     * @access public
     *
     * @param {object} state - The object containg the state of the video
     *     player. All other modules, their parameters, public variables, etc.
     *     are available via this object.
     *
     * @this {object} The global window object.
     *
     * @returns {undefined}
     */
    return function (state) {
        state.videoCaption = {};

        _makeFunctionsPublic(state);

        state.videoCaption.renderElements();
    };

    // ***************************************************************
    // Private functions start here.
    // ***************************************************************

    // function _makeFunctionsPublic(state)
    //
    //     Functions which will be accessible via 'state' object. When called, these functions will
    //     get the 'state' object as a context.
    function _makeFunctionsPublic(state) {
        state.videoCaption.autoShowCaptions    = _.bind(autoShowCaptions, state);
        state.videoCaption.autoHideCaptions    = _.bind(autoHideCaptions, state);
        state.videoCaption.resize              = _.bind(resize, state);
        state.videoCaption.toggle              = _.bind(toggle, state);
        state.videoCaption.onMouseEnter        = _.bind(onMouseEnter, state);
        state.videoCaption.onMouseLeave        = _.bind(onMouseLeave, state);
        state.videoCaption.onMovement          = _.bind(onMovement, state);
        state.videoCaption.renderCaption       = _.bind(renderCaption, state);
        state.videoCaption.captionHeight       = _.bind(captionHeight, state);
        state.videoCaption.topSpacingHeight    = _.bind(topSpacingHeight, state);
        state.videoCaption.bottomSpacingHeight = _.bind(bottomSpacingHeight, state);
        state.videoCaption.scrollCaption       = _.bind(scrollCaption, state);
        state.videoCaption.search              = _.bind(search, state);
        state.videoCaption.play                = _.bind(play, state);
        state.videoCaption.pause               = _.bind(pause, state);
        state.videoCaption.seekPlayer          = _.bind(seekPlayer, state);
        state.videoCaption.hideCaptions        = _.bind(hideCaptions, state);
        state.videoCaption.calculateOffset     = _.bind(calculateOffset, state);
        state.videoCaption.updatePlayTime      = _.bind(updatePlayTime, state);
        state.videoCaption.setSubtitlesHeight  = _.bind(setSubtitlesHeight, state);

        state.videoCaption.renderElements      = _.bind(renderElements, state);
        state.videoCaption.bindHandlers        = _.bind(bindHandlers, state);
        state.videoCaption.fetchCaption        = _.bind(fetchCaption, state);
        state.videoCaption.captionURL          = _.bind(captionURL, state);
    }

    // ***************************************************************
    // Public functions start here.
    // These are available via the 'state' object. Their context ('this' keyword) is the 'state' object.
    // The magic private function that makes them available and sets up their context is makeFunctionsPublic().
    // ***************************************************************

    /**
     * @desc Create any necessary DOM elements, attach them, and set their
     *     initial configuration. Also make the created DOM elements available
     *     via the 'state' object. Much easier to work this way - you don't
     *     have to do repeated jQuery element selects.
     *
     * @type {function}
     * @access public
     *
     * @this {object} - The object containg the state of the video
     *     player. All other modules, their parameters, public variables, etc.
     *     are available via this object.
     *
     * @returns {boolean}
     *     true: The function fethched captions successfully, and compltely
     *         rendered everything related to captions.
     *     false: The captions were not fetched. Nothing will be rendered,
     *         and the CC button will be hidden.
     */
    function renderElements() {
        this.videoCaption.loaded = false;

        this.videoCaption.subtitlesEl = this.el.find('ol.subtitles');
        this.videoCaption.hideSubtitlesEl = this.el.find('a.hide-subtitles');

        if (!this.videoCaption.fetchCaption()) {
            this.videoCaption.hideCaptions(true);
            this.videoCaption.hideSubtitlesEl.hide();
        }
    }

    // function bindHandlers()
    //
    //     Bind any necessary function callbacks to DOM events (click, mousemove, etc.).
    function bindHandlers() {
        $(window).bind('resize', this.videoCaption.resize);
        this.videoCaption.hideSubtitlesEl.on('click', this.videoCaption.toggle);

        this.videoCaption.subtitlesEl
            .on(
                'mouseenter',
                this.videoCaption.onMouseEnter
            ).on(
                'mouseleave',
                this.videoCaption.onMouseLeave
            ).on(
                'mousemove',
                this.videoCaption.onMovement
            ).on(
                'mousewheel',
                this.videoCaption.onMovement
            ).on(
                'DOMMouseScroll',
                this.videoCaption.onMovement
            );

        if (this.videoType === 'html5') {
            this.el.on('mousemove', this.videoCaption.autoShowCaptions);
            this.el.on('keydown', this.videoCaption.autoShowCaptions);

            // Moving slider on subtitles is not a mouse move,
            // but captions and controls should be showed.
            this.videoCaption.subtitlesEl.on('scroll', this.videoCaption.autoShowCaptions);
            this.videoCaption.subtitlesEl.on('scroll', this.videoControl.showControls);
        }
    }

    /**
     * @desc Fetch the caption file specified by the user. Upn successful
     *     receival of the file, the captions will be rendered.
     *
     * @type {function}
     * @access public
     *
     * @this {object} - The object containg the state of the video
     *     player. All other modules, their parameters, public variables, etc.
     *     are available via this object.
     *
     * @returns {boolean}
     *     true: The user specified a caption file. NOTE: if an error happens
     *         while the specified file is being retrieved (for example the
     *         file is missing on the server), this function will still return
     *         true.
     *     false: No caption file was specified, or an empty string was
     *         specified.
     */
    function fetchCaption() {
        var _this = this;

        // Check whether the captions file was specified. This is the point
        // where we either stop with the caption panel (so that a white empty
        // panel to the right of the video will not be shown), or carry on
        // further.
        if (!this.youtubeId('1.0')) {
            return false;
        }

        // Fetch the captions file. If no file was specified, or if an error
        // occurred, then we hide the captions panel, and the "CC" button
        $.ajaxWithPrefix({
            url: _this.videoCaption.captionURL(),
            notifyOnError: false,
            success: function (captions) {
                _this.videoCaption.captions = captions.text;
                _this.videoCaption.start = captions.start;
                _this.videoCaption.loaded = true;

                if (onTouchBasedDevice()) {
                    _this.videoCaption.subtitlesEl.find('li').html(
                        gettext(
                            'Caption will be displayed when ' +
                            'you start playing the video.'
                        )
                    );
                } else {
                    _this.videoCaption.renderCaption();
                }
            },
            error: function (jqXHR, textStatus, errorThrown) {
                console.log('ERROR while fetching captions.');
                console.log(
                    'STATUS:', textStatus + ', MESSAGE:', '' + errorThrown
                );

                _this.videoCaption.hideCaptions(true);
                _this.videoCaption.hideSubtitlesEl.hide();
            }
        });

        return true;
    }

    function captionURL() {
        return '' + this.config.caption_asset_path + this.youtubeId('1.0') + '.srt.sjson';
    }

    function autoShowCaptions(event) {
        if (!this.captionsShowLock) {
            if (!this.captionsHidden) {
                return;
            }

            this.captionsShowLock = true;

            if (this.captionState === 'invisible') {
                this.videoCaption.subtitlesEl.show();
                this.captionState = 'visible';
            } else if (this.captionState === 'hiding') {
                this.videoCaption.subtitlesEl.stop(true, false).css('opacity', 1).show();
                this.captionState = 'visible';
            } else if (this.captionState === 'visible') {
                clearTimeout(this.captionHideTimeout);
            }

            this.captionHideTimeout = setTimeout(this.videoCaption.autoHideCaptions, this.videoCaption.fadeOutTimeout);

            this.captionsShowLock = false;
        }
    }

    function autoHideCaptions() {
        var _this;

        this.captionHideTimeout = null;

        if (!this.captionsHidden) {
            return;
        }

        this.captionState = 'hiding';

        _this = this;

        this.videoCaption.subtitlesEl.fadeOut(this.videoCaption.fadeOutTimeout, function () {
            _this.captionState = 'invisible';
        });
    }

    function resize() {
        this.videoCaption.subtitlesEl
            .find('.spacing:first').height(this.videoCaption.topSpacingHeight())
            .find('.spacing:last').height(this.videoCaption.bottomSpacingHeight());

        this.videoCaption.scrollCaption();

        this.videoCaption.setSubtitlesHeight();
    }

    function onMouseEnter() {
        if (this.videoCaption.frozen) {
            clearTimeout(this.videoCaption.frozen);
        }

        this.videoCaption.frozen = setTimeout(this.videoCaption.onMouseLeave, 10000);
    }

    function onMouseLeave() {
        if (this.videoCaption.frozen) {
            clearTimeout(this.videoCaption.frozen);
        }

        this.videoCaption.frozen = null;

        if (this.videoCaption.playing) {
            this.videoCaption.scrollCaption();
        }
    }

    function onMovement() {
        this.videoCaption.onMouseEnter();
    }

    function renderCaption() {
        var container = $('<ol>'),
            _this = this;

        this.el.find('.video-wrapper').after(this.videoCaption.subtitlesEl);
        this.el.find('.video-controls .secondary-controls').append(this.videoCaption.hideSubtitlesEl);

        this.videoCaption.setSubtitlesHeight();

        if (this.videoType === 'html5') {
            this.videoCaption.fadeOutTimeout = this.config.fadeOutTimeout;

            this.videoCaption.subtitlesEl.addClass('html5');
            this.captionHideTimeout = setTimeout(this.videoCaption.autoHideCaptions, this.videoCaption.fadeOutTimeout);
        }

        this.videoCaption.hideCaptions(this.hide_captions);

        this.videoCaption.bindHandlers();

        $.each(this.videoCaption.captions, function(index, text) {
            var liEl = $('<li>');

            liEl.html(text);

            liEl.attr({
                'data-index': index,
                'data-start': _this.videoCaption.start[index]
            });

            container.append(liEl);
        });

        this.videoCaption.subtitlesEl.html(container.html());

        this.videoCaption.subtitlesEl.find('li[data-index]').on('click', this.videoCaption.seekPlayer);

        this.videoCaption.subtitlesEl.prepend($('<li class="spacing">').height(this.videoCaption.topSpacingHeight()));
        this.videoCaption.subtitlesEl.append($('<li class="spacing">').height(this.videoCaption.bottomSpacingHeight()));

        this.videoCaption.rendered = true;
    }

    function scrollCaption() {
        var el = this.videoCaption.subtitlesEl.find('.current:first');

        if (!this.videoCaption.frozen && el.length) {
            this.videoCaption.subtitlesEl.scrollTo(
                el,
                {
                    offset: -this.videoCaption.calculateOffset(el)
                }
            );
        }
    }

    function search(time) {
        var index, max, min;

        if (this.videoCaption.loaded) {
            min = 0;
            max = this.videoCaption.start.length - 1;

            while (min < max) {
                index = Math.ceil((max + min) / 2);

                if (time < this.videoCaption.start[index]) {
                    max = index - 1;
                }

                if (time >= this.videoCaption.start[index]) {
                    min = index;
                }
            }

            return min;
        }

        return undefined;
    }

    function play() {
        if (this.videoCaption.loaded) {
            if (!this.videoCaption.rendered) {
                this.videoCaption.renderCaption();
            }

            this.videoCaption.playing = true;
        }
    }

    function pause() {
        if (this.videoCaption.loaded) {
            this.videoCaption.playing = false;
        }
    }

    function updatePlayTime(time) {
        var newIndex;

        if (this.videoCaption.loaded) {
            // Current mode === 'flash' can only be for YouTube videos. So, we
            // don't have to also check for videoType === 'youtube'.
            if (this.currentPlayerMode === 'flash') {
                // Total play time changes with speed change. Also there is
                // a 250 ms delay we have to take into account.
                time = Math.round(
                    Time.convert(time, this.speed, '1.0') * 1000 + 250
                );
            } else {
                // Total play time remains constant when speed changes.
                time = Math.round(parseInt(time, 10) * 1000);
            }

            newIndex = this.videoCaption.search(time);

            if (
                newIndex !== void 0 &&
                this.videoCaption.currentIndex !== newIndex
            ) {
                if (this.videoCaption.currentIndex) {
                    this.videoCaption.subtitlesEl
                        .find('li.current')
                        .removeClass('current');
                }

                this.videoCaption.subtitlesEl
                    .find("li[data-index='" + newIndex + "']")
                    .addClass('current');

                this.videoCaption.currentIndex = newIndex;

                this.videoCaption.scrollCaption();
            }
        }
    }

    function seekPlayer(event) {
        var time;

        event.preventDefault();

        // Current mode === 'flash' can only be for YouTube videos. So, we
        // don't have to also check for videoType === 'youtube'.
        if (this.currentPlayerMode === 'flash') {
            // Total play time changes with speed change. Also there is
            // a 250 ms delay we have to take into account.
            time = Math.round(
                Time.convert(
                    $(event.target).data('start'), '1.0', this.speed
                ) / 1000
            );
        } else {
            // Total play time remains constant when speed changes.
            time = parseInt($(event.target).data('start'), 10)/1000;
        }

        this.trigger(
            'videoPlayer.onCaptionSeek',
            {
                'type': 'onCaptionSeek',
                'time': time
            }
        );
    }

    function calculateOffset(element) {
        return this.videoCaption.captionHeight() / 2 - element.height() / 2;
    }

    function topSpacingHeight() {
        return this.videoCaption.calculateOffset(this.videoCaption.subtitlesEl.find('li:not(.spacing):first'));
    }

    function bottomSpacingHeight() {
        return this.videoCaption.calculateOffset(this.videoCaption.subtitlesEl.find('li:not(.spacing):last'));
    }

    function toggle(event) {
        event.preventDefault();

        if (this.el.hasClass('closed')) {
            this.videoCaption.hideCaptions(false);
        } else {
            this.videoCaption.hideCaptions(true);
        }
    }

    function hideCaptions(hide_captions) {
        var type;

        if (hide_captions) {
            type = 'hide_transcript';
            this.captionsHidden = true;
            this.videoCaption.hideSubtitlesEl.attr('title', gettext('Turn on captions'));
            this.el.addClass('closed');
        } else {
            type = 'show_transcript';
            this.captionsHidden = false;
            this.videoCaption.hideSubtitlesEl.attr('title', gettext('Turn off captions'));
            this.el.removeClass('closed');
            this.videoCaption.scrollCaption();
        }

        if (this.videoPlayer) {
            this.videoPlayer.log(type, {
                currentTime: this.videoPlayer.currentTime
            });
        }

        this.videoCaption.setSubtitlesHeight();

        $.cookie('hide_captions', hide_captions, {
            expires: 3650,
            path: '/'
        });
    }

    function captionHeight() {
        if (this.isFullScreen) {
            return $(window).height() - this.el.find('.video-controls').height() -
                    0.5 * this.videoControl.sliderEl.height() -
                    2 * parseInt(this.videoCaption.subtitlesEl.css('padding-top'), 10);
        } else {
            return this.el.find('.video-wrapper').height();
        }
    }

    function setSubtitlesHeight() {
        var height = 0;
        if (this.videoType === 'html5'){
            // on page load captionHidden = undefined
            if  (
                (this.captionsHidden === undefined && this.hide_captions === true ) ||
                (this.captionsHidden === true) ) {
                // In case of html5 autoshowing subtitles,
                // we ajdust height of subs, by height of scrollbar
                height = this.videoControl.el.height() + 0.5 * this.videoControl.sliderEl.height();
                // height of videoControl does not contain height of slider.
                // (css is set to absolute, to avoid yanking when slider autochanges its height)
            }
        }
        this.videoCaption.subtitlesEl.css({
            maxHeight: this.videoCaption.captionHeight() - height
        });
     }
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));

// Wrapper for RequireJS. It will make the standard requirejs(), require(), and
// define() functions from Require JS available inside the anonymous function.
(function (requirejs, require, define) {

define('GLabelElOutput', ['logme'], function (logme) {
    return GLabelElOutput;

    function GLabelElOutput(config, state) {
        if ($.isPlainObject(config.functions["function"])) {
            processFuncObj(config.functions["function"]);
        } else if ($.isArray(config.functions["function"])) {
            (function (c1) {
                while (c1 < config.functions["function"].length) {
                    if ($.isPlainObject(config.functions["function"][c1])) {
                        processFuncObj(config.functions["function"][c1]);
                    }

                    c1 += 1;
                }
            }(0));
        }

        return;

        function processFuncObj(obj) {
            var paramNames, funcString, func, disableAutoReturn;

            // We are only interested in functions that are meant for output to an
            // element.
            if (
                (typeof obj['@output'] !== 'string') ||
                (obj['@output'].toLowerCase() !== 'plot_label')
            ) {
                return;
            }

            if (typeof obj['@el_id'] !== 'string') {
                logme('ERROR: You specified "output" as "plot_label", but did not spify "el_id".');

                return;
            }

            if (typeof obj['#text'] !== 'string') {
                logme('ERROR: Function body is not defined.');

                return;
            }

            disableAutoReturn = obj['@disable_auto_return'];

            funcString = obj['#text'];

            if (
                (disableAutoReturn === undefined) ||
                    (
                        (typeof disableAutoReturn === 'string') &&
                        (disableAutoReturn.toLowerCase() !== 'true')
                    )
            ) {
                if (funcString.search(/return/i) === -1) {
                    funcString = 'return ' + funcString;
                }
            } else {
                if (funcString.search(/return/i) === -1) {
                    logme(
                        'ERROR: You have specified a JavaScript ' +
                        'function without a "return" statemnt. Your ' +
                        'function will return "undefined" by default.'
                    );
                }
            }

            // Make sure that all HTML entities are converted to their proper
            // ASCII text equivalents.
            funcString = $('<div>').html(funcString).text();

            paramNames = state.getAllParameterNames();
            paramNames.push(funcString);

            try {
                func = Function.apply(null, paramNames);
            } catch (err) {
                logme(
                    'ERROR: The function body "' +
                        funcString +
                        '" was not converted by the Function constructor.'
                );
                logme('Error message: "' + err.message + '".');

                if (state.showDebugInfo) {
                    $('#' + gstId).html('<div style="color: red;">' + 'ERROR IN XML: Could not create a function from string "' + funcString + '".' + '</div>');
                    $('#' + gstId).append('<div style="color: red;">' + 'Error message: "' + err.message + '".' + '</div>');
                }

                paramNames.pop();

                return;
            }

            paramNames.pop();

            state.plde.push({
                'elId': obj['@el_id'],
                'func': func
            });
        }

    }
});

// End of wrapper for RequireJS. As you can see, we are passing
// namespaced Require JS variables to an anonymous function. Within
// it, you can use the standard requirejs(), require(), and define()
// functions as if they were in the global namespace.
}(RequireJS.requirejs, RequireJS.require, RequireJS.define)); // End-of: (function (requirejs, require, define)

/*
 * We will add a function that will be called for all GraphicalSliderTool
 * xmodule module instances. It must be available globally by design of
 * xmodule.
 */
window.GraphicalSliderTool = function (el) {
    // All the work will be performed by the GstMain module. We will get access
    // to it, and all it's dependencies, via Require JS. Currently Require JS
    // is namespaced and is available via a global object RequireJS.
    RequireJS.require(['GstMain'], function (GstMain) {
        // The GstMain module expects the DOM ID of a Graphical Slider Tool
        // element. Since we are given a <section> element which might in
        // theory contain multiple graphical_slider_tool <div> elements (each
        // with a unique DOM ID), we will iterate over all children, and for
        // each match, we will call GstMain module.
        $(el).children('.graphical_slider_tool').each(function (index, value) {
            JavascriptLoader.executeModuleScripts($(value), function(){
                GstMain($(value).attr('id'));
            });
        });
    });
};

(function (requirejs, require, define) {

// Main module.
require(
[
    'video/01_initialize.js',
    'video/04_video_control.js',
    'video/05_video_quality_control.js',
    'video/06_video_progress_slider.js',
    'video/07_video_volume_control.js',
    'video/08_video_speed_control.js',
    'video/09_video_caption.js'
],
function (
    Initialize,
    VideoControl,
    VideoQualityControl,
    VideoProgressSlider,
    VideoVolumeControl,
    VideoSpeedControl,
    VideoCaption
) {
    var previousState,
        youtubeXhr = null;

    // Because this constructor can be called multiple times on a single page (when
    // the user switches verticals, the page doesn't reload, but the content changes), we must
    // will check each time if there is a previous copy of 'state' object. If there is, we
    // will make sure that copy exists cleanly. We have to do this because when verticals switch,
    // the code does not handle any Xmodule JS code that is running - it simply removes DOM
    // elements from the page. Any functions that were running during this, and that will run
    // afterwards (expecting the DOM elements to be present) must be stopped by hand.
    previousState = null;

    window.Video = function (element) {
        var state;

        // Stop bufferization of previous video on sequence change.
        // Problem: multiple video tags with the same src cannot
        // play together. The second tag waiting when first video will be fully loaded.
        // That's why we abort bufferization forcibly.
        $(element).closest('.sequence').bind('sequence:change', function(e){
            if (previousState !== null && typeof previousState.videoPlayer !== 'undefined') {
                previousState.stopBuffering();
                $(e.currentTarget).unbind('sequence:change');
            }
        });

        // Check for existance of previous state, uninitialize it if necessary, and create a new state.
        // Store new state for future invocation of this module consturctor function.
        if (previousState !== null && typeof previousState.videoPlayer !== 'undefined') {
            previousState.videoPlayer.onPause();
        }
        state = {};
        previousState = state;

        state.youtubeXhr = youtubeXhr;
        Initialize(state, element);
        if (!youtubeXhr) {
            youtubeXhr = state.youtubeXhr;
        }

        VideoControl(state);
        VideoQualityControl(state);
        VideoProgressSlider(state);
        VideoVolumeControl(state);
        VideoSpeedControl(state);
        VideoCaption(state);

        // Because the 'state' object is only available inside this closure, we will also make
        // it available to the caller by returning it. This is necessary so that we can test
        // Video with Jasmine.
        return state;
    };

    window.Video.clearYoutubeXhr = function () {
        youtubeXhr = null;
    };
});

}(RequireJS.requirejs, RequireJS.require, RequireJS.define));
